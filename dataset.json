[
  {
    "question": "What is the current building key, building street address, city, state, and postal code of the history department?",
    "db_id": "dw",
    "sql": "SELECT DISTINCT d.FCLT_BUILDING_KEY, e.BUILDING_STREET_ADDRESS, d.CITY, d.STATE, d.POSTAL_CODE FROM FCLT_BUILDING_ADDRESS d JOIN FCLT_ROOMS a ON a.FCLT_BUILDING_KEY = d.FCLT_BUILDING_KEY JOIN FCLT_ORG_DLC_KEY b ON a.FCLT_ORGANIZATION_KEY = b.FCLT_ORGANIZATION_KEY JOIN MASTER_DEPT_HIERARCHY c ON b.DLC_KEY = c.DLC_KEY JOIN BUILDINGS e ON e.BUILDING_KEY = d.FCLT_BUILDING_KEY WHERE lower(c.DLC_NAME) = lower('History') AND d.ADDRESS_PURPOSE = 'STREET';",
    "gold_tables": [
      "dw#sep#FCLT_BUILDING_ADDRESS",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_ORG_DLC_KEY",
      "dw#sep#MASTER_DEPT_HIERARCHY",
      "dw#sep#BUILDINGS"
    ],
    "mapping": {
      "building key": [
        "FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY"
      ],
      "building street address": [
        "BUILDINGS.BUILDING_STREET_ADDRESS",
        "FCLT_BUILDING_ADDRESS.ADDRESS_PURPOSE"
      ],
      "city": [
        "FCLT_BUILDING_ADDRESS.CITY"
      ],
      "state": [
        "FCLT_BUILDING_ADDRESS.STATE"
      ],
      "postal code": [
        "FCLT_BUILDING_ADDRESS.POSTAL_CODE"
      ],
      "history department": [
        "MASTER_DEPT_HIERARCHY.DLC_NAME"
      ]
    },
    "join_keys": [
      [
        "FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY",
        "FCLT_ROOMS.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_ROOMS.FCLT_ORGANIZATION_KEY",
        "FCLT_ORG_DLC_KEY.FCLT_ORGANIZATION_KEY"
      ],
      [
        "FCLT_ORG_DLC_KEY.DLC_KEY",
        "MASTER_DEPT_HIERARCHY.DLC_KEY"
      ],
      [
        "FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY",
        "BUILDINGS.BUILDING_KEY"
      ]
    ],
    "sample_id": 0
  },
  {
    "question": "Show the unique activity titles, locations, term start date, and supervisor name for all independent activities, sorted by the ascending order of start date.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT a.activity_title, d.session_location, c.term_start_date, b.person_name AS Leader FROM iap_subject_detail a JOIN iap_subject_person b ON a.iap_subject_person_key = b.iap_subject_person_key JOIN academic_terms_all c ON c.term_code = a.term_code JOIN iap_subject_session d ON a.iap_subject_session_key = d.iap_subject_session_key WHERE b.person_role = 'Activity leader' ORDER BY term_start_date ASC;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#IAP_SUBJECT_PERSON",
      "dw#sep#ACADEMIC_TERMS_ALL",
      "dw#sep#IAP_SUBJECT_SESSION"
    ],
    "mapping": {
      "activity titles": [
        "IAP_SUBJECT_DETAIL.ACTIVITY_TITLE"
      ],
      "locations": [
        "IAP_SUBJECT_SESSION.SESSION_LOCATION"
      ],
      "term start date": [
        "ACADEMIC_TERMS_ALL.TERM_START_DATE"
      ],
      "supervisor name": [
        "IAP_SUBJECT_PERSON.PERSON_NAME",
        "IAP_SUBJECT_PERSON.PERSON_ROLE"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_PERSON.IAP_SUBJECT_PERSON_KEY",
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_PERSON_KEY"
      ],
      [
        "ACADEMIC_TERMS_ALL.TERM_CODE",
        "IAP_SUBJECT_DETAIL.TERM_CODE"
      ],
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY",
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY"
      ]
    ],
    "sample_id": 1
  },
  {
    "question": "List the unique course instructor names, course titles, and the amount of material for each course instructor key and the key of subject offered.",
    "db_id": "dw",
    "sql": "SELECT lci.LIBRARY_COURSE_INSTRUCTOR_KEY, lso.LIBRARY_SUBJECT_OFFERED_KEY, lci.instructor_name, lso.subject_title, COUNT(DISTINCT lrmd.LIBRARY_RESERVE_CATALOG_KEY) AS material_count FROM LIBRARY_COURSE_INSTRUCTOR lci JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY JOIN LIBRARY_SUBJECT_OFFERED lso ON lso.LIBRARY_SUBJECT_OFFERED_KEY = lrmd.LIBRARY_SUBJECT_OFFERED_KEY GROUP BY lci.LIBRARY_COURSE_INSTRUCTOR_KEY, lso.LIBRARY_SUBJECT_OFFERED_KEY, lci.instructor_name, lso.subject_title;",
    "gold_tables": [
      "dw#sep#LIBRARY_COURSE_INSTRUCTOR",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_SUBJECT_OFFERED",
      "dw#sep#LIBRARY_RESERVE_CATALOG"
    ],
    "mapping": {
      "course instructor names": [
        "LIBRARY_COURSE_INSTRUCTOR.INSTRUCTOR_NAME"
      ],
      "course titles": [
        "LIBRARY_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "amount of material": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_ISBN"
      ],
      "course instructor key": [
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ],
      "key of subject offered": [
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY"
      ]
    ],
    "sample_id": 2
  },
  {
    "question": "What is the room, floor, building key, building street address, city, state, and postal code of Professor Summer Haynes's office?",
    "db_id": "dw",
    "sql": "SELECT DISTINCT fac_rooms.Room, fac_rooms.floor, fac_building_address.BUILDING_KEY, BUILDINGS.BUILDING_STREET_ADDRESS, fac_building_address.CITY, fac_building_address.STATE, fac_building_address.POSTAL_CODE FROM (SELECT office_location FROM employee_directory WHERE full_name = 'Haynes, Summer') AS emp_office JOIN fac_rooms ON emp_office.office_location = fac_rooms.fac_room_key JOIN fac_building_address ON fac_rooms.building_key = fac_building_address.BUILDING_KEY JOIN BUILDINGS ON BUILDINGS.BUILDING_KEY = fac_building_address.BUILDING_KEY WHERE fac_building_address.ADDRESS_PURPOSE = 'STREET';",
    "gold_tables": [
      "dw#sep#EMPLOYEE_DIRECTORY",
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_BUILDING_ADDRESS",
      "dw#sep#BUILDINGS"
    ],
    "mapping": {
      "room": [
        "FAC_ROOMS.ROOM"
      ],
      "floor": [
        "FAC_ROOMS.FLOOR"
      ],
      "building key": [
        "FAC_BUILDING_ADDRESS.BUILDING_KEY"
      ],
      "building street address": [
        "BUILDINGS.BUILDING_STREET_ADDRESS",
        "FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE"
      ],
      "city": [
        "FAC_BUILDING_ADDRESS.CITY"
      ],
      "state": [
        "FAC_BUILDING_ADDRESS.STATE"
      ],
      "postal code": [
        "FAC_BUILDING_ADDRESS.POSTAL_CODE"
      ],
      "Professor Summer Haynes": [
        "EMPLOYEE_DIRECTORY.FULL_NAME"
      ],
      "office": [
        "EMPLOYEE_DIRECTORY.OFFICE_LOCATION"
      ]
    },
    "join_keys": [
      [
        "EMPLOYEE_DIRECTORY.OFFICE_LOCATION",
        "FAC_ROOMS.FAC_ROOM_KEY"
      ],
      [
        "FAC_BUILDING_ADDRESS.BUILDING_KEY",
        "FAC_ROOMS.BUILDING_KEY"
      ],
      [
        "BUILDINGS.BUILDING_KEY",
        "FAC_BUILDING_ADDRESS.BUILDING_KEY"
      ]
    ],
    "sample_id": 3
  },
  {
    "question": "List the unique full room names, their corresponding building names, street addresses, cities, states, postal codes, and building heights for rooms associated with subjects that Computer Science students can enroll in.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT fr.ROOM_FULL_NAME, b.BUILDING_NAME, b.BUILDING_STREET_ADDRESS, fba.CITY, fba.STATE, fba.POSTAL_CODE, fb.BUILDING_HEIGHT FROM COURSE_CATALOG_SUBJECT_OFFERED JOIN FCLT_ROOMS fr ON MEET_PLACE = FCLT_ROOM_KEY JOIN FCLT_BUILDING_ADDRESS fba ON fba.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY JOIN FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY JOIN BUILDINGS b ON b.BUILDING_KEY = fr.FCLT_BUILDING_KEY WHERE DEPARTMENT_NAME = 'Electrical Eng & Computer Sci' AND fba.ADDRESS_PURPOSE = 'STREET';",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_BUILDING_ADDRESS",
      "dw#sep#FCLT_BUILDING",
      "dw#sep#BUILDINGS"
    ],
    "mapping": {
      "full room names": [
        "FCLT_ROOMS.ROOM_FULL_NAME"
      ],
      "building names": [
        "BUILDINGS.BUILDING_NAME"
      ],
      "street addresses": [
        "BUILDINGS.BUILDING_STREET_ADDRESS",
        "FCLT_BUILDING_ADDRESS.ADDRESS_PURPOSE"
      ],
      "cities": [
        "FCLT_BUILDING_ADDRESS.CITY"
      ],
      "states": [
        "FCLT_BUILDING_ADDRESS.STATE"
      ],
      "postal codes": [
        "FCLT_BUILDING_ADDRESS.POSTAL_CODE"
      ],
      "building heights": [
        "FCLT_BUILDING.BUILDING_HEIGHT"
      ],
      "Computer Science": [
        "COURSE_CATALOG_SUBJECT_OFFERED.DEPARTMENT_NAME"
      ]
    },
    "join_keys": [
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.MEET_PLACE",
        "FCLT_ROOMS.FCLT_ROOM_KEY"
      ],
      [
        "FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY",
        "FCLT_ROOMS.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_BUILDING.FCLT_BUILDING_KEY",
        "FCLT_ROOMS.FCLT_BUILDING_KEY"
      ],
      [
        "BUILDINGS.BUILDING_KEY",
        "FCLT_ROOMS.FCLT_BUILDING_KEY"
      ]
    ],
    "sample_id": 4
  },
  {
    "question": "List the unique term code, subject title, room, floor, building key, building street address, city, state, and postal code, formats, and number of enrolled students for all courses with more than 300 attendees.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT s.TERM_CODE, s.subject_title, fr.room, fr.floor, b.BUILDING_KEY, b.BUILDING_STREET_ADDRESS, fba.CITY, fba.STATE, fba.POSTAL_CODE, s.form_type, s.num_enrolled_students FROM subject_offered s JOIN FCLT_ROOMS fr ON MEET_PLACE = FCLT_ROOM_KEY JOIN FCLT_BUILDING_ADDRESS fba ON fba.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY JOIN BUILDINGS b ON fr.FCLT_BUILDING_KEY = b.BUILDING_KEY WHERE s.num_enrolled_students > 300 AND fba.ADDRESS_PURPOSE = 'STREET';",
    "gold_tables": [
      "dw#sep#SUBJECT_OFFERED",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_BUILDING_ADDRESS",
      "dw#sep#BUILDINGS"
    ],
    "mapping": {
      "term code": [
        "SUBJECT_OFFERED.TERM_CODE"
      ],
      "subject title": [
        "SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "room": [
        "FCLT_ROOMS.ROOM"
      ],
      "floor": [
        "FCLT_ROOMS.FLOOR"
      ],
      "building key": [
        "BUILDINGS.BUILDING_KEY"
      ],
      "building street address": [
        "BUILDINGS.BUILDING_STREET_ADDRESS",
        "FCLT_BUILDING_ADDRESS.ADDRESS_PURPOSE"
      ],
      "city": [
        "FCLT_BUILDING_ADDRESS.CITY"
      ],
      "state": [
        "FCLT_BUILDING_ADDRESS.STATE"
      ],
      "postal code": [
        "FCLT_BUILDING_ADDRESS.POSTAL_CODE"
      ],
      "formats": [
        "SUBJECT_OFFERED.FORM_TYPE"
      ],
      "number of enrolled students": [
        "SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS"
      ],
      "attendees": [
        "SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS"
      ]
    },
    "join_keys": [
      [
        "FCLT_ROOMS.FCLT_ROOM_KEY",
        "SUBJECT_OFFERED.MEET_PLACE"
      ],
      [
        "FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY",
        "FCLT_ROOMS.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_ROOMS.FCLT_BUILDING_KEY",
        "BUILDINGS.BUILDING_KEY"
      ]
    ],
    "sample_id": 5
  },
  {
    "question": "What are the subject titles, their material titles, ISBN numbers, new shelf prices, and total costs of new materials for each subject title, sorted by individual item prices in ascending order?",
    "db_id": "dw",
    "sql": "WITH deduped AS (SELECT DISTINCT tso.SUBJECT_TITLE, tm.title, tm.isbn, tm.new_shelf_price FROM tip_material tm JOIN TIP_DETAIL td ON tm.TIP_MATERIAL_KEY = td.TIP_MATERIAL_KEY JOIN TIP_SUBJECT_OFFERED tso ON tso.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY) SELECT SUBJECT_TITLE, title, isbn, new_shelf_price, SUM(new_shelf_price) OVER(PARTITION BY SUBJECT_TITLE) AS total_cost FROM deduped ORDER BY new_shelf_price ASC;",
    "gold_tables": [
      "dw#sep#TIP_MATERIAL",
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_SUBJECT_OFFERED"
    ],
    "mapping": {
      "subject titles": [
        "TIP_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "material titles": [
        "TIP_MATERIAL.TITLE"
      ],
      "ISBN numbers": [
        "TIP_MATERIAL.ISBN"
      ],
      "new shelf prices": [
        "TIP_MATERIAL.NEW_SHELF_PRICE"
      ],
      "cost of new materials": [
        "TIP_MATERIAL.NEW_SHELF_PRICE"
      ]
    },
    "join_keys": [
      [
        "TIP_MATERIAL.TIP_MATERIAL_KEY",
        "TIP_DETAIL.TIP_MATERIAL_KEY"
      ],
      [
        "TIP_SUBJECT_OFFERED.SUBJECT_ID",
        "TIP_DETAIL.SUBJECT_ID"
      ]
    ],
    "sample_id": 6
  },
  {
    "question": "List the long names of buildings constructed before 1950 that have more than 100 employees, the built year of the building, and number of employees.",
    "db_id": "dw",
    "sql": "WITH building_current AS (SELECT FCLT_BUILDING_KEY, BUILDING_NAME_LONG, EXTRACT(YEAR FROM STR_TO_DATE(DATE_BUILT, '%m/%d/%Y')) AS year_built, ROW_NUMBER() OVER (PARTITION BY FCLT_BUILDING_KEY ORDER BY CAST(FISCAL_PERIOD AS UNSIGNED) DESC) AS rn FROM FCLT_BUILDING_HIST) SELECT b.BUILDING_NAME_LONG, b.year_built, COUNT(DISTINCT ed.MIT_ID) AS num_employees FROM building_current b JOIN FCLT_ROOMS r ON r.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY JOIN (SELECT DISTINCT MIT_ID, OFFICE_LOCATION FROM EMPLOYEE_DIRECTORY) ed ON ed.OFFICE_LOCATION = r.BUILDING_ROOM WHERE b.rn = 1 AND b.year_built < 1950 GROUP BY b.FCLT_BUILDING_KEY, b.BUILDING_NAME_LONG, b.year_built HAVING COUNT(DISTINCT ed.MIT_ID) > 100 ORDER BY b.BUILDING_NAME_LONG;",
    "gold_tables": [
      "dw#sep#FCLT_BUILDING_HIST",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#EMPLOYEE_DIRECTORY"
    ],
    "mapping": {
      "long names of buildings": [
        "FCLT_BUILDING_HIST.BUILDING_NAME_LONG"
      ],
      "built year": [
        "FCLT_BUILDING_HIST.DATE_BUILT"
      ],
      "employees": [
        "EMPLOYEE_DIRECTORY.MIT_ID"
      ]
    },
    "join_keys": [
      [
        "EMPLOYEE_DIRECTORY.OFFICE_LOCATION",
        "FCLT_ROOMS.BUILDING_ROOM"
      ]
    ],
    "sample_id": 7
  },
  {
    "question": "What is the name of the building that accomodates the most students, and how many students does it accomodate?",
    "db_id": "dw",
    "sql": "SELECT DISTINCT building_name, num_students FROM (SELECT fclt_building_key, COUNT(DISTINCT full_name) AS num_students FROM fclt_rooms JOIN mit_student_directory ON office_location = BUILDING_ROOM GROUP BY fclt_building_key) AS a JOIN fclt_building ON a.fclt_building_key = fclt_building.fclt_building_key JOIN (SELECT MAX(num_students) AS max_num_students FROM (SELECT fclt_building_key, COUNT(DISTINCT full_name) AS num_students FROM fclt_rooms JOIN mit_student_directory ON office_location = BUILDING_ROOM GROUP BY fclt_building_key) AS subquery1) AS b ON a.num_students = b.max_num_students;",
    "gold_tables": [
      "dw#sep#FCLT_ROOMS",
      "dw#sep#MIT_STUDENT_DIRECTORY",
      "dw#sep#FCLT_BUILDING"
    ],
    "mapping": {
      "name of the building": [
        "FCLT_BUILDING.BUILDING_NAME"
      ],
      "students": [
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ]
    },
    "join_keys": [
      [
        "FCLT_ROOMS.BUILDING_ROOM",
        "MIT_STUDENT_DIRECTORY.OFFICE_LOCATION"
      ],
      [
        "FCLT_ROOMS.BUILDING_ROOM",
        "MIT_STUDENT_DIRECTORY.OFFICE_LOCATION"
      ]
    ],
    "sample_id": 8
  },
  {
    "question": "List the name and floor of the building with the largest floor number.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT b.BUILDING_NAME, f.FLOOR FROM FAC_FLOOR f JOIN FAC_BUILDING b ON f.BUILDING_KEY = b.FAC_BUILDING_KEY WHERE CAST(f.LEVEL_ID AS SIGNED) = (SELECT MAX(CAST(LEVEL_ID AS SIGNED)) FROM FAC_FLOOR WHERE LEVEL_ID IS NOT NULL);",
    "gold_tables": [
      "dw#sep#FAC_FLOOR",
      "dw#sep#FAC_BUILDING"
    ],
    "mapping": {
      "name": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "floor": [
        "FAC_FLOOR.FLOOR"
      ]
    },
    "join_keys": [
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_FLOOR.BUILDING_KEY"
      ]
    ],
    "sample_id": 9
  },
  {
    "question": "For each IAP category and academic year, list the category name, academic year, total fee collected, total number of IAP subjects, and the minimum and maximum enrollment.",
    "db_id": "dw",
    "sql": "SELECT isc.IAP_CATEGORY_NAME, ty.ACADEMIC_YEAR, SUM(deduped.FEE) AS Total_Fee, COUNT(DISTINCT deduped.ACTIVITY_TITLE) AS Total_Subjects, MIN(deduped.MAX_ENROLLMENT) AS Min_Attendance, MAX(deduped.MAX_ENROLLMENT) AS Max_Attendance FROM (SELECT DISTINCT ACTIVITY_TITLE, TERM_CODE, IAP_SUBJECT_CATEGORY_KEY, FEE, MAX_ENROLLMENT FROM IAP_SUBJECT_DETAIL) deduped JOIN IAP_SUBJECT_CATEGORY isc ON deduped.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY JOIN (SELECT DISTINCT ACADEMIC_TERM_CODE, ACADEMIC_YEAR FROM TIME_DAY) ty ON deduped.TERM_CODE = ty.ACADEMIC_TERM_CODE GROUP BY isc.IAP_CATEGORY_NAME, ty.ACADEMIC_YEAR;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#IAP_SUBJECT_CATEGORY",
      "dw#sep#TIME_DAY"
    ],
    "mapping": {
      "category name": [
        "IAP_SUBJECT_CATEGORY.IAP_CATEGORY_NAME"
      ],
      "academic year": [
        "TIME_DAY.ACADEMIC_YEAR"
      ],
      "fee collected": [
        "IAP_SUBJECT_DETAIL.FEE"
      ],
      "IAP subjects": [
        "IAP_SUBJECT_DETAIL.ACTIVITY_TITLE"
      ],
      "enrollment": [
        "IAP_SUBJECT_DETAIL.MAX_ENROLLMENT"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_CATEGORY_KEY",
        "IAP_SUBJECT_CATEGORY.IAP_SUBJECT_CATEGORY_KEY"
      ],
      [
        "TIME_DAY.ACADEMIC_TERM_CODE",
        "IAP_SUBJECT_DETAIL.TERM_CODE"
      ]
    ],
    "sample_id": 10
  },
  {
    "question": "For each sponsor of the independent activity periods, list the sponsor name, number of sessions held, the total number of enrollment, the minimum and maximum fee, the number of sessions with info, and the number of sessions without info.",
    "db_id": "dw",
    "sql": "WITH SessionStats AS (SELECT isd.IAP_SUBJECT_SESSION_KEY, isd.IAP_SUBJECT_SPONSOR_KEY, MAX(isd.MAX_ENROLLMENT) as enrollment, MAX(isd.FEE) as fee FROM IAP_SUBJECT_DETAIL isd GROUP BY isd.IAP_SUBJECT_SESSION_KEY, isd.IAP_SUBJECT_SPONSOR_KEY), SessionInfo AS (SELECT DISTINCT IAP_SUBJECT_SESSION_KEY, HAS_SESSION_INFO FROM IAP_SUBJECT_SESSION) SELECT issr.SPONSOR_NAME, COUNT(DISTINCT ss.IAP_SUBJECT_SESSION_KEY) AS Total_Sessions, SUM(ss.enrollment) AS Total_Enrollment, MIN(ss.fee) AS Min_Fee, MAX(ss.fee) AS Max_Fee, COUNT(DISTINCT CASE WHEN si.HAS_SESSION_INFO = 'Y' THEN ss.IAP_SUBJECT_SESSION_KEY END) AS Num_Sessions_With_Info, COUNT(DISTINCT CASE WHEN si.HAS_SESSION_INFO = 'N' THEN ss.IAP_SUBJECT_SESSION_KEY END) AS Num_Sessions_Without_Info FROM SessionStats ss JOIN IAP_SUBJECT_SPONSOR issr ON ss.IAP_SUBJECT_SPONSOR_KEY = issr.IAP_SUBJECT_SPONSOR_KEY JOIN SessionInfo si ON ss.IAP_SUBJECT_SESSION_KEY = si.IAP_SUBJECT_SESSION_KEY GROUP BY issr.SPONSOR_NAME;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_SESSION",
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#IAP_SUBJECT_SPONSOR"
    ],
    "mapping": {
      "sponsor name": [
        "IAP_SUBJECT_SPONSOR.SPONSOR_NAME"
      ],
      "sessions": [
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY"
      ],
      "enrollment": [
        "IAP_SUBJECT_DETAIL.MAX_ENROLLMENT"
      ],
      "fee": [
        "IAP_SUBJECT_DETAIL.FEE"
      ],
      "info": [
        "IAP_SUBJECT_SESSION.HAS_SESSION_INFO"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY",
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY"
      ],
      [
        "IAP_SUBJECT_SPONSOR.IAP_SUBJECT_SPONSOR_KEY",
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SPONSOR_KEY"
      ]
    ],
    "sample_id": 11
  },
  {
    "question": "What are the individual's email and name, academic year, total number of IAP subjects, the minimum and maximum fees, and the total course enrollment for each individual and academic year?",
    "db_id": "dw",
    "sql": "WITH SessionEnrollment AS (SELECT IAP_SUBJECT_SESSION_KEY, MAX(MAX_ENROLLMENT) as enrollment, MAX(FEE) as fee, TERM_CODE FROM IAP_SUBJECT_DETAIL GROUP BY IAP_SUBJECT_SESSION_KEY, TERM_CODE), PersonSessions AS (SELECT DISTINCT isp.PERSON_EMAIL, isp.PERSON_NAME, isd.IAP_SUBJECT_SESSION_KEY, isd.ACTIVITY_TITLE, isd.TERM_CODE FROM IAP_SUBJECT_PERSON isp JOIN IAP_SUBJECT_DETAIL isd ON isp.IAP_SUBJECT_PERSON_KEY = isd.IAP_SUBJECT_PERSON_KEY) SELECT ps.PERSON_EMAIL, ps.PERSON_NAME, ty.ACADEMIC_YEAR, COUNT(DISTINCT ps.ACTIVITY_TITLE) AS Total_Subjects, MIN(se.fee) AS Min_Fee, MAX(se.fee) AS Max_Fee, SUM(se.enrollment) AS Total_Enrollment FROM PersonSessions ps JOIN SessionEnrollment se ON ps.IAP_SUBJECT_SESSION_KEY = se.IAP_SUBJECT_SESSION_KEY JOIN (SELECT DISTINCT ACADEMIC_TERM_CODE, ACADEMIC_YEAR FROM TIME_DAY) ty ON ps.TERM_CODE = ty.ACADEMIC_TERM_CODE GROUP BY ps.PERSON_EMAIL, ps.PERSON_NAME, ty.ACADEMIC_YEAR;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_PERSON",
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#TIME_DAY"
    ],
    "mapping": {
      "email": [
        "IAP_SUBJECT_PERSON.PERSON_EMAIL"
      ],
      "name": [
        "IAP_SUBJECT_PERSON.PERSON_NAME"
      ],
      "academic year": [
        "TIME_DAY.ACADEMIC_YEAR"
      ],
      "IAP subjects": [
        "IAP_SUBJECT_DETAIL.ACTIVITY_TITLE"
      ],
      "fees": [
        "IAP_SUBJECT_DETAIL.FEE"
      ],
      "course enrollment": [
        "IAP_SUBJECT_DETAIL.MAX_ENROLLMENT"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_PERSON_KEY",
        "IAP_SUBJECT_PERSON.IAP_SUBJECT_PERSON_KEY"
      ],
      [
        "TIME_DAY.ACADEMIC_TERM_CODE",
        "IAP_SUBJECT_DETAIL.TERM_CODE"
      ]
    ],
    "sample_id": 12
  },
  {
    "question": "What is the term code, term description, total number of IAP sessions, total fee collected, and minimum and maximum enrollment for each term code?",
    "db_id": "dw",
    "sql": "WITH DedupDetail AS (SELECT IAP_SUBJECT_SESSION_KEY, TERM_CODE, MAX(FEE) as FEE, MAX(MAX_ENROLLMENT) as MAX_ENROLLMENT FROM IAP_SUBJECT_DETAIL GROUP BY IAP_SUBJECT_SESSION_KEY, TERM_CODE) SELECT dd.TERM_CODE, ata.TERM_DESCRIPTION, COUNT(DISTINCT dd.IAP_SUBJECT_SESSION_KEY) AS Total_Sessions, SUM(dd.FEE) AS Total_Fee, MIN(dd.MAX_ENROLLMENT) AS Min_Enrollment, MAX(dd.MAX_ENROLLMENT) AS Max_Enrollment FROM DedupDetail dd JOIN ACADEMIC_TERMS_ALL ata ON dd.TERM_CODE = ata.TERM_CODE GROUP BY dd.TERM_CODE, ata.TERM_DESCRIPTION;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_SESSION",
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#ACADEMIC_TERMS_ALL"
    ],
    "mapping": {
      "term code": [
        "IAP_SUBJECT_DETAIL.TERM_CODE"
      ],
      "term description": [
        "ACADEMIC_TERMS_ALL.TERM_DESCRIPTION"
      ],
      "IAP sessions": [
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY"
      ],
      "fee": [
        "IAP_SUBJECT_DETAIL.FEE"
      ],
      "enrollment": [
        "IAP_SUBJECT_DETAIL.MAX_ENROLLMENT"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY",
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY"
      ],
      [
        "ACADEMIC_TERMS_ALL.TERM_CODE",
        "IAP_SUBJECT_DETAIL.TERM_CODE"
      ]
    ],
    "sample_id": 13
  },
  {
    "question": "What is the name of the building, total number of subjects, total fee, and shortest and longest sessions for each physical IAP session location?",
    "db_id": "dw",
    "sql": "SELECT b.BUILDING_NAME, COUNT(DISTINCT isd.ACTIVITY_TITLE) AS Total_Subjects, (SELECT SUM(fee_per_subj) FROM (SELECT MAX(isd2.FEE) as fee_per_subj FROM IAP_SUBJECT_SESSION iss2 JOIN IAP_SUBJECT_DETAIL isd2 ON iss2.IAP_SUBJECT_SESSION_KEY = isd2.IAP_SUBJECT_SESSION_KEY WHERE iss2.SESSION_LOCATION = b.BUILDING_NUMBER GROUP BY iss2.IAP_SUBJECT_SESSION_KEY, isd2.ACTIVITY_TITLE) sub) AS Total_Fee, MIN(TIMESTAMPDIFF(MINUTE, STR_TO_DATE(iss.SESSION_START_TIME, '%h%i%p'), STR_TO_DATE(iss.SESSION_END_TIME, '%h%i%p')) + CASE WHEN STR_TO_DATE(iss.SESSION_END_TIME, '%h%i%p') < STR_TO_DATE(iss.SESSION_START_TIME, '%h%i%p') THEN 1440 ELSE 0 END) AS Min_Sessions, MAX(TIMESTAMPDIFF(MINUTE, STR_TO_DATE(iss.SESSION_START_TIME, '%h%i%p'), STR_TO_DATE(iss.SESSION_END_TIME, '%h%i%p')) + CASE WHEN STR_TO_DATE(iss.SESSION_END_TIME, '%h%i%p') < STR_TO_DATE(iss.SESSION_START_TIME, '%h%i%p') THEN 1440 ELSE 0 END) AS Max_Sessions FROM IAP_SUBJECT_SESSION iss JOIN IAP_SUBJECT_DETAIL isd ON iss.IAP_SUBJECT_SESSION_KEY = isd.IAP_SUBJECT_SESSION_KEY JOIN BUILDINGS b ON b.BUILDING_NUMBER = iss.SESSION_LOCATION GROUP BY b.BUILDING_NAME, b.BUILDING_NUMBER;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_SESSION",
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#BUILDINGS"
    ],
    "mapping": {
      "name of the building": [
        "BUILDINGS.BUILDING_NAME"
      ],
      "subjects": [
        "IAP_SUBJECT_DETAIL.ACTIVITY_TITLE"
      ],
      "fee": [
        "IAP_SUBJECT_DETAIL.FEE"
      ],
      "sessions": [
        "IAP_SUBJECT_SESSION.SESSION_END_TIME",
        "IAP_SUBJECT_SESSION.SESSION_START_TIME"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY",
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY"
      ],
      [
        "IAP_SUBJECT_SESSION.SESSION_LOCATION",
        "BUILDINGS.BUILDING_NUMBER"
      ]
    ],
    "sample_id": 14
  },
  {
    "question": "What is total number of subjects, the total fee, and the shortest and longest sessions, for all virtual IAP sessions?",
    "db_id": "dw",
    "sql": "SELECT COUNT(DISTINCT isd.ACTIVITY_TITLE) AS Total_Subjects, (SELECT SUM(fee) FROM (SELECT DISTINCT isd2.ACTIVITY_TITLE, isd2.FEE as fee FROM IAP_SUBJECT_SESSION iss2 JOIN IAP_SUBJECT_DETAIL isd2 ON iss2.IAP_SUBJECT_SESSION_KEY = isd2.IAP_SUBJECT_SESSION_KEY WHERE iss2.SESSION_LOCATION NOT IN (SELECT BUILDING_NUMBER FROM BUILDINGS WHERE BUILDING_NUMBER IS NOT NULL)) sub) AS Total_Fee, MIN(TIMESTAMPDIFF(MINUTE, STR_TO_DATE(iss.SESSION_START_TIME, '%h%i%p'), STR_TO_DATE(iss.SESSION_END_TIME, '%h%i%p')) + CASE WHEN STR_TO_DATE(iss.SESSION_END_TIME, '%h%i%p') < STR_TO_DATE(iss.SESSION_START_TIME, '%h%i%p') THEN 1440 ELSE 0 END) AS Min_Sessions, MAX(TIMESTAMPDIFF(MINUTE, STR_TO_DATE(iss.SESSION_START_TIME, '%h%i%p'), STR_TO_DATE(iss.SESSION_END_TIME, '%h%i%p')) + CASE WHEN STR_TO_DATE(iss.SESSION_END_TIME, '%h%i%p') < STR_TO_DATE(iss.SESSION_START_TIME, '%h%i%p') THEN 1440 ELSE 0 END) AS Max_Sessions FROM IAP_SUBJECT_SESSION iss JOIN IAP_SUBJECT_DETAIL isd ON iss.IAP_SUBJECT_SESSION_KEY = isd.IAP_SUBJECT_SESSION_KEY WHERE iss.SESSION_LOCATION NOT IN (SELECT BUILDING_NUMBER FROM BUILDINGS WHERE BUILDING_NUMBER IS NOT NULL);",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_SESSION",
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#BUILDINGS"
    ],
    "mapping": {
      "subjects": [
        "IAP_SUBJECT_DETAIL.ACTIVITY_TITLE"
      ],
      "fee": [
        "IAP_SUBJECT_DETAIL.FEE"
      ],
      "sessions": [
        "IAP_SUBJECT_SESSION.SESSION_END_TIME",
        "IAP_SUBJECT_SESSION.SESSION_START_TIME"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY",
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY"
      ]
    ],
    "sample_id": 15
  },
  {
    "question": "What is the school code, school name, full name of the department, course level, total number of courses, and total number of degree-granting courses for each school code, department, and course level?",
    "db_id": "dw",
    "sql": "SELECT sd.SCHOOL_CODE, sd.SCHOOL_NAME, sd.DEPARTMENT_FULL_NAME, scd.COURSE_LEVEL, COUNT(DISTINCT scd.COURSE) AS Total_Courses, COUNT(DISTINCT CASE WHEN scd.IS_DEGREE_GRANTING = 'Y' THEN scd.COURSE END) AS Total_Degree_Granting_Courses FROM SIS_COURSE_DESCRIPTION scd JOIN SIS_DEPARTMENT sd ON scd.DEPARTMENT = sd.DEPARTMENT_CODE GROUP BY sd.SCHOOL_CODE, sd.SCHOOL_NAME, scd.DEPARTMENT, sd.DEPARTMENT_FULL_NAME, scd.COURSE_LEVEL;",
    "gold_tables": [
      "dw#sep#SIS_COURSE_DESCRIPTION",
      "dw#sep#SIS_DEPARTMENT"
    ],
    "mapping": {
      "school code": [
        "SIS_SUBJECT_CODE.SCHOOL_CODE"
      ],
      "school name": [
        "SIS_SUBJECT_CODE.SCHOOL_NAME"
      ],
      "full name of the department": [
        "SIS_DEPARTMENT.DEPARTMENT_FULL_NAME"
      ],
      "course level": [
        "SIS_COURSE_DESCRIPTION.COURSE_LEVEL"
      ],
      "courses": [
        "SIS_COURSE_DESCRIPTION.COURSE"
      ],
      "degree-granting courses": [
        "SIS_COURSE_DESCRIPTION.IS_DEGREE_GRANTING"
      ]
    },
    "join_keys": [
      [
        "SIS_COURSE_DESCRIPTION.DEPARTMENT",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ]
    ],
    "sample_id": 16
  },
  {
    "question": "What are the different schools and departments that offer SIS courses? List their school code, school name, department code, department name, the total number of phone numbers, and the most common course level.",
    "db_id": "dw",
    "sql": "SELECT sd.SCHOOL_CODE, sd.SCHOOL_NAME, sd.DEPARTMENT_CODE, sad.SIS_ADMIN_DEPARTMENT_NAME, COUNT(DISTINCT sad.DEPARTMENT_PHONE_NUMBER) AS Total_Phone_Numbers, CASE WHEN SUM(CASE WHEN scd.COURSE_LEVEL = 'U' THEN 1 ELSE 0 END) >= SUM(CASE WHEN scd.COURSE_LEVEL = 'G' THEN 1 ELSE 0 END) THEN 'U' ELSE 'G' END AS Most_Common_Course_Level FROM SIS_ADMIN_DEPARTMENT sad JOIN SIS_DEPARTMENT sd ON sad.SIS_ADMIN_DEPARTMENT_CODE = sd.DEPARTMENT_CODE JOIN SIS_COURSE_DESCRIPTION scd ON sd.DEPARTMENT_CODE = scd.DEPARTMENT GROUP BY sd.SCHOOL_CODE, sd.SCHOOL_NAME, sd.DEPARTMENT_CODE, sad.SIS_ADMIN_DEPARTMENT_NAME;",
    "gold_tables": [
      "dw#sep#SIS_ADMIN_DEPARTMENT",
      "dw#sep#SIS_DEPARTMENT",
      "dw#sep#SIS_COURSE_DESCRIPTION"
    ],
    "mapping": {
      "school code": [
        "SIS_DEPARTMENT.SCHOOL_CODE"
      ],
      "school name": [
        "SIS_DEPARTMENT.SCHOOL_NAME"
      ],
      "department code": [
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      "department name": [
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_NAME"
      ],
      "phone numbers": [
        "SIS_ADMIN_DEPARTMENT.DEPARTMENT_PHONE_NUMBER"
      ],
      "course level": [
        "SIS_COURSE_DESCRIPTION.COURSE_LEVEL"
      ]
    },
    "join_keys": [
      [
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_CODE",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      [
        "SIS_DEPARTMENT.DEPARTMENT_CODE",
        "SIS_COURSE_DESCRIPTION.DEPARTMENT"
      ]
    ],
    "sample_id": 17
  },
  {
    "question": "What is the school code, school name, DLC key, the graduate level, total number of SIS subjects, the minimum and maximum course numbers, and the total number of departments offering subjects for each school?",
    "db_id": "dw",
    "sql": "SELECT ssc.SCHOOL_CODE, ssc.SCHOOL_NAME, MAX(sd.DLC_KEY) AS DLC_KEY, scd.GRADUATE_LEVEL, COUNT(DISTINCT ssc.SUBJECT_CODE) AS Total_Subjects, MIN(ssc.COURSE_NUMBER) AS Min_Course_Number, MAX(ssc.COURSE_NUMBER) AS Max_Course_Number, COUNT(DISTINCT sd.DEPARTMENT_CODE) AS Total_Departments FROM SIS_SUBJECT_CODE ssc LEFT JOIN SIS_COURSE_DESCRIPTION scd ON ssc.SUBJECT_CODE = scd.COURSE LEFT JOIN SIS_DEPARTMENT sd ON scd.DEPARTMENT = sd.DEPARTMENT_CODE GROUP BY ssc.SCHOOL_CODE, ssc.SCHOOL_NAME, scd.GRADUATE_LEVEL;",
    "gold_tables": [
      "dw#sep#SIS_SUBJECT_CODE",
      "dw#sep#SIS_COURSE_DESCRIPTION",
      "dw#sep#SIS_DEPARTMENT"
    ],
    "mapping": {
      "school code": [
        "SIS_SUBJECT_CODE.SCHOOL_CODE"
      ],
      "school name": [
        "SIS_SUBJECT_CODE.SCHOOL_NAME"
      ],
      "DLC key": [
        "SIS_DEPARTMENT.DLC_KEY"
      ],
      "graduate level": [
        "SIS_COURSE_DESCRIPTION.GRADUATE_LEVEL"
      ],
      "SIS subjects": [
        "SIS_SUBJECT_CODE.SUBJECT_CODE"
      ],
      "course numbers": [
        "SIS_SUBJECT_CODE.COURSE_NUMBER"
      ],
      "departments": [
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ]
    },
    "join_keys": [
      [
        "SIS_SUBJECT_CODE.SUBJECT_CODE",
        "SIS_COURSE_DESCRIPTION.COURSE"
      ],
      [
        "SIS_COURSE_DESCRIPTION.DEPARTMENT",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ]
    ],
    "sample_id": 18
  },
  {
    "question": "What is the building component, name of the building, square footage for all rooms, total number of floors, total number of rooms, total number of facility organizations, total number of supervisors, and total number of supervisees for each building component?",
    "db_id": "dw",
    "sql": "WITH room_metrics AS (SELECT sd.BUILDING_COMPONENT, b.BUILDING_NAME, SUM(sd.ROOM_SQUARE_FOOTAGE) AS Total_Square_Footage, COUNT(DISTINCT sf.FLOOR) AS Total_Number_Of_Floors, COUNT(DISTINCT sd.BUILDING_ROOM) AS Total_Rooms, COUNT(DISTINCT su.FCLT_ORGANIZATION_KEY) AS Total_Number_FCLT FROM SPACE_DETAIL sd JOIN BUILDINGS b ON b.BUILDING_KEY = sd.BUILDING_KEY LEFT JOIN SPACE_FLOOR sf ON sd.FLOOR_KEY = sf.FLOOR_KEY LEFT JOIN SPACE_UNIT su ON sd.SPACE_UNIT_KEY = su.SPACE_UNIT_KEY GROUP BY sd.BUILDING_COMPONENT, b.BUILDING_NAME), dlc_by_component AS (SELECT DISTINCT sd.BUILDING_COMPONENT, b.BUILDING_NAME, su.DLC_KEY FROM SPACE_DETAIL sd JOIN BUILDINGS b ON b.BUILDING_KEY = sd.BUILDING_KEY JOIN SPACE_UNIT su ON sd.SPACE_UNIT_KEY = su.SPACE_UNIT_KEY), supervisor_metrics AS (SELECT dc.BUILDING_COMPONENT, dc.BUILDING_NAME, COUNT(DISTINCT ssu.MIT_ID) AS Total_Supervisors, SUM(ssu.NUM_OF_SUPERVISEES) AS Total_Supervisees FROM dlc_by_component dc JOIN SPACE_SUPERVISOR_USAGE ssu ON FIND_IN_SET(dc.DLC_KEY, ssu.DEPT_NAMES) > 0 GROUP BY dc.BUILDING_COMPONENT, dc.BUILDING_NAME) SELECT rm.BUILDING_COMPONENT, rm.BUILDING_NAME, rm.Total_Square_Footage, rm.Total_Number_Of_Floors, rm.Total_Rooms, rm.Total_Number_FCLT, COALESCE(sm.Total_Supervisors, 0) AS Total_Supervisors, COALESCE(sm.Total_Supervisees, 0) AS Total_Supervisees FROM room_metrics rm LEFT JOIN supervisor_metrics sm ON rm.BUILDING_COMPONENT = sm.BUILDING_COMPONENT AND rm.BUILDING_NAME = sm.BUILDING_NAME;",
    "gold_tables": [
      "dw#sep#SPACE_DETAIL",
      "dw#sep#BUILDINGS",
      "dw#sep#SPACE_FLOOR",
      "dw#sep#SPACE_UNIT",
      "dw#sep#SPACE_SUPERVISOR_USAGE"
    ],
    "mapping": {
      "building component": [
        "SPACE_DETAIL.BUILDING_COMPONENT"
      ],
      "name of the building": [
        "BUILDINGS.BUILDING_NAME"
      ],
      "square footage": [
        "SPACE_DETAIL.ROOM_SQUARE_FOOTAGE"
      ],
      "rooms": [
        "SPACE_DETAIL.BUILDING_ROOM"
      ],
      "floors": [
        "SPACE_FLOOR.FLOOR"
      ],
      "facility organizations": [
        "SPACE_UNIT.FCLT_ORGANIZATION_KEY"
      ],
      "supervisors": [
        "SPACE_SUPERVISOR_USAGE.MIT_ID"
      ],
      "supervisees": [
        "SPACE_SUPERVISOR_USAGE.NUM_OF_SUPERVISEES"
      ]
    },
    "join_keys": [
      [
        "SPACE_DETAIL.BUILDING_KEY",
        "BUILDINGS.BUILDING_KEY"
      ],
      [
        "SPACE_DETAIL.FLOOR_KEY",
        "SPACE_FLOOR.FLOOR_KEY"
      ],
      [
        "SPACE_DETAIL.SPACE_UNIT_KEY",
        "SPACE_UNIT.SPACE_UNIT_KEY"
      ],
      [
        "SPACE_SUPERVISOR_USAGE.DEPT_NAMES",
        "SPACE_UNIT.DLC_KEY"
      ]
    ],
    "sample_id": 19
  },
  {
    "question": "What is the DLC key, name of the DLC, total number of floors, total square footage, total number of facility organizations, total number of supervisors, total number of supervisees, and total building heights for each DLC?",
    "db_id": "dw",
    "sql": "WITH dlc_base AS ( SELECT DISTINCT su.DLC_KEY, fo.DLC_NAME FROM SPACE_UNIT su JOIN FCLT_ORGANIZATION fo ON fo.DLC_KEY = su.DLC_KEY ), floor_counts AS ( SELECT su.DLC_KEY, COUNT(DISTINCT sf.FLOOR) AS Total_Floors, COUNT(DISTINCT su.FCLT_ORGANIZATION_KEY) AS Total_Facility_Orgs, SUM(sd.ROOM_SQUARE_FOOTAGE) AS Total_Square_Footage FROM SPACE_DETAIL sd JOIN SPACE_FLOOR sf ON sd.FLOOR_KEY = sf.FLOOR_KEY JOIN SPACE_UNIT su ON sd.SPACE_UNIT_KEY = su.SPACE_UNIT_KEY GROUP BY su.DLC_KEY ), height_by_dlc AS ( SELECT DLC_KEY, SUM(height) as total_height FROM ( SELECT DISTINCT su.DLC_KEY, sd.BUILDING_KEY, fb.BUILDING_HEIGHT as height FROM SPACE_DETAIL sd JOIN FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = sd.BUILDING_KEY JOIN SPACE_UNIT su ON sd.SPACE_UNIT_KEY = su.SPACE_UNIT_KEY ) t GROUP BY DLC_KEY ), supervisees_by_dlc AS ( SELECT DEPT_NAMES as DLC_KEY, SUM(NUM_OF_SUPERVISEES) as total_supervisees, COUNT(DISTINCT MIT_ID) as total_supervisors FROM SPACE_SUPERVISOR_USAGE GROUP BY DEPT_NAMES ) SELECT d.DLC_KEY, d.DLC_NAME, COALESCE(f.Total_Floors, 0) AS Total_Number_Of_Floors, COALESCE(f.Total_Square_Footage, 0) AS Total_Square_Footage, COALESCE(f.Total_Facility_Orgs, 0) AS Total_Number_Facility, COALESCE(s.total_supervisors, 0) AS Total_Supervisors, COALESCE(s.total_supervisees, 0) AS Total_Supervisees, COALESCE(h.total_height, 0) AS Cumulative_Building_Height FROM dlc_base d LEFT JOIN floor_counts f ON f.DLC_KEY = d.DLC_KEY LEFT JOIN height_by_dlc h ON h.DLC_KEY = d.DLC_KEY LEFT JOIN supervisees_by_dlc s ON s.DLC_KEY = d.DLC_KEY;",
    "gold_tables": [
      "dw#sep#SPACE_DETAIL",
      "dw#sep#FCLT_BUILDING",
      "dw#sep#SPACE_FLOOR",
      "dw#sep#SPACE_UNIT",
      "dw#sep#SPACE_SUPERVISOR_USAGE",
      "dw#sep#FCLT_ORGANIZATION"
    ],
    "mapping": {
      "DLC key": [
        "SPACE_UNIT.DLC_KEY"
      ],
      "name of the DLC": [
        "FCLT_ORGANIZATION.DLC_NAME"
      ],
      "floors": [
        "SPACE_FLOOR.FLOOR"
      ],
      "square footage": [
        "SPACE_DETAIL.ROOM_SQUARE_FOOTAGE"
      ],
      "facility organizations": [
        "SPACE_UNIT.FCLT_ORGANIZATION_KEY"
      ],
      "supervisors": [
        "SPACE_SUPERVISOR_USAGE.MIT_ID"
      ],
      "supervisees": [
        "SPACE_SUPERVISOR_USAGE.NUM_OF_SUPERVISEES"
      ],
      "building heights": [
        "FCLT_BUILDING.BUILDING_HEIGHT"
      ]
    },
    "join_keys": [
      [
        "SPACE_UNIT.DLC_KEY",
        "SPACE_SUPERVISOR_USAGE.DEPT_NAMES"
      ],
      [
        "SPACE_DETAIL.BUILDING_KEY",
        "FCLT_BUILDING.FCLT_BUILDING_KEY"
      ],
      [
        "SPACE_DETAIL.FLOOR_KEY",
        "SPACE_FLOOR.FLOOR_KEY"
      ],
      [
        "SPACE_DETAIL.SPACE_UNIT_KEY",
        "SPACE_UNIT.SPACE_UNIT_KEY"
      ],
      [
        "SPACE_UNIT.DLC_KEY",
        "FCLT_ORGANIZATION.DLC_KEY"
      ]
    ],
    "sample_id": 20
  },
  {
    "question": "What is the department name, total number of types of TIP subjects, total number of enrolled students, the minimum and maximum rental new price for each department?",
    "db_id": "dw",
    "sql": "SELECT tso.OFFER_DEPT_NAME, \n       COUNT(DISTINCT tso.SUBJECT_ID) AS Total_Subjects, \n       SUM(tso.NUM_ENROLLED_STUDENTS) AS Total_Enrolled_Students, \n       MIN(tm.RENTAL_NEW_PRICE) AS Min_Rental_New_Price, \n       MAX(tm.RENTAL_NEW_PRICE) AS Max_Rental_New_Price \nFROM TIP_SUBJECT_OFFERED tso \nLEFT JOIN TIP_DETAIL td ON tso.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY \nLEFT JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY \nGROUP BY tso.OFFER_DEPT_NAME;",
    "gold_tables": [
      "dw#sep#TIP_SUBJECT_OFFERED",
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_MATERIAL"
    ],
    "mapping": {
      "department name": [
        "TIP_SUBJECT_OFFERED.OFFER_DEPT_NAME"
      ],
      "TIP subjects": [
        "TIP_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "enrolled students": [
        "TIP_SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS"
      ],
      "rental new price": [
        "TIP_MATERIAL.RENTAL_NEW_PRICE"
      ]
    },
    "join_keys": [
      [
        "TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY",
        "TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY"
      ],
      [
        "TIP_MATERIAL.TIP_MATERIAL_KEY",
        "TIP_DETAIL.TIP_MATERIAL_KEY"
      ]
    ],
    "sample_id": 21
  },
  {
    "question": "What are the details of courses offered in the current academic term, including the academic year, term code, hgn code, the total number of types of courses, the average number of units, the department name, the name and email address of the person in charge?",
    "db_id": "dw",
    "sql": "SELECT CC.ACADEMIC_YEAR, CC.TERM_CODE, CC.HGN_CODE, COUNT(DISTINCT CC.SUBJECT_ID) AS TOTAL_COURSES, AVG(CC.TOTAL_UNITS) AS AVERAGE_UNITS, CC.DEPARTMENT_NAME, ED.FULL_NAME AS RESPONSIBLE_FACULTY_NAME, ED.EMAIL_ADDRESS AS RESPONSIBLE_FACULTY_EMAIL FROM COURSE_CATALOG_SUBJECT_OFFERED CC JOIN ACADEMIC_TERMS AT ON CC.TERM_CODE = AT.TERM_CODE LEFT JOIN EMPLOYEE_DIRECTORY ED ON CC.RESPONSIBLE_FACULTY_MIT_ID = ED.MIT_ID WHERE AT.IS_CURRENT_TERM = 'Y' GROUP BY CC.ACADEMIC_YEAR, CC.TERM_CODE, CC.HGN_CODE, CC.DEPARTMENT_NAME, ED.FULL_NAME, ED.EMAIL_ADDRESS;",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#ACADEMIC_TERMS",
      "dw#sep#EMPLOYEE_DIRECTORY"
    ],
    "mapping": {
      "current academic term": [
        "ACADEMIC_TERMS.IS_CURRENT_TERM"
      ],
      "academic year": [
        "COURSE_CATALOG_SUBJECT_OFFERED.ACADEMIC_YEAR"
      ],
      "term code": [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE"
      ],
      "hgn code": [
        "SUBJECT_OFFERED.HGN_CODE"
      ],
      "courses": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "number of units": [
        "COURSE_CATALOG_SUBJECT_OFFERED.TOTAL_UNITS"
      ],
      "department name": [
        "COURSE_CATALOG_SUBJECT_OFFERED.DEPARTMENT_NAME"
      ],
      "name": [
        "EMPLOYEE_DIRECTORY.FULL_NAME"
      ],
      "email address": [
        "EMPLOYEE_DIRECTORY.EMAIL_ADDRESS"
      ]
    },
    "join_keys": [
      [
        "SUBJECT_OFFERED.SUBJECT_ID",
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE",
        "ACADEMIC_TERMS.TERM_CODE"
      ],
      [
        "EMPLOYEE_DIRECTORY.MIT_ID",
        "SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID"
      ]
    ],
    "sample_id": 22
  },
  {
    "question": "Retrieve information about the IAP subjects, including their titles, categories, session titles, session start time, session end time, sponsor names, and total number of sessions.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT isd.ACTIVITY_TITLE, isc.IAP_CATEGORY_NAME, iss.SESSION_TITLE, iss.SESSION_START_TIME, iss.SESSION_END_TIME, isp.SPONSOR_NAME, sess_count.Total_Sessions FROM IAP_SUBJECT_DETAIL isd JOIN IAP_SUBJECT_CATEGORY isc ON isd.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY JOIN IAP_SUBJECT_SESSION iss ON isd.IAP_SUBJECT_SESSION_KEY = iss.IAP_SUBJECT_SESSION_KEY JOIN IAP_SUBJECT_SPONSOR isp ON isd.IAP_SUBJECT_SPONSOR_KEY = isp.IAP_SUBJECT_SPONSOR_KEY JOIN (SELECT ACTIVITY_TITLE, COUNT(DISTINCT IAP_SUBJECT_SESSION_KEY) AS Total_Sessions FROM IAP_SUBJECT_DETAIL GROUP BY ACTIVITY_TITLE) sess_count ON isd.ACTIVITY_TITLE = sess_count.ACTIVITY_TITLE;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#IAP_SUBJECT_CATEGORY",
      "dw#sep#IAP_SUBJECT_SESSION",
      "dw#sep#IAP_SUBJECT_SPONSOR"
    ],
    "mapping": {
      "titles": [
        "IAP_SUBJECT_DETAIL.ACTIVITY_TITLE"
      ],
      "categories": [
        "IAP_SUBJECT_CATEGORY.IAP_CATEGORY_NAME"
      ],
      "session titles": [
        "IAP_SUBJECT_SESSION.SESSION_TITLE"
      ],
      "session start time": [
        "IAP_SUBJECT_SESSION.SESSION_START_TIME"
      ],
      "session end time": [
        "IAP_SUBJECT_SESSION.SESSION_END_TIME"
      ],
      "sponsor names": [
        "IAP_SUBJECT_SPONSOR.SPONSOR_NAME"
      ],
      "sessions": [
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_CATEGORY.IAP_SUBJECT_CATEGORY_KEY",
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_CATEGORY_KEY"
      ],
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY",
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY"
      ],
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SPONSOR_KEY",
        "IAP_SUBJECT_SPONSOR.IAP_SUBJECT_SPONSOR_KEY"
      ]
    ],
    "sample_id": 23
  },
  {
    "question": "Show the department names, the corresponding SIS subject code, subject code descriptions, graduate level, and the total number of courses per department.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT sd.DEPARTMENT_NAME, sc.SUBJECT_CODE, sc.SUBJECT_CODE_DESC, scd.GRADUATE_LEVEL, Total_Courses.Total_Courses FROM SIS_DEPARTMENT sd JOIN SIS_COURSE_DESCRIPTION scd ON sd.DEPARTMENT_CODE = scd.DEPARTMENT JOIN SIS_SUBJECT_CODE sc ON scd.COURSE = sc.COURSE_NUMBER JOIN (SELECT sd.DEPARTMENT_NAME, COUNT(DISTINCT COURSE_NUMBER) AS Total_Courses FROM SIS_DEPARTMENT sd JOIN SIS_COURSE_DESCRIPTION scd ON sd.DEPARTMENT_CODE = scd.DEPARTMENT JOIN SIS_SUBJECT_CODE sc ON scd.COURSE = sc.COURSE_NUMBER GROUP BY DEPARTMENT_NAME) AS Total_Courses ON sd.DEPARTMENT_NAME = Total_Courses.DEPARTMENT_NAME;",
    "gold_tables": [
      "dw#sep#SIS_DEPARTMENT",
      "dw#sep#SIS_COURSE_DESCRIPTION",
      "dw#sep#SIS_SUBJECT_CODE"
    ],
    "mapping": {
      "department names": [
        "SIS_DEPARTMENT.DEPARTMENT_NAME"
      ],
      "SIS subject code": [
        "SIS_SUBJECT_CODE.SUBJECT_CODE"
      ],
      "subject code descriptions": [
        "SIS_SUBJECT_CODE.SUBJECT_CODE_DESC"
      ],
      "graduate level": [
        "SIS_COURSE_DESCRIPTION.GRADUATE_LEVEL"
      ],
      "courses": [
        "SIS_SUBJECT_CODE.COURSE_NUMBER"
      ]
    },
    "join_keys": [
      [
        "SIS_COURSE_DESCRIPTION.DEPARTMENT",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      [
        "SIS_SUBJECT_CODE.COURSE_NUMBER",
        "SIS_COURSE_DESCRIPTION.COURSE"
      ]
    ],
    "sample_id": 24
  },
  {
    "question": "For each term, list the term code, the term description, whether the term is current or not, and the total number of types of CIS courses.",
    "db_id": "dw",
    "sql": "SELECT at.TERM_CODE, at.TERM_DESCRIPTION, at.IS_CURRENT_TERM, COUNT(DISTINCT ccc.SUBJECT_ID) AS Total_SUBJECTS FROM (SELECT ACADEMIC_TERMS_ALL.*, CASE WHEN TERM_CODE LIKE '%FA' THEN 'Y' END AS A, CASE WHEN TERM_CODE LIKE '%JA' THEN 'Y' END AS B, CASE WHEN TERM_CODE LIKE '%SP' THEN 'Y' END AS C, CASE WHEN TERM_CODE LIKE '%SU' THEN 'Y' END AS D FROM ACADEMIC_TERMS_ALL) at LEFT OUTER JOIN CIS_COURSE_CATALOG ccc ON ccc.ACADEMIC_YEAR = at.ACADEMIC_YEAR AND (ccc.IS_OFFERED_FALL_TERM = at.A OR ccc.IS_OFFERED_IAP = at.B OR ccc.IS_OFFERED_SPRING_TERM = at.C OR ccc.IS_OFFERED_SUMMER_TERM = at.D) GROUP BY at.TERM_CODE, at.TERM_DESCRIPTION, at.IS_CURRENT_TERM",
    "gold_tables": [
      "dw#sep#ACADEMIC_TERMS_ALL",
      "dw#sep#ACADEMIC_TERM_PARAMETER",
      "dw#sep#CIS_COURSE_CATALOG"
    ],
    "mapping": {
      "term code": [
        "ACADEMIC_TERMS_ALL.TERM_CODE"
      ],
      "term description": [
        "ACADEMIC_TERMS_ALL.TERM_DESCRIPTION"
      ],
      "term is current or not": [
        "ACADEMIC_TERM_PARAMETER.IS_CURRENT_TERM"
      ],
      "CIS courses": [
        "CIS_COURSE_CATALOG.SUBJECT_ID"
      ]
    },
    "join_keys": [],
    "sample_id": 25
  },
  {
    "question": "What is the author, school name, material status, total record counts, and total number of types of courses for each author and school?",
    "db_id": "dw",
    "sql": "SELECT tm.AUTHOR, sd.SCHOOL_NAME, tms.TIP_MATERIAL_STATUS, SUM(td.RECORD_COUNT) AS Total_Record_Count, COUNT(DISTINCT td.SUBJECT_ID) AS Total_Subject FROM TIP_DETAIL td JOIN (SELECT DISTINCT TIP_MATERIAL_KEY, CASE WHEN INSTR(AUTHOR, ';') > 0 THEN SUBSTR(AUTHOR, 1, INSTR(AUTHOR, ';') - 1) ELSE AUTHOR END AS AUTHOR FROM TIP_MATERIAL) tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY JOIN STUDENT_DEPARTMENT sd ON tso.OFFER_DEPT_CODE = sd.DEPARTMENT_CODE GROUP BY tm.AUTHOR, tms.TIP_MATERIAL_STATUS, sd.SCHOOL_NAME;",
    "gold_tables": [
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_MATERIAL",
      "dw#sep#TIP_MATERIAL_STATUS",
      "dw#sep#TIP_SUBJECT_OFFERED",
      "dw#sep#STUDENT_DEPARTMENT"
    ],
    "mapping": {
      "author": [
        "TIP_MATERIAL.AUTHOR"
      ],
      "school name": [
        "STUDENT_DEPARTMENT.SCHOOL_NAME"
      ],
      "material status": [
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS"
      ],
      "record counts": [
        "TIP_DETAIL.RECORD_COUNT"
      ],
      "courses": [
        "TIP_DETAIL.SUBJECT_ID"
      ]
    },
    "join_keys": [
      [
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS_KEY",
        "TIP_DETAIL.TIP_MATERIAL_STATUS_KEY"
      ],
      [
        "TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY",
        "TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY"
      ],
      [
        "STUDENT_DEPARTMENT.DEPARTMENT_CODE",
        "TIP_SUBJECT_OFFERED.OFFER_DEPT_CODE"
      ]
    ],
    "sample_id": 26
  },
  {
    "question": "What is the course number, subject title, material status, the total, min, and max new shelf price, the total, min, and max used shelf price, total number of schools and the total number of materials for each TIP subject and material status?",
    "db_id": "dw",
    "sql": "WITH DedupMaterial AS (\n  SELECT TIP_MATERIAL_KEY, MAX(TITLE) AS TITLE, \n         MAX(NEW_SHELF_PRICE) AS NEW_SHELF_PRICE, \n         MAX(USED_SHELF_PRICE) AS USED_SHELF_PRICE\n  FROM TIP_MATERIAL\n  GROUP BY TIP_MATERIAL_KEY\n),\ndistinct_materials AS (\n  SELECT DISTINCT tso.COURSE_NUMBER, tso.SUBJECT_TITLE, tms.TIP_MATERIAL_STATUS, \n         tm.TIP_MATERIAL_KEY, tm.NEW_SHELF_PRICE, tm.USED_SHELF_PRICE, tso.OFFER_SCHOOL_NAME \n  FROM TIP_DETAIL td \n  JOIN DedupMaterial tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY \n  JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY \n  JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY\n)\nSELECT COURSE_NUMBER, SUBJECT_TITLE, TIP_MATERIAL_STATUS,\n       SUM(NEW_SHELF_PRICE) AS total_new_price,\n       MIN(NEW_SHELF_PRICE) AS min_new_price,\n       MAX(NEW_SHELF_PRICE) AS max_new_price,\n       SUM(USED_SHELF_PRICE) AS total_used_price,\n       MIN(USED_SHELF_PRICE) AS min_used_price,\n       MAX(USED_SHELF_PRICE) AS max_used_price,\n       COUNT(DISTINCT OFFER_SCHOOL_NAME) AS num_schools,\n       COUNT(DISTINCT TIP_MATERIAL_KEY) AS num_materials\nFROM distinct_materials\nGROUP BY COURSE_NUMBER, SUBJECT_TITLE, TIP_MATERIAL_STATUS;",
    "gold_tables": [
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_MATERIAL",
      "dw#sep#TIP_MATERIAL_STATUS",
      "dw#sep#TIP_SUBJECT_OFFERED"
    ],
    "mapping": {
      "course number": [
        "TIP_SUBJECT_OFFERED.COURSE_NUMBER"
      ],
      "subject title": [
        "TIP_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "material status": [
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS"
      ],
      "new shelf price": [
        "TIP_MATERIAL.NEW_SHELF_PRICE"
      ],
      "used shelf price": [
        "TIP_MATERIAL.USED_SHELF_PRICE"
      ],
      "schools": [
        "TIP_SUBJECT_OFFERED.OFFER_SCHOOL_NAME"
      ],
      "materials": [
        "TIP_DETAIL.TIP_MATERIAL_KEY"
      ],
      "TIP subject": [
        "TIP_SUBJECT_OFFERED.SUBJECT_TITLE"
      ]
    },
    "join_keys": [
      [
        "TIP_DETAIL.TIP_MATERIAL_KEY",
        "TIP_MATERIAL.TIP_MATERIAL_KEY"
      ],
      [
        "TIP_DETAIL.TIP_MATERIAL_STATUS_KEY",
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS_KEY"
      ],
      [
        "TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY",
        "TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY"
      ]
    ],
    "sample_id": 27
  },
  {
    "question": "What is material status, the total number of materials, the total number of subjects, the total number of schools, and the most recent publication year for each material status?",
    "db_id": "dw",
    "sql": "SELECT tms.TIP_MATERIAL_STATUS, COUNT(DISTINCT td.TIP_MATERIAL_KEY) AS Total_Materials, COUNT(DISTINCT td.SUBJECT_ID) AS Total_Subjects, COUNT(DISTINCT tso.OFFER_SCHOOL_NAME) AS Total_Num_Schools, MAX(tm.YEAR) AS Most_Recent_Year FROM TIP_DETAIL td JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY GROUP BY tms.TIP_MATERIAL_STATUS;",
    "gold_tables": [
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_MATERIAL",
      "dw#sep#TIP_MATERIAL_STATUS",
      "dw#sep#TIP_SUBJECT_OFFERED",
      "dw#sep#STUDENT_DEPARTMENT"
    ],
    "mapping": {
      "material status": [
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS"
      ],
      "materials": [
        "TIP_DETAIL.TIP_MATERIAL_KEY"
      ],
      "subjects": [
        "TIP_DETAIL.SUBJECT_ID"
      ],
      "schools": [
        "STUDENT_DEPARTMENT.SCHOOL_NAME"
      ],
      "publication year": [
        "TIP_MATERIAL.YEAR"
      ]
    },
    "join_keys": [
      [
        "TIP_MATERIAL.TIP_MATERIAL_KEY",
        "TIP_DETAIL.TIP_MATERIAL_KEY"
      ],
      [
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS_KEY",
        "TIP_DETAIL.TIP_MATERIAL_STATUS_KEY"
      ],
      [
        "TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY",
        "TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY"
      ],
      [
        "STUDENT_DEPARTMENT.DEPARTMENT_CODE",
        "TIP_SUBJECT_OFFERED.OFFER_DEPT_CODE"
      ]
    ],
    "sample_id": 28
  },
  {
    "question": "What is the term description, whether the term is current or not, total number of types of TIP subjects offered and materials needed, the minimum and maximum number of enrolled students, the total number of schools offering subjects, and the total number of records for each term code?",
    "db_id": "dw",
    "sql": "SELECT at.TERM_DESCRIPTION, at.IS_CURRENT_TERM, COUNT(DISTINCT tso.COURSE_NUMBER) AS Total_Courses, (SELECT COUNT(DISTINCT tm2.ISBN) FROM TIP_SUBJECT_OFFERED tso2 LEFT JOIN TIP_DETAIL td2 ON td2.TIP_SUBJECT_OFFERED_KEY = tso2.TIP_SUBJECT_OFFERED_KEY LEFT JOIN TIP_MATERIAL tm2 ON td2.TIP_MATERIAL_KEY = tm2.TIP_MATERIAL_KEY WHERE tso2.TERM_CODE = at.TERM_CODE) AS Total_Materials, MIN(tso.NUM_ENROLLED_STUDENTS) AS Min_Enrolled_Students, MAX(tso.NUM_ENROLLED_STUDENTS) AS Max_Enrolled_Students, COUNT(DISTINCT tso.OFFER_SCHOOL_NAME) AS Total_Num_Schools, COALESCE((SELECT SUM(td2.RECORD_COUNT) FROM TIP_SUBJECT_OFFERED tso2 LEFT JOIN TIP_DETAIL td2 ON td2.TIP_SUBJECT_OFFERED_KEY = tso2.TIP_SUBJECT_OFFERED_KEY WHERE tso2.TERM_CODE = at.TERM_CODE), 0) AS Total_Records FROM ACADEMIC_TERMS_ALL at LEFT JOIN TIP_SUBJECT_OFFERED tso ON at.TERM_CODE = tso.TERM_CODE GROUP BY at.TERM_CODE, at.TERM_DESCRIPTION, at.IS_CURRENT_TERM;",
    "gold_tables": [
      "dw#sep#ACADEMIC_TERMS_ALL",
      "dw#sep#TIP_SUBJECT_OFFERED",
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_MATERIAL"
    ],
    "mapping": {
      "term description": [
        "ACADEMIC_TERMS_ALL.TERM_DESCRIPTION"
      ],
      "term is current or not": [
        "ACADEMIC_TERMS_ALL.IS_CURRENT_TERM"
      ],
      "TIP subjects": [
        "TIP_SUBJECT_OFFERED.COURSE_NUMBER"
      ],
      "materials": [
        "TIP_MATERIAL.ISBN"
      ],
      "enrolled students": [
        "TIP_SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS"
      ],
      "schools": [
        "TIP_SUBJECT_OFFERED.OFFER_SCHOOL_NAME"
      ],
      "number of records": [
        "TIP_DETAIL.RECORD_COUNT"
      ],
      "term code": [
        "ACADEMIC_TERMS_ALL.TERM_CODE"
      ]
    },
    "join_keys": [
      [
        "ACADEMIC_TERMS_ALL.TERM_CODE",
        "TIP_SUBJECT_OFFERED.TERM_CODE"
      ],
      [
        "TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY",
        "TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY"
      ],
      [
        "TIP_DETAIL.TIP_MATERIAL_KEY",
        "TIP_MATERIAL.TIP_MATERIAL_KEY"
      ],
      [
        "TIP_DETAIL.TIP_MATERIAL_STATUS_KEY",
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS_KEY"
      ]
    ],
    "sample_id": 29
  },
  {
    "question": "List all buildings with their names, building numbers, building height, street address, city, state, HR department name, assignable square footage, total and average square footage, ordered in descending order of assignable, total, and average square footage.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT new.BUILDING_NAME, new.BUILDING_NUMBER, fb.BUILDING_HEIGHT, new.BUILDING_STREET_ADDRESS, fba.CITY, fba.STATE, new.HR_DEPARTMENT_NAME, new.Assignable_Square_Footage, new.Total_Square_Footage, new.Avg_Square_Footage_Per_Room FROM (SELECT b.BUILDING_NAME, b.BUILDING_NUMBER, b.BUILDING_STREET_ADDRESS, fb.FAC_BUILDING_KEY, fo.HR_DEPARTMENT_NAME, ROUND(SUM(CASE WHEN fr.MAJOR_USE_DESC IN ('OFFICES','LABS','RESIDENT','SUPPORT','GENERAL','SPECIAL','CLASSRMS','STUDY','HEALTH','UNCLASS') THEN fr.AREA ELSE 0 END)) AS Assignable_Square_Footage, SUM(fr.AREA) AS Total_Square_Footage, AVG(fr.AREA) AS Avg_Square_Footage_Per_Room FROM BUILDINGS b JOIN FAC_BUILDING fb ON b.BUILDING_KEY = fb.FAC_BUILDING_KEY JOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY JOIN FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY GROUP BY b.BUILDING_NAME, b.BUILDING_NUMBER, b.BUILDING_STREET_ADDRESS, fb.FAC_BUILDING_KEY, fo.HR_DEPARTMENT_NAME) new JOIN FAC_BUILDING_ADDRESS fba ON new.FAC_BUILDING_KEY = fba.BUILDING_KEY JOIN FAC_BUILDING fb ON new.FAC_BUILDING_KEY = fb.FAC_BUILDING_KEY WHERE fba.ADDRESS_PURPOSE = 'STREET' ORDER BY new.Assignable_Square_Footage DESC, new.Total_Square_Footage DESC, new.Avg_Square_Footage_Per_Room DESC;",
    "gold_tables": [
      "dw#sep#BUILDINGS",
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_ORGANIZATION",
      "dw#sep#FAC_BUILDING_ADDRESS"
    ],
    "mapping": {
      "names": [
        "BUILDINGS.BUILDING_NAME"
      ],
      "building numbers": [
        "BUILDINGS.BUILDING_NUMBER"
      ],
      "building height": [
        "FAC_BUILDING.BUILDING_HEIGHT"
      ],
      "street address": [
        "BUILDINGS.BUILDING_STREET_ADDRESS"
      ],
      "city": [
        "FAC_BUILDING_ADDRESS.CITY"
      ],
      "state": [
        "FAC_BUILDING_ADDRESS.STATE"
      ],
      "HR department name": [
        "FAC_ORGANIZATION.HR_DEPARTMENT_NAME"
      ],
      "assignable square footage": [
        "FAC_ROOMS.AREA",
        "FAC_ROOMS.MAJOR_USE_DESC"
      ],
      "square footage": [
        "FAC_ROOMS.AREA"
      ]
    },
    "join_keys": [
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "BUILDINGS.BUILDING_KEY"
      ],
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_ROOMS.BUILDING_KEY"
      ],
      [
        "FAC_ROOMS.ORGANIZATION_KEY",
        "FAC_ORGANIZATION.ORGANIZATION_KEY"
      ]
    ],
    "sample_id": 30
  },
  {
    "question": "For the 2023 Fall term, what are the unique term descriptions, subject titles along with their prerequisites, total number of types of subjects per term code, instructor of this course, and the number of types of courses ever taught by the instructor?",
    "db_id": "dw",
    "sql": "WITH InstructorExperience AS (\n  SELECT FALL_INSTRUCTORS, COUNT(DISTINCT SUBJECT_ID) AS Experience \n  FROM COURSE_CATALOG_SUBJECT_OFFERED \n  GROUP BY FALL_INSTRUCTORS\n),\nSubjectCounts AS (\n  SELECT TERM_CODE, COUNT(DISTINCT SUBJECT_ID) AS Total_Subjects\n  FROM COURSE_CATALOG_SUBJECT_OFFERED \n  WHERE TERM_CODE = '2023FA'\n  GROUP BY TERM_CODE\n)\nSELECT DISTINCT at.TERM_DESCRIPTION, ccso.SUBJECT_TITLE, ccso.PREREQUISITES, \n       sc.Total_Subjects, ccso.FALL_INSTRUCTORS, COALESCE(ie.Experience, 0) AS Experience\nFROM COURSE_CATALOG_SUBJECT_OFFERED ccso \nJOIN ACADEMIC_TERMS at ON ccso.TERM_CODE = at.TERM_CODE \nJOIN SubjectCounts sc ON ccso.TERM_CODE = sc.TERM_CODE\nLEFT JOIN InstructorExperience ie ON ccso.FALL_INSTRUCTORS = ie.FALL_INSTRUCTORS\nWHERE ccso.TERM_CODE = '2023FA';",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#ACADEMIC_TERMS"
    ],
    "mapping": {
      "2023 Fall term": [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE"
      ],
      "term descriptions": [
        "ACADEMIC_TERMS.TERM_DESCRIPTION"
      ],
      "subject titles": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "prerequisites": [
        "COURSE_CATALOG_SUBJECT_OFFERED.PREREQUISITES"
      ],
      "subjects": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "term code": [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE"
      ],
      "instructor": [
        "COURSE_CATALOG_SUBJECT_OFFERED.FALL_INSTRUCTORS"
      ],
      "courses": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ]
    },
    "join_keys": [
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE",
        "ACADEMIC_TERMS.TERM_CODE"
      ]
    ],
    "sample_id": 31
  },
  {
    "question": "Show the details of rooms including the full name of the rooms, the building names, floor numbers, the organizations occupying them, name of the departments occupying them, and the percentage of the room area over the assignable floor area and building.",
    "db_id": "dw",
    "sql": "SELECT fr.ROOM_FULL_NAME, fb.BUILDING_NAME, ff.FLOOR, fo.ORGANIZATION_NAME, fo.HR_DEPARTMENT_NAME, CASE WHEN ff.ASSIGNABLE_AREA = 0 THEN 0 ELSE fr.AREA/ff.ASSIGNABLE_AREA END AS PERC_OF_ASG_FLOOR, CASE WHEN fb.ASSIGNABLE_AREA = 0 THEN 0 ELSE fr.AREA/fb.ASSIGNABLE_AREA END AS PERC_OF_ASG_BUILDING FROM FAC_ROOMS fr JOIN FAC_BUILDING fb ON fr.BUILDING_KEY = fb.FAC_BUILDING_KEY JOIN FAC_FLOOR ff ON fr.FLOOR_KEY = ff.FLOOR_KEY LEFT JOIN FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY;",
    "gold_tables": [
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_FLOOR",
      "dw#sep#FAC_ORGANIZATION"
    ],
    "mapping": {
      "full name of the rooms": [
        "FAC_ROOMS.ROOM_FULL_NAME"
      ],
      "building names": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "floor numbers": [
        "FAC_FLOOR.FLOOR"
      ],
      "organizations": [
        "FAC_ORGANIZATION.ORGANIZATION_NAME"
      ],
      "name of the departments": [
        "FAC_ORGANIZATION.HR_DEPARTMENT_NAME"
      ],
      "room area": [
        "FAC_ROOMS.AREA"
      ],
      "assignable floor area": [
        "FAC_FLOOR.ASSIGNABLE_AREA"
      ]
    },
    "join_keys": [
      [
        "FAC_ROOMS.BUILDING_KEY",
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ],
      [
        "FAC_ROOMS.FLOOR_KEY",
        "FAC_FLOOR.FLOOR_KEY"
      ],
      [
        "FAC_ROOMS.ORGANIZATION_KEY",
        "FAC_ORGANIZATION.ORGANIZATION_KEY"
      ]
    ],
    "sample_id": 32
  },
  {
    "question": "Show the details of rooms including the full name of the rooms, the building names, floor numbers, the organizations occupying them, name of the departments occupying them, and the percentage of the room area over the floor area and building.",
    "db_id": "dw",
    "sql": "SELECT fr.ROOM_FULL_NAME, fb.BUILDING_NAME, ff.FLOOR, fo.ORGANIZATION_NAME, fo.HR_DEPARTMENT_NAME, fr.AREA/NULLIF(FLOOR_AREA, 0) AS PERC_OF_FLOOR, fr.AREA/NULLIF(BUILDING_AREA, 0) AS PERC_OF_BUILDING FROM (SELECT ROOM_FULL_NAME, BUILDING_KEY, FLOOR_KEY, ORGANIZATION_KEY, AREA, SUM(AREA) OVER (PARTITION BY FLOOR_KEY) AS FLOOR_AREA, SUM(AREA) OVER (PARTITION BY BUILDING_KEY) AS BUILDING_AREA FROM FAC_ROOMS) fr JOIN FAC_BUILDING fb ON fr.BUILDING_KEY = fb.FAC_BUILDING_KEY JOIN FAC_FLOOR ff ON fr.FLOOR_KEY = ff.FLOOR_KEY JOIN FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY;",
    "gold_tables": [
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_FLOOR",
      "dw#sep#FAC_ORGANIZATION"
    ],
    "mapping": {
      "full name": [
        "FAC_ROOMS.ROOM_FULL_NAME"
      ],
      "building names": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "floor numbers": [
        "FAC_FLOOR.FLOOR"
      ],
      "organizations": [
        "FAC_ORGANIZATION.ORGANIZATION_NAME"
      ],
      "departments": [
        "FAC_ORGANIZATION.HR_DEPARTMENT_NAME"
      ],
      "room area": [
        "FAC_ROOMS.AREA"
      ],
      "floor area": [
        "FAC_ROOMS.AREA",
        "FAC_ROOMS.FLOOR_KEY"
      ]
    },
    "join_keys": [],
    "sample_id": 33
  },
  {
    "question": "What are the academic year, and instructors names for courses offered in the academic year 2022, along with the total number of types of courses per instructor?",
    "db_id": "dw",
    "sql": "SELECT ata.ACADEMIC_YEAR, ed.FULL_NAME, COUNT(distinct so.COURSE_NUMBER) AS Total_Courses FROM SUBJECT_OFFERED so JOIN ACADEMIC_TERMS_ALL ata ON so.TERM_CODE = ata.TERM_CODE JOIN EMPLOYEE_DIRECTORY ed ON so.RESPONSIBLE_FACULTY_MIT_ID = ed.MIT_ID WHERE ata.ACADEMIC_YEAR = 2022 GROUP BY ata.ACADEMIC_YEAR, ed.FULL_NAME;",
    "gold_tables": [
      "dw#sep#SUBJECT_OFFERED",
      "dw#sep#ACADEMIC_TERMS_ALL",
      "dw#sep#EMPLOYEE_DIRECTORY"
    ],
    "mapping": {
      "academic year": [
        "ACADEMIC_TERMS_ALL.ACADEMIC_YEAR"
      ],
      "instructors names": [
        "EMPLOYEE_DIRECTORY.FULL_NAME"
      ],
      "courses": [
        "SUBJECT_OFFERED.COURSE_NUMBER"
      ]
    },
    "join_keys": [
      [
        "SUBJECT_OFFERED.TERM_CODE",
        "ACADEMIC_TERMS_ALL.TERM_CODE"
      ],
      [
        "SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID",
        "EMPLOYEE_DIRECTORY.MIT_ID"
      ]
    ],
    "sample_id": 34
  },
  {
    "question": "What are the building names, department names, organizations, their highest and lowest floor number, along with the total number of rooms per each building key?",
    "db_id": "dw",
    "sql": "SELECT fb.FAC_BUILDING_KEY, fb.BUILDING_NAME, fo.HR_DEPARTMENT_NAME, fo.ORGANIZATION, MAX(CAST(ff.LEVEL_ID AS SIGNED)) as MAX_FLOOR, MIN(CAST(ff.LEVEL_ID AS SIGNED)) as MIN_FLOOR, COUNT(DISTINCT fr.FAC_ROOM_KEY) AS Total_Rooms FROM FAC_BUILDING fb JOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY JOIN FAC_FLOOR ff ON fr.FLOOR_KEY = ff.FLOOR_KEY JOIN FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY GROUP BY fb.FAC_BUILDING_KEY, fb.BUILDING_NAME, fo.HR_DEPARTMENT_NAME, fo.ORGANIZATION;",
    "gold_tables": [
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_FLOOR",
      "dw#sep#FAC_ORGANIZATION"
    ],
    "mapping": {
      "building names": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "department names": [
        "FAC_ORGANIZATION.HR_DEPARTMENT_NAME"
      ],
      "organizations": [
        "FAC_ORGANIZATION.ORGANIZATION"
      ],
      "floor number": [
        "FAC_FLOOR.LEVEL_ID"
      ],
      "room": [
        "FAC_ROOMS.FAC_ROOM_KEY"
      ],
      "building key": [
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ]
    },
    "join_keys": [
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_ROOMS.BUILDING_KEY"
      ],
      [
        "FAC_FLOOR.FLOOR_KEY",
        "FAC_ROOMS.FLOOR_KEY"
      ],
      [
        "FAC_ORGANIZATION.ORGANIZATION_KEY",
        "FAC_ROOMS.ORGANIZATION_KEY"
      ]
    ],
    "sample_id": 35
  },
  {
    "question": "Provide the complete information for students with the first name Kevin, including their full names, email addresses, department names, department phone numbers, school names, and the total student count per department and school. If a student is associated with more than one department, list a separate row for each department.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT msd.FULL_NAME, msd.EMAIL_ADDRESS, sd.DEPARTMENT_NAME, sad.DEPARTMENT_PHONE_NUMBER, sd.SCHOOL_NAME, (SELECT COUNT(DISTINCT msd2.EMAIL_ADDRESS) FROM MIT_STUDENT_DIRECTORY msd2 JOIN SIS_DEPARTMENT sd2 ON msd2.DEPARTMENT = sd2.DEPARTMENT_CODE WHERE sd2.DEPARTMENT_CODE = sd.DEPARTMENT_CODE) AS Total_Students_DEPT, (SELECT COUNT(DISTINCT msd3.EMAIL_ADDRESS) FROM MIT_STUDENT_DIRECTORY msd3 JOIN SIS_DEPARTMENT sd3 ON msd3.DEPARTMENT = sd3.DEPARTMENT_CODE WHERE sd3.SCHOOL_CODE = sd.SCHOOL_CODE) AS Total_Students_SCHOOL FROM MIT_STUDENT_DIRECTORY msd JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE LEFT JOIN SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE WHERE msd.FIRST_NAME = 'Kevin';",
    "gold_tables": [
      "dw#sep#MIT_STUDENT_DIRECTORY",
      "dw#sep#SIS_DEPARTMENT",
      "dw#sep#SIS_ADMIN_DEPARTMENT"
    ],
    "mapping": {
      "first name": [
        "MIT_STUDENT_DIRECTORY.FIRST_NAME"
      ],
      "full names": [
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ],
      "email addresses": [
        "MIT_STUDENT_DIRECTORY.EMAIL_ADDRESS"
      ],
      "department names": [
        "SIS_DEPARTMENT.DEPARTMENT_NAME"
      ],
      "department phone numbers": [
        "SIS_ADMIN_DEPARTMENT.DEPARTMENT_PHONE_NUMBER"
      ],
      "school names": [
        "SIS_DEPARTMENT.SCHOOL_NAME"
      ],
      "student": [
        "MIT_STUDENT_DIRECTORY.EMAIL_ADDRESS"
      ],
      "department": [
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      "school": [
        "SIS_DEPARTMENT.SCHOOL_CODE"
      ]
    },
    "join_keys": [
      [
        "MIT_STUDENT_DIRECTORY.DEPARTMENT",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      [
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_CODE",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ]
    ],
    "sample_id": 36
  },
  {
    "question": "What are the unique titles of subjects offered in the fall term along with their instructor names, instructor emails, and the total number of types of subjects per instructor?",
    "db_id": "dw",
    "sql": "SELECT ccso.SUBJECT_TITLE, e.FULL_NAME AS INSTRUCTOR, e.EMAIL_ADDRESS, Total_Subjects.Total_Subjects FROM EMPLOYEE_DIRECTORY e JOIN COURSE_CATALOG_SUBJECT_OFFERED ccso ON ccso.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID JOIN ACADEMIC_TERMS_ALL at ON ccso.TERM_CODE = at.TERM_CODE JOIN (SELECT ccso.RESPONSIBLE_FACULTY_MIT_ID, COUNT(DISTINCT ccso.SUBJECT_ID) AS Total_Subjects FROM COURSE_CATALOG_SUBJECT_OFFERED ccso JOIN ACADEMIC_TERMS_ALL at ON ccso.TERM_CODE = at.TERM_CODE WHERE at.TERM_CODE LIKE '%FA' GROUP BY ccso.RESPONSIBLE_FACULTY_MIT_ID) AS Total_Subjects ON e.MIT_ID = Total_Subjects.RESPONSIBLE_FACULTY_MIT_ID WHERE at.TERM_CODE LIKE '%FA' GROUP BY ccso.SUBJECT_TITLE, e.FULL_NAME, e.EMAIL_ADDRESS, Total_Subjects.Total_Subjects;",
    "gold_tables": [
      "dw#sep#EMPLOYEE_DIRECTORY",
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#ACADEMIC_TERMS_ALL"
    ],
    "mapping": {
      "titles": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "subjects": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "fall term": [
        "ACADEMIC_TERMS_ALL.TERM_CODE"
      ],
      "instructor names": [
        "EMPLOYEE_DIRECTORY.FULL_NAME"
      ],
      "instructor emails": [
        "EMPLOYEE_DIRECTORY.EMAIL_ADDRESS"
      ]
    },
    "join_keys": [
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID",
        "EMPLOYEE_DIRECTORY.MIT_ID"
      ],
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE",
        "ACADEMIC_TERMS_ALL.TERM_CODE"
      ]
    ],
    "sample_id": 37
  },
  {
    "question": "List the building names, names of HR departments occupying them, the total gross square footage, the total and average assignable square footage, and the built year per building key.",
    "db_id": "dw",
    "sql": "WITH LatestHist AS (SELECT FCLT_BUILDING_KEY, EXT_GROSS_AREA FROM (SELECT FCLT_BUILDING_KEY, EXT_GROSS_AREA, ROW_NUMBER() OVER (PARTITION BY FCLT_BUILDING_KEY ORDER BY CAST(FISCAL_PERIOD AS UNSIGNED) DESC) AS rn FROM FCLT_BUILDING_HIST) t WHERE rn = 1) SELECT b.BUILDING_NAME, fo.HR_DEPARTMENT_NAME, MAX(lh.EXT_GROSS_AREA) AS Total_Gross_Sq_Ft, ROUND(SUM(CASE WHEN fr.MAJOR_USE_DESC IN ('OFFICES','LABS','RESIDENT','SUPPORT','GENERAL','SPECIAL','CLASSRMS','STUDY','HEALTH','UNCLASS') THEN fr.AREA ELSE 0 END)) AS Total_Assignable_Sq_Ft, ROUND(AVG(CASE WHEN fr.MAJOR_USE_DESC IN ('OFFICES','LABS','RESIDENT','SUPPORT','GENERAL','SPECIAL','CLASSRMS','STUDY','HEALTH','UNCLASS') THEN fr.AREA ELSE NULL END), 2) AS Avg_Assignable_Sq_Ft, YEAR(STR_TO_DATE(MAX(fb.DATE_BUILT), '%m/%d/%Y')) AS Year_Built FROM BUILDINGS b JOIN FAC_BUILDING fb ON b.BUILDING_KEY = fb.FAC_BUILDING_KEY JOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY JOIN FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY LEFT JOIN LatestHist lh ON fb.FAC_BUILDING_KEY = lh.FCLT_BUILDING_KEY GROUP BY b.BUILDING_KEY, b.BUILDING_NAME, fo.HR_DEPARTMENT_NAME;",
    "gold_tables": [
      "dw#sep#BUILDINGS",
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_ORGANIZATION",
      "dw#sep#FCLT_BUILDING_HIST"
    ],
    "mapping": {
      "building names": [
        "BUILDINGS.BUILDING_NAME"
      ],
      "names of HR departments": [
        "FAC_ORGANIZATION.HR_DEPARTMENT_NAME"
      ],
      "gross square footage": [
        "FCLT_BUILDING_HIST.EXT_GROSS_AREA"
      ],
      "assignable square footage": [
        "FAC_ROOMS.AREA",
        "FAC_ROOMS.MAJOR_USE_DESC"
      ],
      "built year": [
        "FAC_BUILDING.DATE_BUILT"
      ],
      "building key": [
        "BUILDINGS.BUILDING_KEY"
      ]
    },
    "join_keys": [
      [
        "BUILDINGS.BUILDING_KEY",
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ],
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_ROOMS.BUILDING_KEY"
      ],
      [
        "FAC_ROOMS.ORGANIZATION_KEY",
        "FAC_ORGANIZATION.ORGANIZATION_KEY"
      ],
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FCLT_BUILDING_HIST.FCLT_BUILDING_KEY"
      ]
    ],
    "sample_id": 38
  },
  {
    "question": "Retrieve the titles of subjects offered in the summer term along with their descriptions, responsible faculty names, email address, building name, room name, floor level, building street address, and the total number of types of courses per departmnet.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT ccso.SUBJECT_TITLE, ccso.SUBJECT_DESCRIPTION, ccso.RESPONSIBLE_FACULTY_NAME, ed.EMAIL_ADDRESS, b.BUILDING_NAME, fr.ROOM_FULL_NAME, ff.LEVEL_ID, b.BUILDING_STREET_ADDRESS, (SELECT COUNT(DISTINCT ccso2.SUBJECT_ID) FROM COURSE_CATALOG_SUBJECT_OFFERED ccso2 WHERE ccso2.DEPARTMENT_CODE = ccso.DEPARTMENT_CODE) AS Total_Courses FROM COURSE_CATALOG_SUBJECT_OFFERED ccso JOIN ACADEMIC_TERMS at ON ccso.TERM_CODE = at.TERM_CODE LEFT JOIN EMPLOYEE_DIRECTORY ed ON ccso.RESPONSIBLE_FACULTY_MIT_ID = ed.MIT_ID LEFT JOIN FAC_ROOMS fr ON ccso.MEET_PLACE = fr.FAC_ROOM_KEY LEFT JOIN FAC_FLOOR ff ON ff.FLOOR_KEY = fr.FLOOR_KEY LEFT JOIN BUILDINGS b ON fr.BUILDING_KEY = b.BUILDING_KEY WHERE at.TERM_CODE LIKE \"%SU\";",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#EMPLOYEE_DIRECTORY",
      "dw#sep#ACADEMIC_TERMS",
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_FLOOR",
      "dw#sep#BUILDINGS",
      "dw#sep#FAC_BUILDING_ADDRESS"
    ],
    "mapping": {
      "titles of subjects": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "summer term": [
        "ACADEMIC_TERMS.TERM_CODE"
      ],
      "descriptions": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_DESCRIPTION"
      ],
      "responsible faculty names": [
        "COURSE_CATALOG_SUBJECT_OFFERED.RESPONSIBLE_FACULTY_NAME"
      ],
      "email address": [
        "EMPLOYEE_DIRECTORY.EMAIL_ADDRESS"
      ],
      "building name": [
        "BUILDINGS.BUILDING_NAME"
      ],
      "room name": [
        "FAC_ROOMS.ROOM_FULL_NAME"
      ],
      "floor level": [
        "FAC_FLOOR.LEVEL_ID"
      ],
      "building street address": [
        "BUILDINGS.BUILDING_STREET_ADDRESS",
        "FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE"
      ],
      "courses": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "department": [
        "COURSE_CATALOG_SUBJECT_OFFERED.DEPARTMENT_CODE"
      ]
    },
    "join_keys": [
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID",
        "EMPLOYEE_DIRECTORY.MIT_ID"
      ],
      [
        "ACADEMIC_TERMS.TERM_CODE",
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE"
      ],
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.MEET_PLACE",
        "FAC_ROOMS.FAC_ROOM_KEY"
      ],
      [
        "FAC_ROOMS.FLOOR_KEY",
        "FAC_FLOOR.FLOOR_KEY"
      ],
      [
        "FAC_ROOMS.BUILDING_KEY",
        "BUILDINGS.BUILDING_KEY"
      ],
      [
        "FAC_ROOMS.BUILDING_KEY",
        "FAC_BUILDING_ADDRESS.BUILDING_KEY"
      ]
    ],
    "sample_id": 39
  },
  {
    "question": "For each term code, list the term description, attribute desciption, department name, school name, and the number of subjects in the area of humanities, arts and social sciences.",
    "db_id": "dw",
    "sql": "SELECT ata.TERM_CODE, ata.TERM_DESCRIPTION, ccso.HASS_ATTRIBUTE_DESC, sd.DEPARTMENT_NAME, sd.SCHOOL_NAME, COUNT(DISTINCT ccso.SUBJECT_ID) AS Total_Subjects FROM COURSE_CATALOG_SUBJECT_OFFERED ccso JOIN CIS_HASS_ATTRIBUTE cha ON ccso.HASS_ATTRIBUTE = cha.HASS_ATTRIBUTE JOIN SIS_DEPARTMENT sd ON ccso.DEPARTMENT_CODE = sd.DEPARTMENT_CODE JOIN ACADEMIC_TERMS_ALL ata ON ccso.TERM_CODE = ata.TERM_CODE WHERE cha.CIS_ATTRIBUTE_GROUP = 'H' GROUP BY ata.TERM_CODE, ata.TERM_DESCRIPTION, ccso.HASS_ATTRIBUTE_DESC, sd.DEPARTMENT_NAME, sd.SCHOOL_NAME;",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#CIS_HASS_ATTRIBUTE",
      "dw#sep#SIS_DEPARTMENT",
      "dw#sep#ACADEMIC_TERMS_ALL"
    ],
    "mapping": {
      "term code": [
        "ACADEMIC_TERMS_ALL.TERM_CODE"
      ],
      "term description": [
        "ACADEMIC_TERMS_ALL.TERM_DESCRIPTION"
      ],
      "attribute desciption": [
        "COURSE_CATALOG_SUBJECT_OFFERED.HASS_ATTRIBUTE_DESC"
      ],
      "department name": [
        "SIS_DEPARTMENT.DEPARTMENT_NAME"
      ],
      "school name": [
        "SIS_DEPARTMENT.SCHOOL_NAME"
      ],
      "subjects": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "area of humanities, arts and social studies": [
        "CIS_HASS_ATTRIBUTE.CIS_ATTRIBUTE_GROUP"
      ]
    },
    "join_keys": [
      [
        "CIS_HASS_ATTRIBUTE.HASS_ATTRIBUTE",
        "COURSE_CATALOG_SUBJECT_OFFERED.HASS_ATTRIBUTE"
      ],
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.DEPARTMENT_CODE",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      [
        "ACADEMIC_TERMS_ALL.TERM_CODE",
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE"
      ]
    ],
    "sample_id": 40
  },
  {
    "question": "List building names, their height, street address, city, state, postal code, their gross and assignable square footage, the smallest and largest floor level and the total area of all rooms for each building key.",
    "db_id": "dw",
    "sql": "SELECT fb.BUILDING_NAME, fb.BUILDING_HEIGHT, b.BUILDING_STREET_ADDRESS, fba.CITY, fba.STATE, fba.POSTAL_CODE, fb.EXT_GROSS_AREA, fb.ASSIGNABLE_AREA, MIN(CAST(ff.LEVEL_ID AS SIGNED)) as SMALLEST_FLOOR, MAX(CAST(ff.LEVEL_ID AS SIGNED)) AS HIGHEST_FLOOR, SUM(fr.AREA) AS Total_Room_Area FROM FAC_BUILDING fb JOIN FAC_BUILDING_ADDRESS fba ON fb.FAC_BUILDING_KEY = fba.BUILDING_KEY JOIN FAC_FLOOR ff ON fb.FAC_BUILDING_KEY = ff.BUILDING_KEY JOIN FAC_ROOMS fr ON ff.FLOOR_KEY = fr.FLOOR_KEY JOIN BUILDINGS b ON b.BUILDING_KEY = fb.FAC_BUILDING_KEY WHERE fba.ADDRESS_PURPOSE = 'STREET' GROUP BY fb.FAC_BUILDING_KEY, fb.BUILDING_NAME, fb.BUILDING_HEIGHT, fba.CITY, fba.POSTAL_CODE, fba.STATE, b.BUILDING_STREET_ADDRESS, fb.EXT_GROSS_AREA, fb.ASSIGNABLE_AREA;",
    "gold_tables": [
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_BUILDING_ADDRESS",
      "dw#sep#FAC_FLOOR",
      "dw#sep#FAC_ROOMS",
      "dw#sep#BUILDINGS"
    ],
    "mapping": {
      "building names": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "height": [
        "FAC_BUILDING.BUILDING_HEIGHT"
      ],
      "street address": [
        "BUILDINGS.BUILDING_STREET_ADDRESS",
        "FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE"
      ],
      "city": [
        "FAC_BUILDING_ADDRESS.CITY"
      ],
      "state": [
        "FAC_BUILDING_ADDRESS.STATE"
      ],
      "postal code": [
        "FAC_BUILDING_ADDRESS.POSTAL_CODE"
      ],
      "gross square footage": [
        "FAC_BUILDING.EXT_GROSS_AREA"
      ],
      "assignable square footage": [
        "FAC_BUILDING.ASSIGNABLE_AREA"
      ],
      "floor level": [
        "FAC_FLOOR.LEVEL_ID"
      ],
      "area": [
        "FAC_ROOMS.AREA"
      ],
      "building key": [
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ]
    },
    "join_keys": [
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_BUILDING_ADDRESS.BUILDING_KEY"
      ],
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_FLOOR.BUILDING_KEY"
      ],
      [
        "FAC_FLOOR.FLOOR_KEY",
        "FAC_ROOMS.FLOOR_KEY"
      ],
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "BUILDINGS.BUILDING_KEY"
      ]
    ],
    "sample_id": 41
  },
  {
    "question": "What is the category title, version, department name, school name, total number of courses for each course level, and the total number of degree-granting courses for each CIP category code?",
    "db_id": "dw",
    "sql": "SELECT c.CATEGORY_TITLE, c.VERSION, sd.DEPARTMENT_NAME, sd.SCHOOL_NAME, \n       SUM(CASE WHEN scd.COURSE_LEVEL = 'U' THEN 1 ELSE 0 END) AS Total_U_Courses, \n       SUM(CASE WHEN scd.COURSE_LEVEL = 'G' THEN 1 ELSE 0 END) AS Total_G_Courses, \n       SUM(CASE WHEN scd.IS_DEGREE_GRANTING = 'Y' THEN 1 ELSE 0 END) AS Total_Degree_Granting_Courses \nFROM SIS_COURSE_DESCRIPTION scd \nJOIN SIS_DEPARTMENT sd ON scd.DEPARTMENT = sd.DEPARTMENT_CODE \nLEFT JOIN CIP c ON c.PROGRAM_CODE = scd.CIP_PROGRAM_CODE \nGROUP BY c.CATEGORY_CODE, c.CATEGORY_TITLE, c.VERSION, sd.DEPARTMENT_NAME, sd.SCHOOL_NAME;",
    "gold_tables": [
      "dw#sep#CIP",
      "dw#sep#SIS_COURSE_DESCRIPTION",
      "dw#sep#SIS_DEPARTMENT"
    ],
    "mapping": {
      "category title": [
        "CIP.CATEGORY_TITLE"
      ],
      "version": [
        "CIP.VERSION"
      ],
      "department name": [
        "SIS_DEPARTMENT.DEPARTMENT_NAME"
      ],
      "school name": [
        "SIS_DEPARTMENT.SCHOOL_NAME"
      ],
      "course level": [
        "SIS_COURSE_DESCRIPTION.COURSE_LEVEL"
      ],
      "degree-granting courses": [
        "SIS_COURSE_DESCRIPTION.IS_DEGREE_GRANTING"
      ],
      "CIP category code": [
        "CIP.CATEGORY_CODE"
      ]
    },
    "join_keys": [
      [
        "SIS_COURSE_DESCRIPTION.CIP_PROGRAM_CODE",
        "CIP.PROGRAM_CODE"
      ],
      [
        "SIS_COURSE_DESCRIPTION.DEPARTMENT",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ]
    ],
    "sample_id": 42
  },
  {
    "question": "What is the total number of library materials, the minimum and maximum publication years, and the total number of materials status for each course name?",
    "db_id": "dw",
    "sql": "SELECT lci.COURSE_NAME, COUNT(DISTINCT lrc.CATALOG_SYSTEM_NUMBER) AS Total_Materials, MIN(lrc.CATALOG_YEAR) AS Min_Publication_Year, MAX(lrc.CATALOG_YEAR) AS Max_Publication_Year, COUNT(DISTINCT lms.LIBRARY_MATERIAL_STATUS) AS Total_Statuses FROM LIBRARY_COURSE_INSTRUCTOR lci JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY JOIN LIBRARY_MATERIAL_STATUS lms ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY GROUP BY lci.COURSE_NAME;",
    "gold_tables": [
      "dw#sep#LIBRARY_COURSE_INSTRUCTOR",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#LIBRARY_MATERIAL_STATUS"
    ],
    "mapping": {
      "library materials": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_SYSTEM_NUMBER"
      ],
      "publication years": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_YEAR"
      ],
      "materials status": [
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS"
      ],
      "course name": [
        "LIBRARY_COURSE_INSTRUCTOR.COURSE_NAME"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY",
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_MATERIAL_STATUS_KEY",
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS_KEY"
      ]
    ],
    "sample_id": 43
  },
  {
    "question": "What is the total number of library reserve materials, the minimum and maximum publication years, and the total number of enrolled students for each course instructor?",
    "db_id": "dw",
    "sql": "WITH SubjectEnrollment AS (SELECT lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY, lso.LIBRARY_SUBJECT_OFFERED_KEY, MAX(lso.NUM_ENROLLED_STUDENTS) as enrollment FROM LIBRARY_RESERVE_MATRL_DETAIL lrmd JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY GROUP BY lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY, lso.LIBRARY_SUBJECT_OFFERED_KEY) SELECT lci.INSTRUCTOR_NAME, COUNT(DISTINCT lrc.CATALOG_SYSTEM_NUMBER) AS Total_Materials, MIN(lrc.CATALOG_YEAR) AS Min_Publication_Year, MAX(lrc.CATALOG_YEAR) AS Max_Publication_Year, (SELECT SUM(se.enrollment) FROM SubjectEnrollment se WHERE se.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY) AS Total_Enrolled_Students FROM LIBRARY_COURSE_INSTRUCTOR lci JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY GROUP BY lci.INSTRUCTOR_NAME, lci.LIBRARY_COURSE_INSTRUCTOR_KEY;",
    "gold_tables": [
      "dw#sep#LIBRARY_COURSE_INSTRUCTOR",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#LIBRARY_SUBJECT_OFFERED"
    ],
    "mapping": {
      "library reserve materials": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_SYSTEM_NUMBER"
      ],
      "publication years": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_YEAR"
      ],
      "enrolled students": [
        "LIBRARY_SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS"
      ],
      "course instructor": [
        "LIBRARY_COURSE_INSTRUCTOR.INSTRUCTOR_NAME"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY",
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ],
      [
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY"
      ]
    ],
    "sample_id": 44
  },
  {
    "question": "What is the material status, term description, total number of courses and materials, occurences in departments and school, and the total number of instructors for each library material status code and term code?",
    "db_id": "dw",
    "sql": "SELECT lms.LIBRARY_MATERIAL_STATUS, ata.TERM_DESCRIPTION, COUNT(DISTINCT lso.COURSE_NUMBER) AS Total_Courses, COUNT(DISTINCT lrc.CATALOG_SYSTEM_NUMBER) AS Total_Materials, COUNT(DISTINCT lso.OFFER_DEPT_CODE), COUNT(DISTINCT lso.OFFER_SCHOOL_NAME), COUNT(DISTINCT lci.INSTRUCTOR_NAME) AS Total_Instructors FROM LIBRARY_MATERIAL_STATUS lms JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lms.LIBRARY_MATERIAL_STATUS_KEY = lrmd.LIBRARY_MATERIAL_STATUS_KEY JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY JOIN LIBRARY_COURSE_INSTRUCTOR lci ON lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY JOIN ACADEMIC_TERMS_ALL ata ON ata.TERM_CODE = lso.TERM_CODE GROUP BY lms.LIBRARY_MATERIAL_STATUS_CODE, lms.LIBRARY_MATERIAL_STATUS, lso.TERM_CODE, ata.TERM_DESCRIPTION;",
    "gold_tables": [
      "dw#sep#LIBRARY_MATERIAL_STATUS",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_SUBJECT_OFFERED",
      "dw#sep#LIBRARY_COURSE_INSTRUCTOR",
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#ACADEMIC_TERMS_ALL"
    ],
    "mapping": {
      "material status": [
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS"
      ],
      "term description": [
        "ACADEMIC_TERMS_ALL.TERM_DESCRIPTION"
      ],
      "courses": [
        "LIBRARY_SUBJECT_OFFERED.COURSE_NUMBER"
      ],
      "materials": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_SYSTEM_NUMBER"
      ],
      "departments": [
        "LIBRARY_SUBJECT_OFFERED.OFFER_DEPT_CODE"
      ],
      "school": [
        "LIBRARY_SUBJECT_OFFERED.OFFER_SCHOOL_NAME"
      ],
      "instructors": [
        "LIBRARY_COURSE_INSTRUCTOR.INSTRUCTOR_NAME"
      ],
      "library material status code": [
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS_CODE"
      ],
      "term code": [
        "LIBRARY_SUBJECT_OFFERED.TERM_CODE"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_MATERIAL_STATUS_KEY"
      ],
      [
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ],
      [
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "ACADEMIC_TERMS_ALL.TERM_CODE",
        "LIBRARY_SUBJECT_OFFERED.TERM_CODE"
      ]
    ],
    "sample_id": 45
  },
  {
    "question": "For building 36, list all space units, their floor and building name, building street address, their space usage, and the number of organizations and space units on the same building and floor.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT su.SPACE_UNIT, sf.FLOOR, b.BUILDING_NAME, b.BUILDING_STREET_ADDRESS, su2.SPACE_USAGE, (SELECT COUNT(DISTINCT fo2.FCLT_ORGANIZATION_KEY) FROM SPACE_UNIT su2 JOIN SPACE_DETAIL sd2 ON su2.SPACE_UNIT_KEY = sd2.SPACE_UNIT_KEY JOIN FCLT_ORGANIZATION fo2 ON fo2.FCLT_ORGANIZATION_KEY = su2.FCLT_ORGANIZATION_KEY WHERE sd2.FLOOR_KEY = sd.FLOOR_KEY AND sd2.BUILDING_KEY = sd.BUILDING_KEY) AS Total_Organizations, (SELECT COUNT(DISTINCT su3.SPACE_UNIT) FROM SPACE_UNIT su3 JOIN SPACE_DETAIL sd3 ON su3.SPACE_UNIT_KEY = sd3.SPACE_UNIT_KEY WHERE sd3.FLOOR_KEY = sd.FLOOR_KEY AND sd3.BUILDING_KEY = sd.BUILDING_KEY) AS Total_Space_Units FROM SPACE_UNIT su JOIN SPACE_DETAIL sd ON su.SPACE_UNIT_KEY = sd.SPACE_UNIT_KEY JOIN SPACE_USAGE su2 ON su2.SPACE_USAGE_KEY = sd.SPACE_USAGE_KEY JOIN SPACE_FLOOR sf ON sd.FLOOR_KEY = sf.FLOOR_KEY JOIN BUILDINGS b ON b.BUILDING_KEY = sd.BUILDING_KEY JOIN FCLT_ORGANIZATION fo ON fo.FCLT_ORGANIZATION_KEY = su.FCLT_ORGANIZATION_KEY JOIN FCLT_BUILDING_ADDRESS fba ON fba.FCLT_BUILDING_KEY = b.BUILDING_KEY WHERE fba.ADDRESS_PURPOSE = 'STREET' AND b.BUILDING_NUMBER = 36;",
    "gold_tables": [
      "dw#sep#SPACE_UNIT",
      "dw#sep#SPACE_DETAIL",
      "dw#sep#FCLT_ORGANIZATION",
      "dw#sep#SPACE_USAGE",
      "dw#sep#SPACE_FLOOR",
      "dw#sep#BUILDINGS",
      "dw#sep#FCLT_BUILDING_ADDRESS"
    ],
    "mapping": {
      "building 36": [
        "BUILDINGS.BUILDING_NUMBER"
      ],
      "space units": [
        "SPACE_UNIT.SPACE_UNIT"
      ],
      "floor": [
        "SPACE_FLOOR.FLOOR"
      ],
      "building name": [
        "BUILDINGS.BUILDING_NAME"
      ],
      "building street address": [
        "BUILDINGS.BUILDING_STREET_ADDRESS",
        "FCLT_BUILDING_ADDRESS.ADDRESS_PURPOSE"
      ],
      "space usage": [
        "SPACE_USAGE.SPACE_USAGE"
      ],
      "organizations": [
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY"
      ]
    },
    "join_keys": [
      [
        "SPACE_DETAIL.SPACE_UNIT_KEY",
        "SPACE_UNIT.SPACE_UNIT_KEY"
      ],
      [
        "SPACE_USAGE.SPACE_USAGE_KEY",
        "SPACE_DETAIL.SPACE_USAGE_KEY"
      ],
      [
        "SPACE_DETAIL.FLOOR_KEY",
        "SPACE_FLOOR.FLOOR_KEY"
      ],
      [
        "SPACE_DETAIL.BUILDING_KEY",
        "BUILDINGS.BUILDING_KEY"
      ],
      [
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY",
        "SPACE_UNIT.FCLT_ORGANIZATION_KEY"
      ],
      [
        "BUILDINGS.BUILDING_KEY",
        "FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY"
      ]
    ],
    "sample_id": 46
  },
  {
    "question": "For each distinct mailing list containing more than 1000 people and with a name starting with A (case insensitive), provide its name, whether it is a mailing list, whether it is a moira group, whether it is a NFS group, the owner of the mailing list, and the number of people in the list.",
    "db_id": "dw",
    "sql": "WITH DeduplicatedList AS (SELECT MOIRA_LIST_KEY, MOIRA_LIST_NAME, MAX(IS_MOIRA_MAILING_LIST) AS IS_MOIRA_MAILING_LIST, MAX(IS_MOIRA_GROUP) AS IS_MOIRA_GROUP, MAX(IS_NFS_GROUP) AS IS_NFS_GROUP FROM MOIRA_LIST GROUP BY MOIRA_LIST_KEY, MOIRA_LIST_NAME), MemberCounts AS (SELECT MOIRA_LIST_KEY, COUNT(DISTINCT MOIRA_LIST_MEMBER) AS member_count FROM MOIRA_LIST_DETAIL GROUP BY MOIRA_LIST_KEY HAVING COUNT(DISTINCT MOIRA_LIST_MEMBER) > 1000) SELECT DISTINCT ml.MOIRA_LIST_NAME, ml.IS_MOIRA_MAILING_LIST, ml.IS_MOIRA_GROUP, ml.IS_NFS_GROUP, mlo.OWNER, mc.member_count FROM DeduplicatedList ml JOIN MemberCounts mc ON ml.MOIRA_LIST_KEY = mc.MOIRA_LIST_KEY JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY WHERE UPPER(ml.MOIRA_LIST_NAME) LIKE 'A%';",
    "gold_tables": [
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_OWNER"
    ],
    "mapping": {
      "name": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "mailing list": [
        "MOIRA_LIST.IS_MOIRA_MAILING_LIST"
      ],
      "moira group": [
        "MOIRA_LIST.IS_MOIRA_GROUP"
      ],
      "NFS group": [
        "MOIRA_LIST.IS_NFS_GROUP"
      ],
      "owner": [
        "MOIRA_LIST_OWNER.OWNER"
      ],
      "people": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ],
      [
        "MOIRA_LIST_OWNER.MOIRA_LIST_OWNER_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_OWNER_KEY"
      ]
    ],
    "sample_id": 47
  },
  {
    "question": "List the mailing lists with the largest number of members and the least number of members, including their names, owners, public status, hidden status, and number of members in the list. If a mailing list has multiple owners, create a separate entry for each owner. Similarly, if multiple lists share the minimum or maximum member count, include all those lists.",
    "db_id": "dw",
    "sql": "WITH DeduplicatedList AS (SELECT MOIRA_LIST_KEY, MOIRA_LIST_NAME, MAX(IS_MOIRA_MAILING_LIST) AS IS_MOIRA_MAILING_LIST, MAX(IS_PUBLIC) AS IS_PUBLIC, MAX(IS_HIDDEN) AS IS_HIDDEN FROM MOIRA_LIST GROUP BY MOIRA_LIST_KEY, MOIRA_LIST_NAME), MailingLists AS (SELECT MOIRA_LIST_KEY, MOIRA_LIST_NAME, IS_PUBLIC, IS_HIDDEN FROM DeduplicatedList WHERE IS_MOIRA_MAILING_LIST = 'Y'), MemberCounts AS (SELECT ml.MOIRA_LIST_KEY, COALESCE(mc.member_count, 0) AS member_count FROM MailingLists ml LEFT JOIN (SELECT MOIRA_LIST_KEY, COUNT(DISTINCT MOIRA_LIST_MEMBER) AS member_count FROM MOIRA_LIST_DETAIL GROUP BY MOIRA_LIST_KEY) mc ON mc.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY), ListOwners AS (SELECT DISTINCT mld.MOIRA_LIST_KEY, mlo.OWNER FROM MOIRA_LIST_DETAIL mld JOIN MOIRA_LIST_OWNER mlo ON mlo.MOIRA_LIST_OWNER_KEY = mld.MOIRA_LIST_OWNER_KEY) SELECT DISTINCT ml.MOIRA_LIST_NAME, lo.OWNER, ml.IS_PUBLIC, ml.IS_HIDDEN, mc.member_count FROM MailingLists ml JOIN MemberCounts mc ON mc.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY LEFT JOIN ListOwners lo ON lo.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY WHERE mc.member_count = (SELECT MIN(member_count) FROM MemberCounts) OR mc.member_count = (SELECT MAX(member_count) FROM MemberCounts);",
    "gold_tables": [
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_OWNER"
    ],
    "mapping": {
      "names": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "owners": [
        "MOIRA_LIST_OWNER.OWNER"
      ],
      "public status": [
        "MOIRA_LIST.IS_PUBLIC"
      ],
      "hidden status": [
        "MOIRA_LIST.IS_HIDDEN"
      ],
      "members": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_OWNER_KEY",
        "MOIRA_LIST_OWNER.MOIRA_LIST_OWNER_KEY"
      ]
    ],
    "sample_id": 48
  },
  {
    "question": "For email lists with names starting with C (case insensitive) and containing faculty who teach courses in the summer in financial aid years after 2001, provide the name of the list, the number of people in the list, and the number of faculty in the list.",
    "db_id": "dw",
    "sql": "WITH FilteredLists AS ( SELECT DISTINCT ml.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME FROM MOIRA_LIST ml WHERE upper(ml.MOIRA_LIST_NAME) LIKE 'C%' ), QualifyingLists AS ( SELECT DISTINCT fl.MOIRA_LIST_KEY, fl.MOIRA_LIST_NAME FROM COURSE_CATALOG_SUBJECT_OFFERED ccso JOIN EMPLOYEE_DIRECTORY ed ON ccso.RESPONSIBLE_FACULTY_MIT_ID = ed.MIT_ID JOIN MOIRA_LIST_DETAIL mld ON UPPER(ed.KRB_NAME) = UPPER(mld.MOIRA_LIST_MEMBER) JOIN FilteredLists fl ON mld.MOIRA_LIST_KEY = fl.MOIRA_LIST_KEY JOIN ACADEMIC_TERMS at ON ccso.TERM_CODE = at.TERM_CODE WHERE at.TERM_CODE LIKE '%SU' AND CAST(at.FINANCIAL_AID_YEAR AS UNSIGNED) > 2001 ) SELECT ql.MOIRA_LIST_NAME AS Moira_List_Name, (SELECT COUNT(DISTINCT MOIRA_LIST_MEMBER) FROM MOIRA_LIST_DETAIL WHERE MOIRA_LIST_KEY = ql.MOIRA_LIST_KEY) AS Member_Count, (SELECT COUNT(DISTINCT ed.MIT_ID) FROM COURSE_CATALOG_SUBJECT_OFFERED ccso JOIN EMPLOYEE_DIRECTORY ed ON ccso.RESPONSIBLE_FACULTY_MIT_ID = ed.MIT_ID JOIN MOIRA_LIST_DETAIL mld ON UPPER(ed.KRB_NAME) = UPPER(mld.MOIRA_LIST_MEMBER) JOIN ACADEMIC_TERMS at ON ccso.TERM_CODE = at.TERM_CODE WHERE mld.MOIRA_LIST_KEY = ql.MOIRA_LIST_KEY AND at.TERM_CODE LIKE '%SU' AND CAST(at.FINANCIAL_AID_YEAR AS UNSIGNED) > 2001) AS Distinct_Faculty_Count FROM QualifyingLists ql;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#EMPLOYEE_DIRECTORY",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#ACADEMIC_TERMS"
    ],
    "mapping": {
      "names": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "faculty": [
        "EMPLOYEE_DIRECTORY.MIT_ID"
      ],
      "courses in the summer": [
        "ACADEMIC_TERMS.TERM_CODE"
      ],
      "financial aid years": [
        "ACADEMIC_TERMS.FINANCIAL_AID_YEAR"
      ],
      "people": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ]
    },
    "join_keys": [
      [
        "EMPLOYEE_DIRECTORY.MIT_ID",
        "COURSE_CATALOG_SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID"
      ],
      [
        "ACADEMIC_TERMS.TERM_CODE",
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE"
      ]
    ],
    "sample_id": 49
  },
  {
    "question": "Regarding the mailing list about duo users, provide the number of students in this list, and the number of departments and schools associated with these students.",
    "db_id": "dw",
    "sql": "SELECT COUNT(DISTINCT se.MIT_ID) AS Student_Count, COUNT(DISTINCT sd.DEPARTMENT_CODE) AS Department_Count, COUNT(DISTINCT sd.SCHOOL_CODE) AS School_Count FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN SE_PERSON se ON upper(mld.MOIRA_LIST_MEMBER) = upper(se.KRB_NAME) JOIN MIT_STUDENT_DIRECTORY msd ON msd.FULL_NAME = se.FULL_NAME JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE WHERE ml.MOIRA_LIST_NAME = 'cat-duo-users'",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#SE_PERSON",
      "dw#sep#MIT_STUDENT_DIRECTORY",
      "dw#sep#SIS_DEPARTMENT"
    ],
    "mapping": {
      "duo users": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "students": [
        "SE_PERSON.MIT_ID"
      ],
      "departments": [
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      "schools": [
        "SIS_DEPARTMENT.SCHOOL_CODE"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ],
      [
        "MIT_STUDENT_DIRECTORY.DEPARTMENT",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ]
    ],
    "sample_id": 50
  },
  {
    "question": "For faculty who are responsible for courses in 2023 fall term, list the name of mailing lists with ten members that they subscribe to, the number of faculty in these lists, and the number of courses associated with those faculty.",
    "db_id": "dw",
    "sql": "WITH filtered_lists AS (SELECT mld.MOIRA_LIST_KEY FROM MOIRA_LIST_DETAIL mld GROUP BY mld.MOIRA_LIST_KEY HAVING COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) = 10), instructor_courses AS (SELECT fl.MOIRA_LIST_KEY, ccso.RESPONSIBLE_FACULTY_MIT_ID, COUNT(DISTINCT ccso.SUBJECT_TITLE) AS course_count FROM filtered_lists fl JOIN MOIRA_LIST_DETAIL mld ON fl.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN employee_directory ed ON UPPER(mld.MOIRA_LIST_MEMBER) = UPPER(ed.KRB_NAME) JOIN COURSE_CATALOG_SUBJECT_OFFERED ccso ON ed.MIT_ID = ccso.RESPONSIBLE_FACULTY_MIT_ID WHERE ccso.TERM_CODE = '2023FA' GROUP BY fl.MOIRA_LIST_KEY, ccso.RESPONSIBLE_FACULTY_MIT_ID), instructor_counts AS (SELECT MOIRA_LIST_KEY, COUNT(DISTINCT RESPONSIBLE_FACULTY_MIT_ID) AS instructor_count, SUM(course_count) AS total_courses FROM instructor_courses GROUP BY MOIRA_LIST_KEY) SELECT ml.MOIRA_LIST_NAME, ic.instructor_count, ic.total_courses FROM instructor_counts ic JOIN (SELECT DISTINCT MOIRA_LIST_KEY, MOIRA_LIST_NAME FROM MOIRA_LIST WHERE IS_MOIRA_MAILING_LIST = 'Y') ml ON ic.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY WHERE ic.instructor_count > 0;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#EMPLOYEE_DIRECTORY",
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#MOIRA_LIST"
    ],
    "mapping": {
      "faculty": [
        "COURSE_CATALOG_SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID"
      ],
      "2023 fall term": [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE"
      ],
      "name of mailing lists": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "members": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ],
      "courses": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_TITLE"
      ]
    },
    "join_keys": [
      [
        "employee_directory.MIT_ID",
        "COURSE_CATALOG_SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID"
      ],
      [
        "employee_directory.KRB_NAME",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ]
    ],
    "sample_id": 51
  },
  {
    "question": "For each course instructor in the 'keeper-zephyr' mailing list, provide the name of mailing lists they subscribe to, instructor name, earliest and latest publication years, and total number of enrolled students.",
    "db_id": "dw",
    "sql": "WITH KeeperZephyrInstructors AS (SELECT DISTINCT lci.LIBRARY_COURSE_INSTRUCTOR_KEY, lci.INSTRUCTOR_NAME, sep.KRB_NAME FROM LIBRARY_COURSE_INSTRUCTOR lci JOIN SE_PERSON sep ON lci.INSTRUCTOR_NAME = sep.FULL_NAME JOIN MOIRA_LIST_DETAIL mld ON UPPER(sep.KRB_NAME) = UPPER(mld.MOIRA_LIST_MEMBER) JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY WHERE ml.MOIRA_LIST_NAME = 'keeper-zephyr'), AllListsForInstructors AS (SELECT DISTINCT kzi.LIBRARY_COURSE_INSTRUCTOR_KEY, kzi.INSTRUCTOR_NAME, ml.MOIRA_LIST_NAME FROM KeeperZephyrInstructors kzi JOIN MOIRA_LIST_DETAIL mld ON UPPER(kzi.KRB_NAME) = UPPER(mld.MOIRA_LIST_MEMBER) JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY), SubjectEnrollment AS (SELECT lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY, SUM(lso.NUM_ENROLLED_STUDENTS) as enrollment, MIN(lrc.CATALOG_YEAR) as min_year, MAX(lrc.CATALOG_YEAR) as max_year FROM LIBRARY_RESERVE_MATRL_DETAIL lrmd JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY GROUP BY lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY) SELECT ali.MOIRA_LIST_NAME, ali.INSTRUCTOR_NAME, MIN(se.min_year) AS Min_Publication_Year, MAX(se.max_year) AS Max_Publication_Year, SUM(se.enrollment) AS Total_Enrolled_Students FROM AllListsForInstructors ali JOIN SubjectEnrollment se ON ali.LIBRARY_COURSE_INSTRUCTOR_KEY = se.LIBRARY_COURSE_INSTRUCTOR_KEY GROUP BY ali.MOIRA_LIST_NAME, ali.INSTRUCTOR_NAME;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#LIBRARY_COURSE_INSTRUCTOR",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#LIBRARY_SUBJECT_OFFERED",
      "dw#sep#SE_PERSON"
    ],
    "mapping": {
      "'keeper-zephyr' mailing list": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "name of mailing lists": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "instructor name": [
        "LIBRARY_COURSE_INSTRUCTOR.INSTRUCTOR_NAME"
      ],
      "publication years": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_YEAR"
      ],
      "enrolled students": [
        "LIBRARY_SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY",
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_COURSE_INSTRUCTOR.INSTRUCTOR_NAME",
        "SE_PERSON.FULL_NAME"
      ],
      [
        "SE_PERSON.KRB_NAME",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ]
    ],
    "sample_id": 52
  },
  {
    "question": "For each mailing list with a name beginning with R (case insensitive), and that Professor Ayden Hopkins is subscribed to, list its name, description, owner, number of people in the list, and number of tenured faculty in the list.",
    "db_id": "dw",
    "sql": "WITH FilteredLists AS ( SELECT DISTINCT ml.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME, ml.MOIRA_LIST_DESCRIPTION, mlo.OWNER FROM SE_PERSON se JOIN MOIRA_LIST_DETAIL mld ON UPPER(se.KRB_NAME) = UPPER(mld.MOIRA_LIST_MEMBER) JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY JOIN MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY WHERE se.FULL_NAME = 'Hopkins, Ayden' AND UPPER(ml.MOIRA_LIST_NAME) LIKE 'R%' ), MemberCounts AS ( SELECT fl.MOIRA_LIST_KEY, fl.MOIRA_LIST_NAME, fl.MOIRA_LIST_DESCRIPTION, fl.OWNER, COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS Member_Count FROM FilteredLists fl JOIN MOIRA_LIST_DETAIL mld ON fl.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY GROUP BY fl.MOIRA_LIST_KEY, fl.MOIRA_LIST_NAME, fl.MOIRA_LIST_DESCRIPTION, fl.OWNER ), FacultyTenuredCounts AS ( SELECT fl.MOIRA_LIST_KEY, COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS Faculty_Tenured_Count FROM FilteredLists fl JOIN MOIRA_LIST_DETAIL mld ON fl.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN SE_PERSON se ON UPPER(mld.MOIRA_LIST_MEMBER) = UPPER(se.KRB_NAME) WHERE se.PAYROLL_RANK = 'Faculty Tenured' GROUP BY fl.MOIRA_LIST_KEY ) SELECT DISTINCT mc.MOIRA_LIST_NAME, mc.MOIRA_LIST_DESCRIPTION, mc.OWNER, mc.Member_Count, COALESCE(ftc.Faculty_Tenured_Count, 0) AS Faculty_Tenured_Count FROM MemberCounts mc LEFT JOIN FacultyTenuredCounts ftc ON mc.MOIRA_LIST_KEY = ftc.MOIRA_LIST_KEY ORDER BY mc.Member_Count DESC;",
    "gold_tables": [
      "dw#sep#SE_PERSON",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_OWNER"
    ],
    "mapping": {
      "name": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "Professor Ayden Hopkins": [
        "SE_PERSON.FULL_NAME"
      ],
      "description": [
        "MOIRA_LIST.MOIRA_LIST_DESCRIPTION"
      ],
      "owner": [
        "MOIRA_LIST_OWNER.OWNER"
      ],
      "people": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ],
      "tenured faculty": [
        "SE_PERSON.PAYROLL_RANK",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ],
      [
        "MOIRA_LIST_OWNER.MOIRA_LIST_OWNER_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_OWNER_KEY"
      ]
    ],
    "sample_id": 53
  },
  {
    "question": "For the email list with name 'date-destiny', list the name of the list, department name, the number of students from the Management department, and the percentage of students who are from the Management department, rounded to two decimal places.",
    "db_id": "dw",
    "sql": "WITH FilteredList AS (SELECT MOIRA_LIST_KEY, MOIRA_LIST_NAME FROM MOIRA_LIST WHERE MOIRA_LIST_NAME = 'date-destiny'), FilteredListDetails AS (SELECT mld.MOIRA_LIST_KEY, mld.MOIRA_LIST_MEMBER FROM MOIRA_LIST_DETAIL mld JOIN FilteredList fl ON mld.MOIRA_LIST_KEY = fl.MOIRA_LIST_KEY) SELECT ml.MOIRA_LIST_NAME, 'Management' AS DEPARTMENT_NAME, COUNT(DISTINCT CASE WHEN UPPER(ad.SIS_ADMIN_DEPARTMENT_NAME) = 'MANAGEMENT' THEN fld.MOIRA_LIST_MEMBER END) AS MANAGEMENT_STUDENT_COUNT, ROUND(COUNT(DISTINCT CASE WHEN UPPER(ad.SIS_ADMIN_DEPARTMENT_NAME) = 'MANAGEMENT' THEN fld.MOIRA_LIST_MEMBER END) * 100.0 / COUNT(DISTINCT fld.MOIRA_LIST_MEMBER), 2) AS MANAGEMENT_STUDENT_PERCENTAGE FROM MIT_STUDENT_DIRECTORY msd JOIN SE_PERSON se ON msd.FULL_NAME = se.FULL_NAME JOIN FilteredListDetails fld ON UPPER(se.KRB_NAME) = UPPER(fld.MOIRA_LIST_MEMBER) JOIN FilteredList ml ON fld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY LEFT JOIN SIS_ADMIN_DEPARTMENT ad ON msd.DEPARTMENT = ad.SIS_ADMIN_DEPARTMENT_CODE GROUP BY ml.MOIRA_LIST_NAME;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MIT_STUDENT_DIRECTORY",
      "dw#sep#SE_PERSON",
      "dw#sep#SIS_ADMIN_DEPARTMENT"
    ],
    "mapping": {
      "name": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "department name": [
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_NAME"
      ],
      "students": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ],
      "Management department": [
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_NAME"
      ]
    },
    "join_keys": [
      [
        "SE_PERSON.FULL_NAME",
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ],
      [
        "SE_PERSON.KRB_NAME",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ],
      [
        "MIT_STUDENT_DIRECTORY.DEPARTMENT",
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_CODE"
      ]
    ],
    "sample_id": 54
  },
  {
    "question": "For the building with the most floors, list the building name and the names of the mailing lists staring with a (case insensitive) that the building employees with kerberos starting with c (case insensitive) subscribe to.",
    "db_id": "dw",
    "sql": "WITH FilteredMoiraLists AS ( SELECT MOIRA_LIST_KEY, MOIRA_LIST_NAME FROM MOIRA_LIST WHERE MOIRA_LIST_NAME LIKE 'a%' ), FilteredMoiraListDetails AS ( SELECT mld.MOIRA_LIST_MEMBER, mld.MOIRA_LIST_KEY FROM MOIRA_LIST_DETAIL mld JOIN FilteredMoiraLists fml ON mld.MOIRA_LIST_KEY = fml.MOIRA_LIST_KEY ), FloorsWithLevels AS ( SELECT fb.BUILDING_NAME, MAX(CAST(ff.LEVEL_ID AS SIGNED)) OVER (PARTITION BY ff.BUILDING_KEY) AS MAX_LEVEL, MIN(CAST(ff.LEVEL_ID AS SIGNED)) OVER (PARTITION BY ff.BUILDING_KEY) AS MIN_LEVEL FROM FAC_BUILDING fb JOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY JOIN FAC_FLOOR ff ON fr.FLOOR_KEY = ff.FLOOR_KEY ), FloorsPerBuilding AS ( SELECT BUILDING_NAME, MAX_LEVEL - MIN_LEVEL + 1 AS NUM_FLOORS FROM FloorsWithLevels GROUP BY BUILDING_NAME, MAX_LEVEL, MIN_LEVEL ), MaxFloors AS ( SELECT MAX(NUM_FLOORS) AS MAX_FLOORS FROM FloorsPerBuilding ), BuildingWithMostFloors AS ( SELECT a.BUILDING_NAME FROM FloorsPerBuilding a JOIN MaxFloors b ON a.NUM_FLOORS = b.MAX_FLOORS ), EmployeesInTallestBuildings AS ( SELECT DISTINCT UPPER(e.KRB_NAME) AS KRB_NAME, fb.building_name FROM BuildingWithMostFloors b JOIN FAC_BUILDING fb ON b.BUILDING_NAME = fb.BUILDING_NAME JOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY JOIN EMPLOYEE_DIRECTORY e ON e.OFFICE_LOCATION = fr.FAC_ROOM_KEY WHERE upper(e.KRB_NAME) LIKE 'C%' ) SELECT DISTINCT etb.BUILDING_NAME, fml.MOIRA_LIST_NAME FROM EmployeesInTallestBuildings etb JOIN FilteredMoiraListDetails fmld ON UPPER(etb.KRB_NAME) = UPPER(fmld.MOIRA_LIST_MEMBER) JOIN FilteredMoiraLists fml ON fmld.MOIRA_LIST_KEY = fml.MOIRA_LIST_KEY;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_FLOOR",
      "dw#sep#EMPLOYEE_DIRECTORY"
    ],
    "mapping": {
      "floors": [
        "FAC_FLOOR.LEVEL_ID"
      ],
      "building name": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "names of the mailing lists": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "kerberos": [
        "EMPLOYEE_DIRECTORY.KRB_NAME"
      ]
    },
    "join_keys": [
      [
        "FAC_ROOMS.BUILDING_KEY",
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ],
      [
        "FAC_FLOOR.FLOOR_KEY",
        "FAC_ROOMS.FLOOR_KEY"
      ],
      [
        "FAC_ROOMS.FAC_ROOM_KEY",
        "EMPLOYEE_DIRECTORY.OFFICE_LOCATION"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER",
        "EMPLOYEE_DIRECTORY.KRB_NAME"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ]
    ],
    "sample_id": 55
  },
  {
    "question": "For the email lists subscribed by faculty members with last names begin with Y, list the names of the lists, the total number of subjects managed by faculty in those mailing lists, and the number of such faculty in the lists.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT ml.MOIRA_LIST_NAME, COUNT(DISTINCT ccso.SUBJECT_ID) AS course_count, COUNT(DISTINCT ccso.RESPONSIBLE_FACULTY_NAME) AS distinct_faculty_count FROM COURSE_CATALOG_SUBJECT_OFFERED CCSO JOIN EMPLOYEE_DIRECTORY E ON ccso.RESPONSIBLE_FACULTY_MIT_ID = E.MIT_ID JOIN MOIRA_LIST_DETAIL mld ON upper(e.KRB_NAME_UPPERCASE) = upper(mld.MOIRA_LIST_MEMBER) JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY WHERE ccso.RESPONSIBLE_FACULTY_NAME LIKE 'Y%' GROUP BY ML.MOIRA_LIST_NAME;",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#EMPLOYEE_DIRECTORY",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MOIRA_LIST"
    ],
    "mapping": {
      "last names": [
        "COURSE_CATALOG_SUBJECT_OFFERED.RESPONSIBLE_FACULTY_NAME"
      ],
      "names of the lists": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "subjects": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "faculty": [
        "COURSE_CATALOG_SUBJECT_OFFERED.RESPONSIBLE_FACULTY_NAME"
      ]
    },
    "join_keys": [
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID",
        "EMPLOYEE_DIRECTORY.MIT_ID"
      ],
      [
        "EMPLOYEE_DIRECTORY.KRB_NAME_UPPERCASE",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ]
    ],
    "sample_id": 56
  },
  {
    "question": "For students with last names starting with H who are subscribed to mailing list 'beacon-date-date', list the names of the students, the phone numbers of departments they belong to, and the size of the mailing list 'beacon-date-date' that they are subscribed to.",
    "db_id": "dw",
    "sql": "WITH FilteredMoiraLists AS ( SELECT MOIRA_LIST_KEY, MOIRA_LIST_NAME FROM MOIRA_LIST WHERE MOIRA_LIST_NAME = 'beacon-date-date' ), FilteredMoiraListDetails AS ( SELECT mld.MOIRA_LIST_MEMBER, mld.MOIRA_LIST_KEY FROM MOIRA_LIST_DETAIL mld JOIN FilteredMoiraLists fml ON mld.MOIRA_LIST_KEY = fml.MOIRA_LIST_KEY ), MailingListSizes AS ( SELECT fml.MOIRA_LIST_KEY, fml.MOIRA_LIST_NAME, COUNT(fmld.MOIRA_LIST_MEMBER) AS List_Size FROM FilteredMoiraLists fml JOIN FilteredMoiraListDetails fmld ON fml.MOIRA_LIST_KEY = fmld.MOIRA_LIST_KEY GROUP BY fml.MOIRA_LIST_KEY, fml.MOIRA_LIST_NAME ) SELECT msd.FULL_NAME AS Student_Name, sad.DEPARTMENT_PHONE_NUMBER, MLS.List_Size AS List_Size FROM MIT_STUDENT_DIRECTORY msd JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE JOIN SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE JOIN SE_PERSON se ON msd.FULL_NAME = se.FULL_NAME JOIN FilteredMoiraListDetails fmld ON UPPER(se.KRB_NAME) = UPPER(fmld.MOIRA_LIST_MEMBER) JOIN FilteredMoiraLists fml ON fmld.MOIRA_LIST_KEY = fml.MOIRA_LIST_KEY JOIN MailingListSizes MLS ON fml.MOIRA_LIST_KEY = MLS.MOIRA_LIST_KEY WHERE msd.LAST_NAME LIKE 'H%';",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MIT_STUDENT_DIRECTORY",
      "dw#sep#SIS_DEPARTMENT",
      "dw#sep#SIS_ADMIN_DEPARTMENT",
      "dw#sep#SE_PERSON"
    ],
    "mapping": {
      "last names": [
        "MIT_STUDENT_DIRECTORY.LAST_NAME"
      ],
      "mailing list 'beacon-date-date'": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "names": [
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ],
      "phone numbers": [
        "SIS_ADMIN_DEPARTMENT.DEPARTMENT_PHONE_NUMBER"
      ],
      "size of the mailing list": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ],
      [
        "MIT_STUDENT_DIRECTORY.DEPARTMENT",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      [
        "SIS_DEPARTMENT.DEPARTMENT_CODE",
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_CODE"
      ],
      [
        "MIT_STUDENT_DIRECTORY.FULL_NAME",
        "SE_PERSON.FULL_NAME"
      ],
      [
        "SE_PERSON.KRB_NAME",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ],
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ]
    ],
    "sample_id": 57
  },
  {
    "question": "Give the count of mailing lists with names starting with B that include members from the Electrical Engineering and Computer Science department, along with the name of the list starting with B that have the highest number of members from that department and the corresponding member count.",
    "db_id": "dw",
    "sql": "WITH DistinctLists AS ( SELECT ml.MOIRA_LIST_NAME, COUNT(DISTINCT se.MIT_ID) AS Member_Count FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN SE_PERSON se ON UPPER(mld.MOIRA_LIST_MEMBER) = UPPER(se.KRB_NAME) WHERE UPPER(ml.MOIRA_LIST_NAME) LIKE 'B%' AND se.ORGANIZATION = 'Electrical Engineering-Computer Science' GROUP BY ml.MOIRA_LIST_NAME ), Moira_List_With_Most_Members AS ( SELECT MOIRA_LIST_NAME, Member_Count FROM DistinctLists WHERE Member_Count = (SELECT MAX(Member_Count) FROM DistinctLists) ) SELECT COUNT(DISTINCT dl.MOIRA_LIST_NAME) AS Moira_Lists_Start_With_B, (SELECT MOIRA_LIST_NAME FROM Moira_List_With_Most_Members LIMIT 1) AS Moira_List_With_Most_Members, (SELECT Member_Count FROM Moira_List_With_Most_Members LIMIT 1) AS Most_Number_Of_Members FROM DistinctLists dl;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#SE_PERSON"
    ],
    "mapping": {
      "mailing lists": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "names": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "members": [
        "SE_PERSON.MIT_ID"
      ],
      "Electrical Engineering and Computer Science department": [
        "SE_PERSON.ORGANIZATION"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER",
        "SE_PERSON.KRB_NAME"
      ]
    ],
    "sample_id": 58
  },
  {
    "question": "For the 'kangaroo-inspire-yearn' email list, for each department present in the list, list the department name, the number of students in that department, and its percentage relative to the students in the mailing list.",
    "db_id": "dw",
    "sql": "WITH FilteredList AS ( \n    SELECT MOIRA_LIST_KEY, MOIRA_LIST_NAME \n    FROM MOIRA_LIST \n    WHERE MOIRA_LIST_NAME = 'kangaroo-inspire-yearn' \n), \nFilteredListDetails AS ( \n    SELECT mld.MOIRA_LIST_KEY, mld.MOIRA_LIST_MEMBER \n    FROM MOIRA_LIST_DETAIL mld \n    JOIN FilteredList fl ON mld.MOIRA_LIST_KEY = fl.MOIRA_LIST_KEY \n), \nMatchedStudents AS (\n    SELECT fld.MOIRA_LIST_MEMBER, msd.DEPARTMENT,\n           ROW_NUMBER() OVER (PARTITION BY fld.MOIRA_LIST_MEMBER ORDER BY msd.FULL_NAME) as rn\n    FROM FilteredListDetails fld\n    JOIN SE_PERSON se ON UPPER(se.KRB_NAME) = UPPER(fld.MOIRA_LIST_MEMBER)\n    JOIN MIT_STUDENT_DIRECTORY msd ON msd.FULL_NAME = se.FULL_NAME\n),\nDepartmentCounts AS ( \n    SELECT ad.SIS_ADMIN_DEPARTMENT_NAME AS department_name, \n           COUNT(DISTINCT ms.MOIRA_LIST_MEMBER) AS department_student_count \n    FROM MatchedStudents ms\n    LEFT JOIN SIS_ADMIN_DEPARTMENT ad ON ms.DEPARTMENT = ad.SIS_ADMIN_DEPARTMENT_CODE \n    WHERE ms.rn = 1\n    GROUP BY ad.SIS_ADMIN_DEPARTMENT_NAME \n), \nTotalStudents AS ( \n    SELECT COUNT(DISTINCT MOIRA_LIST_MEMBER) AS total_students \n    FROM MatchedStudents WHERE rn = 1\n) \nSELECT dc.department_name, dc.department_student_count, \n       ROUND( dc.department_student_count * 100.0 / ts.total_students, 2 ) AS department_student_percentage \nFROM DepartmentCounts dc, TotalStudents ts;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MIT_STUDENT_DIRECTORY",
      "dw#sep#SE_PERSON",
      "dw#sep#SIS_ADMIN_DEPARTMENT"
    ],
    "mapping": {
      "'kangaroo-inspire-yearn' email list": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "department name": [
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_NAME"
      ],
      "students": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ]
    },
    "join_keys": [
      [
        "SE_PERSON.FULL_NAME",
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ],
      [
        "SE_PERSON.KRB_NAME",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ],
      [
        "MIT_STUDENT_DIRECTORY.DEPARTMENT",
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_CODE"
      ]
    ],
    "sample_id": 59
  },
  {
    "question": "Among the mailing lists subscribed by people with physical offices in building 24, provide the name of the most subscribed mailing list and the total number of subscribers.",
    "db_id": "dw",
    "sql": "WITH MailingListStats AS ( SELECT ml.MOIRA_LIST_NAME, COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS Total_Members FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN EMPLOYEE_DIRECTORY ed ON mld.MOIRA_LIST_MEMBER = ed.KRB_NAME WHERE ed.OFFICE_LOCATION LIKE '24%' GROUP BY ml.MOIRA_LIST_NAME ), Largest AS ( SELECT MOIRA_LIST_NAME, Total_Members, RANK() OVER (ORDER BY Total_Members DESC) AS Size_Rank FROM MailingListStats ) SELECT MAX(CASE WHEN Size_Rank = 1 THEN MOIRA_LIST_NAME END) AS Largest_Mailing_List, MAX(CASE WHEN Size_Rank = 1 THEN Total_Members END) AS Member_Count FROM Largest;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#EMPLOYEE_DIRECTORY"
    ],
    "mapping": {
      "physical offices in building 24": [
        "EMPLOYEE_DIRECTORY.OFFICE_LOCATION"
      ],
      "name": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "subscribers": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ],
      [
        "EMPLOYEE_DIRECTORY.KRB_NAME",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ]
    ],
    "sample_id": 60
  },
  {
    "question": "For email lists subscribed by either support staff or faculty, list its name, the number of subscribers that are support staff, the number of subscribers that are faculty, as well as its active status.",
    "db_id": "dw",
    "sql": "SELECT ml.MOIRA_LIST_NAME, COUNT(DISTINCT CASE WHEN se.EMPLOYEE_TYPE = 'Support Staff' THEN mld.MOIRA_LIST_MEMBER END) AS SUPPORT_COUNT, COUNT(DISTINCT CASE WHEN se.EMPLOYEE_TYPE = 'Faculty' THEN mld.MOIRA_LIST_MEMBER END) AS FACULTY_COUNT, ml.IS_ACTIVE FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN SE_PERSON se ON upper(mld.MOIRA_LIST_MEMBER) = upper(se.KRB_NAME) WHERE se.EMPLOYEE_TYPE IN ('Support Staff', 'Faculty') GROUP BY ml.MOIRA_LIST_NAME, ml.IS_ACTIVE;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#SE_PERSON"
    ],
    "mapping": {
      "support staff or faculty": [
        "SE_PERSON.EMPLOYEE_TYPE"
      ],
      "name": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "subscribers": [
        "SE_PERSON.EMPLOYEE_TYPE"
      ],
      "active status": [
        "MOIRA_LIST.IS_ACTIVE"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ]
    ],
    "sample_id": 61
  },
  {
    "question": "For the 'ocean-apple' mailing list, identify the department with the highest student count. Provide the department name, phone number, and the total number of students subscribed to the mailing list from that department. If multiple departments have the same highest count, list each one separately.",
    "db_id": "dw",
    "sql": "WITH FilteredList AS ( SELECT MOIRA_LIST_KEY, MOIRA_LIST_NAME FROM MOIRA_LIST WHERE MOIRA_LIST_NAME = 'ocean-apple' ), FilteredListDetails AS ( SELECT mld.MOIRA_LIST_KEY, mld.MOIRA_LIST_MEMBER FROM MOIRA_LIST_DETAIL mld JOIN FilteredList fl ON mld.MOIRA_LIST_KEY = fl.MOIRA_LIST_KEY ), StudentMemberCounts AS ( SELECT fl.MOIRA_LIST_KEY, fl.MOIRA_LIST_NAME, ad.DEPARTMENT_PHONE_NUMBER AS department_phone, ad.SIS_ADMIN_DEPARTMENT_NAME AS department_name, COUNT(DISTINCT msd.FULL_NAME) AS student_members FROM FilteredList fl JOIN FilteredListDetails fld ON fl.MOIRA_LIST_KEY = fld.MOIRA_LIST_KEY JOIN SE_PERSON se ON UPPER(fld.MOIRA_LIST_MEMBER) = UPPER(se.KRB_NAME) JOIN MIT_STUDENT_DIRECTORY msd ON se.FULL_NAME = msd.FULL_NAME LEFT JOIN SIS_ADMIN_DEPARTMENT ad ON msd.DEPARTMENT = ad.SIS_ADMIN_DEPARTMENT_CODE GROUP BY fl.MOIRA_LIST_KEY, fl.MOIRA_LIST_NAME, ad.DEPARTMENT_PHONE_NUMBER, ad.SIS_ADMIN_DEPARTMENT_NAME ), RankedDepartments AS ( SELECT department_name, department_phone, SUM(student_members) AS total_student_members, RANK() OVER (ORDER BY SUM(student_members) DESC) AS department_rank FROM StudentMemberCounts GROUP BY department_name, department_phone ) SELECT department_name AS most_prominent_dpt, department_phone AS most_prominent_dpt_phone, total_student_members FROM RankedDepartments WHERE department_rank = 1;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#SE_PERSON",
      "dw#sep#MIT_STUDENT_DIRECTORY",
      "dw#sep#SIS_ADMIN_DEPARTMENT"
    ],
    "mapping": {
      "'ocean-apple' mailing list": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "department name": [
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_NAME"
      ],
      "phone number": [
        "SIS_ADMIN_DEPARTMENT.DEPARTMENT_PHONE_NUMBER"
      ],
      "students": [
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER",
        "SE_PERSON.KRB_NAME"
      ],
      [
        "SE_PERSON.FULL_NAME",
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ],
      [
        "MIT_STUDENT_DIRECTORY.DEPARTMENT",
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_CODE"
      ]
    ],
    "sample_id": 62
  },
  {
    "question": "For each mailing list, list its owner, owner type, the member visibility ('Public Members' if public, and 'Hidden Members' otherwise), and the number of members of this type of visibility. For each owner and owner type, include a grand total for all members in the format of (owner, owner type, null, total members).",
    "db_id": "dw",
    "sql": "WITH DeduplicatedList AS (SELECT MOIRA_LIST_KEY, MOIRA_LIST_NAME, MAX(IS_PUBLIC) AS IS_PUBLIC, MAX(IS_MOIRA_GROUP) AS IS_MOIRA_GROUP FROM MOIRA_LIST GROUP BY MOIRA_LIST_KEY, MOIRA_LIST_NAME), BaseData AS (SELECT mo.OWNER, mo.OWNER_TYPE, ml.MOIRA_LIST_NAME, CASE WHEN ml.IS_PUBLIC = 'Y' THEN 'Public Members' WHEN ml.IS_PUBLIC = 'N' THEN 'Hidden Members' ELSE NULL END AS member_visibility, COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS total_members FROM MOIRA_LIST_DETAIL mld JOIN DeduplicatedList ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY JOIN MOIRA_LIST_OWNER mo ON mld.MOIRA_LIST_OWNER_KEY = mo.MOIRA_LIST_OWNER_KEY WHERE ml.IS_MOIRA_GROUP = 'Y' GROUP BY mo.OWNER, mo.OWNER_TYPE, ml.MOIRA_LIST_NAME, ml.IS_PUBLIC), OwnerTotals AS (SELECT OWNER, OWNER_TYPE, NULL AS MOIRA_LIST_NAME, NULL AS member_visibility, SUM(total_members) AS total_members FROM BaseData GROUP BY OWNER, OWNER_TYPE) SELECT MOIRA_LIST_NAME, OWNER, OWNER_TYPE, member_visibility, total_members FROM BaseData UNION ALL SELECT MOIRA_LIST_NAME, OWNER, OWNER_TYPE, member_visibility, total_members FROM OwnerTotals ORDER BY OWNER, OWNER_TYPE, MOIRA_LIST_NAME;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_OWNER"
    ],
    "mapping": {
      "owner": [
        "MOIRA_LIST_OWNER.OWNER"
      ],
      "owner type": [
        "MOIRA_LIST_OWNER.OWNER_TYPE"
      ],
      "member visibility": [
        "MOIRA_LIST.IS_PUBLIC"
      ],
      "members": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ],
      [
        "MOIRA_LIST_OWNER.MOIRA_LIST_OWNER_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_OWNER_KEY"
      ]
    ],
    "sample_id": 63
  },
  {
    "question": "Group biology courses by cluster type and course level. For each group, list the name of the department, the course title, cluster type, total enrollments, average enrollment within its cluster, course level, number of unique course materials, average new and used prices for TIP materials, total material record count for TIP materials, number of unique library titles, and number of unique library ISBNs.",
    "db_id": "dw",
    "sql": "WITH DedupCourseLevel AS (SELECT COURSE, MAX(COURSE_LEVEL) AS COURSE_LEVEL FROM SIS_COURSE_DESCRIPTION GROUP BY COURSE), BaseEnrollment AS (SELECT sos.SUBJECT_ID, sos.SUBJECT_TITLE, sos.OFFER_DEPT_NAME AS DEPARTMENT, sos.CLUSTER_TYPE, sos.NUM_ENROLLED_STUDENTS, AVG(sos.NUM_ENROLLED_STUDENTS) OVER (PARTITION BY sos.CLUSTER_TYPE) AS avg_enrollment_in_cluster, dcl.COURSE_LEVEL FROM SUBJECT_OFFERED_SUMMARY sos LEFT JOIN DedupCourseLevel dcl ON sos.COURSE_NUMBER = dcl.COURSE WHERE sos.OFFER_DEPT_NAME = 'Biology'), TIPStats AS (SELECT td.SUBJECT_ID, COUNT(DISTINCT tm.TITLE) AS num_unique_materials, AVG(tm.NEW_SHELF_PRICE) AS avg_new_price, AVG(tm.USED_SHELF_PRICE) AS avg_used_price, SUM(td.RECORD_COUNT) AS total_records FROM TIP_DETAIL td LEFT JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY GROUP BY td.SUBJECT_ID), LibraryStats AS (SELECT lrc.CATALOG_SYSTEM_NUMBER AS SUBJECT_ID, COUNT(DISTINCT lrc.CATALOG_TITLE) AS num_library_titles, COUNT(DISTINCT lrc.CATALOG_ISBN) AS num_library_isbns FROM LIBRARY_RESERVE_CATALOG lrc GROUP BY lrc.CATALOG_SYSTEM_NUMBER) SELECT be.DEPARTMENT, be.SUBJECT_TITLE, be.CLUSTER_TYPE, SUM(be.NUM_ENROLLED_STUDENTS) AS total_enrollment, AVG(be.avg_enrollment_in_cluster) AS avg_enrollment_in_cluster, be.COURSE_LEVEL, COALESCE(SUM(ts.num_unique_materials), 0) AS num_unique_materials, AVG(ts.avg_new_price) AS avg_new_material_price, AVG(ts.avg_used_price) AS avg_used_material_price, COALESCE(SUM(ts.total_records), 0) AS total_material_records, COALESCE(SUM(ls.num_library_titles), 0) AS num_unique_library_titles, COALESCE(SUM(ls.num_library_isbns), 0) AS num_unique_library_isbns FROM BaseEnrollment be LEFT JOIN TIPStats ts ON be.SUBJECT_ID = ts.SUBJECT_ID LEFT JOIN LibraryStats ls ON be.SUBJECT_ID = ls.SUBJECT_ID GROUP BY be.DEPARTMENT, be.SUBJECT_TITLE, be.CLUSTER_TYPE, be.COURSE_LEVEL ORDER BY be.DEPARTMENT, be.SUBJECT_TITLE, be.CLUSTER_TYPE;",
    "gold_tables": [
      "dw#sep#SUBJECT_OFFERED_SUMMARY",
      "dw#sep#SIS_COURSE_DESCRIPTION",
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_MATERIAL",
      "dw#sep#LIBRARY_RESERVE_CATALOG"
    ],
    "mapping": {
      "biology courses": [
        "SUBJECT_OFFERED_SUMMARY.OFFER_DEPT_NAME"
      ],
      "cluster type": [
        "SUBJECT_OFFERED_SUMMARY.CLUSTER_TYPE"
      ],
      "course level": [
        "SIS_COURSE_DESCRIPTION.COURSE_LEVEL"
      ],
      "name of the department": [
        "SUBJECT_OFFERED_SUMMARY.OFFER_DEPT_NAME"
      ],
      "course title": [
        "SUBJECT_OFFERED_SUMMARY.SUBJECT_TITLE"
      ],
      "enrollment": [
        "SUBJECT_OFFERED_SUMMARY.NUM_ENROLLED_STUDENTS"
      ],
      "course materials": [
        "TIP_MATERIAL.TITLE"
      ],
      "new price": [
        "TIP_MATERIAL.NEW_SHELF_PRICE"
      ],
      "use price": [
        "TIP_MATERIAL.USED_SHELF_PRICE"
      ],
      "record count for TIP materials": [
        "TIP_DETAIL.RECORD_COUNT"
      ],
      "library titles": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_TITLE"
      ],
      "library ISBNs": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_ISBN"
      ]
    },
    "join_keys": [
      [
        "SUBJECT_OFFERED_SUMMARY.COURSE_NUMBER",
        "SIS_COURSE_DESCRIPTION.COURSE"
      ],
      [
        "TIP_MATERIAL.TIP_MATERIAL_KEY",
        "TIP_DETAIL.TIP_MATERIAL_KEY"
      ],
      [
        "SUBJECT_OFFERED_SUMMARY.SUBJECT_ID",
        "TIP_DETAIL.SUBJECT_ID"
      ],
      [
        "SUBJECT_OFFERED_SUMMARY.SUBJECT_ID",
        "LIBRARY_RESERVE_CATALOG.CATALOG_SYSTEM_NUMBER"
      ]
    ],
    "sample_id": 64
  },
  {
    "question": "For Political Science courses with HASS attributes, for each attribute, list the name and description of the attribute, the number of unique subjects, average units, the total enrollment, the number of departments that grant degrees, and the subject code description.",
    "db_id": "dw",
    "sql": "WITH SubjectInfo AS (SELECT cc.SUBJECT_ID, MAX(cc.HASS_ATTRIBUTE) AS HASS_ATTRIBUTE, MAX(cc.HASS_ATTRIBUTE_DESC) AS HASS_ATTRIBUTE_DESC, MAX(cc.TOTAL_UNITS) AS TOTAL_UNITS, MAX(cc.SUBJECT_CODE) AS SUBJECT_CODE FROM CIS_COURSE_CATALOG cc JOIN SIS_SUBJECT_CODE sc ON cc.SUBJECT_CODE = sc.SUBJECT_CODE LEFT JOIN SIS_DEPARTMENT sd ON sc.DEPARTMENT_CODE = sd.DEPARTMENT_CODE WHERE cc.HASS_ATTRIBUTE IS NOT NULL AND sd.DEPARTMENT_NAME = 'Political Science' GROUP BY cc.SUBJECT_ID), EnrollmentBySubject AS (SELECT SUBJECT_ID, SUM(NUM_ENROLLED_STUDENTS) AS total_enrollment FROM SUBJECT_OFFERED_SUMMARY GROUP BY SUBJECT_ID) SELECT si.HASS_ATTRIBUTE, si.HASS_ATTRIBUTE_DESC, COUNT(*) AS num_subjects, AVG(si.TOTAL_UNITS) AS avg_units, SUM(COALESCE(e.total_enrollment, 0)) AS total_enrollment, COUNT(DISTINCT CASE WHEN sd.IS_DEGREE_GRANTING = 'Y' THEN sd.DEPARTMENT_NAME END) AS num_degree_granting, sc.SUBJECT_CODE_DESC FROM SubjectInfo si LEFT JOIN EnrollmentBySubject e ON si.SUBJECT_ID = e.SUBJECT_ID LEFT JOIN SIS_SUBJECT_CODE sc ON si.SUBJECT_CODE = sc.SUBJECT_CODE LEFT JOIN SIS_DEPARTMENT sd ON sc.DEPARTMENT_CODE = sd.DEPARTMENT_CODE GROUP BY si.HASS_ATTRIBUTE, si.HASS_ATTRIBUTE_DESC, sc.SUBJECT_CODE_DESC ORDER BY si.HASS_ATTRIBUTE;",
    "gold_tables": [
      "dw#sep#CIS_COURSE_CATALOG",
      "dw#sep#SIS_SUBJECT_CODE",
      "dw#sep#SUBJECT_OFFERED_SUMMARY",
      "dw#sep#SIS_DEPARTMENT"
    ],
    "mapping": {
      "Political Science": [
        "SIS_DEPARTMENT.DEPARTMENT_NAME"
      ],
      "name": [
        "CIS_COURSE_CATALOG.HASS_ATTRIBUTE"
      ],
      "description": [
        "CIS_COURSE_CATALOG.HASS_ATTRIBUTE_DESC"
      ],
      "subjects": [
        "CIS_COURSE_CATALOG.SUBJECT_ID"
      ],
      "units": [
        "CIS_COURSE_CATALOG.TOTAL_UNITS"
      ],
      "enrollment": [
        "SUBJECT_OFFERED_SUMMARY.NUM_ENROLLED_STUDENTS"
      ],
      "departments that grant degrees": [
        "SIS_DEPARTMENT.IS_DEGREE_GRANTING"
      ],
      "subject code description": [
        "SIS_SUBJECT_CODE.SUBJECT_CODE_DESC"
      ]
    },
    "join_keys": [
      [
        "CIS_COURSE_CATALOG.SUBJECT_CODE",
        "SIS_SUBJECT_CODE.SUBJECT_CODE"
      ],
      [
        "SUBJECT_OFFERED_SUMMARY.SUBJECT_ID",
        "CIS_COURSE_CATALOG.SUBJECT_ID"
      ],
      [
        "SIS_DEPARTMENT.DEPARTMENT_CODE",
        "SIS_SUBJECT_CODE.DEPARTMENT_CODE"
      ]
    ],
    "sample_id": 65
  },
  {
    "question": "Group subjects by cluster type, department offering the subject, and the school name. For each group, list the cluster type, name of the department, school name, whether the department grants degrees, total number of subjects, total enrollment, and average enrollment. Exclude clusters or schools with no student data.",
    "db_id": "dw",
    "sql": "WITH ClusterSummary AS (SELECT sos.CLUSTER_TYPE, sos.OFFER_DEPT_NAME AS DEPARTMENT, sd.SCHOOL_NAME, COUNT(DISTINCT sos.SUBJECT_ID) AS num_subjects, SUM(sos.NUM_ENROLLED_STUDENTS) AS total_enrollment, AVG(sos.NUM_ENROLLED_STUDENTS) AS avg_enrollment, sd.IS_DEGREE_GRANTING AS degree_granting_status FROM SUBJECT_OFFERED_SUMMARY sos LEFT JOIN SIS_DEPARTMENT sd ON sos.OFFER_DEPT_CODE = sd.DEPARTMENT_CODE WHERE sos.CLUSTER_TYPE IS NOT NULL AND sos.NUM_ENROLLED_STUDENTS > 0 AND sd.SCHOOL_NAME IS NOT NULL GROUP BY sos.CLUSTER_TYPE, sos.OFFER_DEPT_NAME, sd.SCHOOL_NAME, sd.IS_DEGREE_GRANTING) SELECT CLUSTER_TYPE, DEPARTMENT, SCHOOL_NAME, degree_granting_status, num_subjects, total_enrollment, avg_enrollment FROM ClusterSummary ORDER BY CLUSTER_TYPE, DEPARTMENT, SCHOOL_NAME;",
    "gold_tables": [
      "dw#sep#SUBJECT_OFFERED_SUMMARY",
      "dw#sep#SIS_COURSE_DESCRIPTION",
      "dw#sep#SIS_DEPARTMENT"
    ],
    "mapping": {
      "cluster type": [
        "SUBJECT_OFFERED_SUMMARY.CLUSTER_TYPE"
      ],
      "name of the department": [
        "SUBJECT_OFFERED_SUMMARY.OFFER_DEPT_NAME"
      ],
      "school name": [
        "SIS_DEPARTMENT.SCHOOL_NAME"
      ],
      "whether the department grants degrees": [
        "SIS_DEPARTMENT.IS_DEGREE_GRANTING"
      ],
      "subjects": [
        "SUBJECT_OFFERED_SUMMARY.SUBJECT_ID"
      ],
      "enrollment": [
        "SUBJECT_OFFERED_SUMMARY.NUM_ENROLLED_STUDENTS"
      ]
    },
    "join_keys": [
      [
        "SUBJECT_OFFERED_SUMMARY.COURSE_NUMBER",
        "SIS_COURSE_DESCRIPTION.COURSE"
      ],
      [
        "SIS_DEPARTMENT.DEPARTMENT_CODE",
        "SUBJECT_OFFERED_SUMMARY.OFFER_DEPT_CODE"
      ]
    ],
    "sample_id": 66
  },
  {
    "question": "Group classes that take place in buildings at MIT by the building name and course level. For each group, provide the name of the building, the course level ('Graduate' or 'Undergraduate'), the total number of unique courses of such level, and total instructors for these courses. Include subtotals for each building and course level and a grand total across all buildings and course levels.",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN GROUPING(b.BUILDING_NAME) = 1 THEN NULL ELSE b.BUILDING_NAME END AS BUILDING_NAME, CASE WHEN GROUPING(scd.COURSE_LEVEL) = 1 THEN NULL WHEN scd.COURSE_LEVEL = 'G' THEN 'Graduate' WHEN scd.COURSE_LEVEL = 'U' THEN 'Undergraduate' ELSE 'Other' END AS course_level, COUNT(DISTINCT s.SUBJECT_ID) AS unique_courses, COUNT(DISTINCT s.RESPONSIBLE_FACULTY_NAME) AS total_instructors FROM FAC_BUILDING b JOIN SUBJECT_OFFERED s ON b.FAC_BUILDING_KEY = SUBSTRING_INDEX(s.MEET_PLACE, '-', 1) JOIN SIS_COURSE_DESCRIPTION scd ON s.COURSE_NUMBER = scd.COURSE WHERE b.SITE = 'MIT' GROUP BY b.BUILDING_NAME, scd.COURSE_LEVEL WITH ROLLUP ORDER BY GROUPING(b.BUILDING_NAME), b.BUILDING_NAME, GROUPING(scd.COURSE_LEVEL), course_level;",
    "gold_tables": [
      "dw#sep#FAC_BUILDING",
      "dw#sep#SUBJECT_OFFERED",
      "dw#sep#SIS_COURSE_DESCRIPTION",
      "dw#sep#FAC_BUILDING_ADDRESS"
    ],
    "mapping": {
      "buildings at MIT": [
        "FAC_BUILDING.SITE"
      ],
      "name of the building": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "course level": [
        "SIS_COURSE_DESCRIPTION.COURSE_LEVEL"
      ],
      "courses": [
        "SUBJECT_OFFERED_SUMMARY.SUBJECT_ID"
      ],
      "instructors": [
        "SUBJECT_OFFERED_SUMMARY.RESPONSIBLE_FACULTY_NAME"
      ]
    },
    "join_keys": [
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "SUBJECT_OFFERED.MEET_PLACE"
      ],
      [
        "SUBJECT_OFFERED.COURSE_NUMBER",
        "SIS_COURSE_DESCRIPTION.COURSE"
      ],
      [
        "FAC_BUILDING_ADDRESS.BUILDING_KEY",
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ]
    ],
    "sample_id": 67
  },
  {
    "question": "For each course, provide the room number of course location, building name, building number, building city, building state, area, organization name, room usage, term code, course level, the total number of subjects, unique meeting times, and total units. Do not include meet place or meet times with NULL values.",
    "db_id": "dw",
    "sql": "WITH DedupedBuildingAddress AS (SELECT BUILDING_KEY, CITY, STATE FROM FAC_BUILDING_ADDRESS WHERE ADDRESS_PURPOSE = 'STREET'), MeetingPlaceDetails AS (SELECT c.MEET_PLACE AS room_number, c.MEET_TIME, c.TERM_CODE, c.SUBJECT_ID, c.TOTAL_UNITS, b.BUILDING_NAME, b.BUILDING_NUMBER, ba.CITY AS building_city, ba.STATE AS building_state, fr.AREA, fr.ORGANIZATION_NAME, fmu.MAJOR_USE, scd.COURSE_LEVEL AS course_level FROM COURSE_CATALOG_SUBJECT_OFFERED c JOIN FAC_ROOMS fr ON c.MEET_PLACE = fr.FAC_ROOM_KEY JOIN FAC_BUILDING b ON fr.BUILDING_KEY = b.FAC_BUILDING_KEY JOIN FAC_MAJOR_USE fmu ON fr.MAJOR_USE_KEY = fmu.MAJOR_USE_KEY LEFT JOIN DedupedBuildingAddress ba ON b.FAC_BUILDING_KEY = ba.BUILDING_KEY LEFT JOIN SIS_COURSE_DESCRIPTION scd ON c.SUBJECT_ID = scd.COURSE WHERE c.MEET_PLACE IS NOT NULL AND c.MEET_TIME IS NOT NULL), MeetingPlaceAggregates AS (SELECT room_number, BUILDING_NAME, BUILDING_NUMBER, building_city, building_state, AREA, ORGANIZATION_NAME, MAJOR_USE, TERM_CODE, course_level, COUNT(DISTINCT SUBJECT_ID) AS num_subjects, COUNT(DISTINCT MEET_TIME) AS unique_meet_times, SUM(TOTAL_UNITS) AS total_units FROM MeetingPlaceDetails GROUP BY room_number, BUILDING_NAME, BUILDING_NUMBER, building_city, building_state, AREA, ORGANIZATION_NAME, MAJOR_USE, TERM_CODE, course_level) SELECT room_number, BUILDING_NAME, BUILDING_NUMBER, building_city, building_state, AREA, ORGANIZATION_NAME, MAJOR_USE, TERM_CODE, course_level, num_subjects, unique_meet_times, total_units FROM MeetingPlaceAggregates ORDER BY TERM_CODE, total_units DESC, room_number;",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_MAJOR_USE",
      "dw#sep#FAC_BUILDING_ADDRESS",
      "dw#sep#SIS_COURSE_DESCRIPTION"
    ],
    "mapping": {
      "room number": [
        "COURSE_CATALOG_SUBJECT_OFFERED.MEET_PLACE"
      ],
      "building name": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "building number": [
        "FAC_BUILDING.BUILDING_NUMBER"
      ],
      "building city": [
        "FAC_BUILDING_ADDRESS.CITY"
      ],
      "building state": [
        "FAC_BUILDING_ADDRESS.STATE"
      ],
      "area": [
        "FAC_ROOMS.AREA"
      ],
      "organization name": [
        "FAC_ROOMS.ORGANIZATION_NAME"
      ],
      "room usage": [
        "FAC_MAJOR_USE.MAJOR_USE"
      ],
      "term code": [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE"
      ],
      "course level": [
        "SIS_COURSE_DESCRIPTION.COURSE_LEVEL"
      ],
      "subjects": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "meeting times": [
        "COURSE_CATALOG_SUBJECT_OFFERED.MEET_TIME"
      ],
      "units": [
        "COURSE_CATALOG_SUBJECT_OFFERED.TOTAL_UNITS"
      ]
    },
    "join_keys": [
      [
        "FAC_ROOMS.FAC_ROOM_KEY",
        "COURSE_CATALOG_SUBJECT_OFFERED.MEET_PLACE"
      ],
      [
        "FAC_ROOMS.BUILDING_KEY",
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ],
      [
        "FAC_ROOMS.MAJOR_USE_KEY",
        "FAC_MAJOR_USE.MAJOR_USE_KEY"
      ],
      [
        "FAC_BUILDING_ADDRESS.BUILDING_KEY",
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ],
      [
        "SIS_COURSE_DESCRIPTION.COURSE",
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ]
    ],
    "sample_id": 68
  },
  {
    "question": "Consider only books cataloged on or after 2000. For each library material status and department, list the material status, department name, number of associated catalog items, and the total number of enrolled students in courses using those materials. Include subtotals for each material status and a grand total across all status (the corresponding status field is 'Grand Total').",
    "db_id": "dw",
    "sql": "WITH DistinctSubjectOffered AS (\n  SELECT DISTINCT\n    lms.LIBRARY_MATERIAL_STATUS, \n    sc.DEPARTMENT_NAME AS department,\n    lrd.LIBRARY_SUBJECT_OFFERED_KEY,\n    lso.NUM_ENROLLED_STUDENTS\n  FROM LIBRARY_RESERVE_MATRL_DETAIL lrd \n  JOIN LIBRARY_MATERIAL_STATUS lms ON lrd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY \n  JOIN LIBRARY_RESERVE_CATALOG lrc ON lrd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY \n  JOIN LIBRARY_SUBJECT_OFFERED lso ON lrd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY \n  LEFT JOIN SIS_SUBJECT_CODE sc ON lso.COURSE_NUMBER = sc.COURSE_NUMBER \n  WHERE lrc.CATALOG_YEAR >= 2000\n),\nMaterialUsage AS (\n  SELECT LIBRARY_MATERIAL_STATUS, department, \n         COUNT(*) AS num_catalog_items,\n         SUM(NUM_ENROLLED_STUDENTS) AS total_students\n  FROM DistinctSubjectOffered\n  GROUP BY LIBRARY_MATERIAL_STATUS, department\n),\nStatusSubtotals AS (\n  SELECT LIBRARY_MATERIAL_STATUS, NULL AS department, \n         SUM(num_catalog_items) AS num_catalog_items,\n         SUM(total_students) AS total_students\n  FROM MaterialUsage\n  GROUP BY LIBRARY_MATERIAL_STATUS\n),\nGrandTotal AS (\n  SELECT 'Grand Total' AS LIBRARY_MATERIAL_STATUS, NULL AS department, \n         SUM(num_catalog_items) AS num_catalog_items,\n         SUM(total_students) AS total_students\n  FROM MaterialUsage\n)\nSELECT * FROM MaterialUsage\nUNION ALL SELECT * FROM StatusSubtotals\nUNION ALL SELECT * FROM GrandTotal\nORDER BY LIBRARY_MATERIAL_STATUS, department;",
    "gold_tables": [
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_MATERIAL_STATUS",
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#LIBRARY_SUBJECT_OFFERED",
      "dw#sep#SIS_SUBJECT_CODE"
    ],
    "mapping": {
      "cataloged on or after 2000": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_YEAR"
      ],
      "material status": [
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS"
      ],
      "department name": [
        "SIS_SUBJECT_CODE.DEPARTMENT_NAME"
      ],
      "catalog items": [
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      "enrolled students": [
        "LIBRARY_SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_MATERIAL_STATUS_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_SUBJECT_OFFERED.COURSE_NUMBER",
        "SIS_SUBJECT_CODE.COURSE_NUMBER"
      ]
    ],
    "sample_id": 69
  },
  {
    "question": "For each department in the library system, list the name of the department, total number of courses using library materials, the number of catalog items associated with those courses, and the average enrollment per course. Include a grand total across all departments (the corresponding department field should be 'Grand Total').",
    "db_id": "dw",
    "sql": "WITH SubjectEnrollment AS ( SELECT lrd.LIBRARY_COURSE_INSTRUCTOR_KEY, lso.LIBRARY_SUBJECT_OFFERED_KEY, MAX(lso.NUM_ENROLLED_STUDENTS) AS enrollment FROM LIBRARY_RESERVE_MATRL_DETAIL lrd JOIN LIBRARY_SUBJECT_OFFERED lso ON lrd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY WHERE lso.NUM_ENROLLED_STUDENTS > 0 GROUP BY lrd.LIBRARY_COURSE_INSTRUCTOR_KEY, lso.LIBRARY_SUBJECT_OFFERED_KEY ), DepartmentLibraryUsage AS ( SELECT lci.DEPARTMENT, lci.COURSE_NAME, COUNT(DISTINCT lrc.LIBRARY_RESERVE_CATALOG_KEY) AS num_catalog_items, MAX(se.enrollment) AS total_students FROM SubjectEnrollment se JOIN LIBRARY_COURSE_INSTRUCTOR lci ON se.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY JOIN LIBRARY_RESERVE_MATRL_DETAIL lrd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrd.LIBRARY_COURSE_INSTRUCTOR_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY GROUP BY lci.DEPARTMENT, lci.COURSE_NAME ), DepartmentAggregates AS ( SELECT DEPARTMENT, COUNT(DISTINCT COURSE_NAME) AS total_courses, SUM(num_catalog_items) AS total_catalog_items, SUM(total_students) / COUNT(DISTINCT COURSE_NAME) AS avg_students_per_course FROM DepartmentLibraryUsage GROUP BY DEPARTMENT ), GrandTotal AS ( SELECT 'Grand Total' AS DEPARTMENT, SUM(total_courses) AS total_courses, SUM(total_catalog_items) AS total_catalog_items, SUM(total_courses * avg_students_per_course) / SUM(total_courses) AS avg_students_per_course FROM DepartmentAggregates ) SELECT * FROM (SELECT * FROM GrandTotal UNION ALL SELECT * FROM DepartmentAggregates) CombinedResults ORDER BY CASE WHEN DEPARTMENT = 'Grand Total' THEN 0 ELSE 1 END, DEPARTMENT;",
    "gold_tables": [
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_COURSE_INSTRUCTOR",
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#LIBRARY_SUBJECT_OFFERED"
    ],
    "mapping": {
      "name of the department": [
        "LIBRARY_COURSE_INSTRUCTOR.DEPARTMENT"
      ],
      "courses": [
        "LIBRARY_COURSE_INSTRUCTOR.COURSE_NAME"
      ],
      "catalog items": [
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      "enrollment": [
        "LIBRARY_SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ],
      [
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY"
      ]
    ],
    "sample_id": 70
  },
  {
    "question": "For each department and school offering courses with materials, list the department name, school name, number of unique course materials, number of courses, average new and used shelf prices of materials, total material records, and number of distinct material statuses. Include a grand total across all schools and departments (the corresponding school and department fields should be null).",
    "db_id": "dw",
    "sql": "WITH DedupedMaterial AS ( SELECT DISTINCT TIP_MATERIAL_KEY, TITLE, NEW_SHELF_PRICE, USED_SHELF_PRICE FROM TIP_MATERIAL ), MaterialCostDetails AS ( SELECT tso.OFFER_DEPT_NAME AS department_name, tso.SUBJECT_TITLE, tm.TITLE AS material_title, tm.NEW_SHELF_PRICE, tm.USED_SHELF_PRICE, tms.TIP_MATERIAL_STATUS AS material_status, tms.TIP_MATERIAL_STATUS_CODE AS material_status_code, td.RECORD_COUNT AS material_record_count, ts.SCHOOL_NAME AS school_name FROM TIP_DETAIL td JOIN DedupedMaterial tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY JOIN SIS_DEPARTMENT ts ON tso.OFFER_DEPT_CODE = ts.DEPARTMENT_CODE WHERE tso.IS_NO_COURSE_MATERIAL = 'N' ), MaterialCostAggregates AS ( SELECT department_name, school_name, COUNT(DISTINCT material_title) AS num_unique_materials, COUNT(DISTINCT SUBJECT_TITLE) AS num_courses, AVG(NEW_SHELF_PRICE) AS avg_new_price, AVG(USED_SHELF_PRICE) AS avg_used_price, SUM(material_record_count) AS total_material_records, COUNT(DISTINCT material_status) AS num_material_statuses FROM MaterialCostDetails GROUP BY department_name, school_name ), GrandTotal AS ( SELECT NULL AS department_name, NULL AS school_name, COUNT(DISTINCT material_title) AS num_unique_materials, COUNT(DISTINCT SUBJECT_TITLE) AS num_courses, AVG(NEW_SHELF_PRICE) AS avg_new_price, AVG(USED_SHELF_PRICE) AS avg_used_price, SUM(material_record_count) AS total_material_records, COUNT(DISTINCT material_status) AS num_material_statuses FROM MaterialCostDetails ) SELECT department_name, school_name, num_unique_materials, num_courses, avg_new_price, avg_used_price, total_material_records, num_material_statuses FROM MaterialCostAggregates UNION ALL SELECT department_name, school_name, num_unique_materials, num_courses, avg_new_price, avg_used_price, total_material_records, num_material_statuses FROM GrandTotal ORDER BY school_name, department_name;",
    "gold_tables": [
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_MATERIAL",
      "dw#sep#TIP_SUBJECT_OFFERED",
      "dw#sep#TIP_MATERIAL_STATUS",
      "dw#sep#SIS_DEPARTMENT"
    ],
    "mapping": {
      "courses with materials": [
        "TIP_SUBJECT_OFFERED.IS_NO_COURSE_MATERIAL"
      ],
      "department name": [
        "TIP_SUBJECT_OFFERED.OFFER_DEPT_NAME"
      ],
      "school name": [
        "SIS_DEPARTMENT.SCHOOL_NAME"
      ],
      "course materials": [
        "TIP_MATERIAL.TITLE"
      ],
      "courses": [
        "TIP_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "new": [
        "TIP_MATERIAL.NEW_SHELF_PRICE"
      ],
      "used": [
        "TIP_MATERIAL.USED_SHELF_PRICE"
      ],
      "material records": [
        "TIP_DETAIL.RECORD_COUNT"
      ],
      "material statuses": [
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS"
      ]
    },
    "join_keys": [
      [
        "TIP_MATERIAL.TIP_MATERIAL_KEY",
        "TIP_DETAIL.TIP_MATERIAL_KEY"
      ],
      [
        "TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY",
        "TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY"
      ],
      [
        "TIP_DETAIL.TIP_MATERIAL_STATUS_KEY",
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS_KEY"
      ],
      [
        "SIS_DEPARTMENT.DEPARTMENT_CODE",
        "TIP_SUBJECT_OFFERED.OFFER_DEPT_CODE"
      ]
    ],
    "sample_id": 71
  },
  {
    "question": "For each TIP material status, list the total number of unique materials associated with the status, the total number of records associated with the status, and the total student enrollment associated with the status. Any material status with null values should be displayed as 'No material status'. Additionally, include a grand total across all material status (the material status for this row should be displayed as 'Grand Total').",
    "db_id": "dw",
    "sql": "WITH RecordCounts AS (SELECT COALESCE(tms.TIP_MATERIAL_STATUS, 'No material status') AS material_status, SUM(td.RECORD_COUNT) AS total_record_count FROM TIP_DETAIL td JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY WHERE td.RECORD_COUNT > 0 GROUP BY COALESCE(tms.TIP_MATERIAL_STATUS, 'No material status')), MaterialCounts AS (SELECT COALESCE(tms.TIP_MATERIAL_STATUS, 'No material status') AS material_status, COUNT(DISTINCT tm.TITLE) AS num_materials FROM TIP_DETAIL td JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY WHERE td.RECORD_COUNT > 0 GROUP BY COALESCE(tms.TIP_MATERIAL_STATUS, 'No material status')), EnrollmentDedup AS (SELECT DISTINCT COALESCE(tms.TIP_MATERIAL_STATUS, 'No material status') AS material_status, tso.TIP_SUBJECT_OFFERED_KEY, tso.NUM_ENROLLED_STUDENTS FROM TIP_DETAIL td JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY WHERE td.RECORD_COUNT > 0), EnrollmentAgg AS (SELECT material_status, SUM(NUM_ENROLLED_STUDENTS) as total_enrollment FROM EnrollmentDedup GROUP BY material_status) SELECT rc.material_status, mc.num_materials, rc.total_record_count, ea.total_enrollment FROM RecordCounts rc JOIN MaterialCounts mc ON rc.material_status = mc.material_status JOIN EnrollmentAgg ea ON rc.material_status = ea.material_status UNION ALL SELECT 'Grand Total', (SELECT COUNT(DISTINCT tm.TITLE) FROM TIP_DETAIL td JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY WHERE td.RECORD_COUNT > 0), (SELECT SUM(td.RECORD_COUNT) FROM TIP_DETAIL td JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY WHERE td.RECORD_COUNT > 0), (SELECT SUM(NUM_ENROLLED_STUDENTS) FROM (SELECT DISTINCT tso.TIP_SUBJECT_OFFERED_KEY, tso.NUM_ENROLLED_STUDENTS FROM TIP_DETAIL td JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY WHERE td.RECORD_COUNT > 0) x) ORDER BY (material_status = 'Grand Total') ASC, total_record_count DESC;",
    "gold_tables": [
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_MATERIAL_STATUS",
      "dw#sep#TIP_MATERIAL",
      "dw#sep#TIP_SUBJECT_OFFERED"
    ],
    "mapping": {
      "TIP material status": [
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS"
      ],
      "materials": [
        "TIP_MATERIAL.TITLE"
      ],
      "records": [
        "TIP_DETAIL.RECORD_COUNT"
      ],
      "student enrollment": [
        "TIP_SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS"
      ]
    },
    "join_keys": [
      [
        "TIP_DETAIL.TIP_MATERIAL_STATUS_KEY",
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS_KEY"
      ],
      [
        "TIP_DETAIL.TIP_MATERIAL_KEY",
        "TIP_MATERIAL.TIP_MATERIAL_KEY"
      ],
      [
        "TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY",
        "TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY"
      ]
    ],
    "sample_id": 72
  },
  {
    "question": "For each room, list its associated building name, floor number, room number, ownership type, organization name, number of rooms, area, and percentage of area relative to the building. Include subtotals across floors, subtotals across all floors for each building, and a grand total across all buildings. For the subtotal for each building and the grand total, the percentage of area should be relative to area of all buildings. All numeric values should be rounded to integers and formatted using commas as thousands separators except the relative percentages which should be rounded to two decimal places.",
    "db_id": "dw",
    "sql": "WITH DedupOrg AS (\n  SELECT FCLT_ORGANIZATION_KEY, MAX(ORGANIZATION_NAME) AS ORGANIZATION_NAME\n  FROM FCLT_ORGANIZATION\n  GROUP BY FCLT_ORGANIZATION_KEY\n),\nbase_data AS (\n  SELECT b.BUILDING_NAME_LONG AS Building_Name, f.FLOOR AS Floor_Number, r.BUILDING_ROOM AS Room_Number, \n         b.OWNERSHIP_TYPE, o.ORGANIZATION_NAME AS Organization_Name, r.AREA,\n         SUM(r.AREA) OVER (PARTITION BY b.FCLT_BUILDING_KEY) AS Building_Total_Area\n  FROM FCLT_FLOOR f\n  LEFT JOIN FCLT_ROOMS r ON f.FCLT_FLOOR_KEY = r.FCLT_FLOOR_KEY\n  LEFT JOIN FCLT_BUILDING b ON f.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY\n  LEFT JOIN DedupOrg o ON r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY\n  WHERE b.BUILDING_NAME_LONG IS NOT NULL\n)\nSELECT Building_Name, Floor_Number, Room_Number, OWNERSHIP_TYPE, Organization_Name,\n       COUNT(*) AS Num_Rooms, SUM(AREA) AS Total_Area,\n       CASE WHEN Building_Total_Area > 0 THEN SUM(AREA) / Building_Total_Area * 100 ELSE 0 END AS Pct_Of_Building\nFROM base_data\nGROUP BY Building_Name, Floor_Number, Room_Number, OWNERSHIP_TYPE, Organization_Name, Building_Total_Area\nWITH ROLLUP\nHAVING Building_Name IS NOT NULL OR (Floor_Number IS NULL AND Room_Number IS NULL);",
    "gold_tables": [
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_FLOOR",
      "dw#sep#FCLT_BUILDING",
      "dw#sep#FCLT_ORGANIZATION"
    ],
    "mapping": {
      "room": [
        "FCLT_ROOMS.FCLT_ROOM_KEY"
      ],
      "building name": [
        "FCLT_BUILDING.BUILDING_NAME_LONG"
      ],
      "floor number": [
        "FCLT_FLOOR.FLOOR"
      ],
      "room number": [
        "FCLT_ROOMS.BUILDING_ROOM"
      ],
      "ownership type": [
        "FCLT_BUILDING.OWNERSHIP_TYPE"
      ],
      "organization name": [
        "FCLT_ORGANIZATION.ORGANIZATION_NAME"
      ],
      "number of rooms": [
        "FCLT_ROOMS.FCLT_ROOM_KEY"
      ],
      "area": [
        "FCLT_ROOMS.AREA"
      ]
    },
    "join_keys": [
      [
        "FCLT_FLOOR.FCLT_FLOOR_KEY",
        "FCLT_ROOMS.FCLT_FLOOR_KEY"
      ],
      [
        "FCLT_BUILDING.FCLT_BUILDING_KEY",
        "FCLT_FLOOR.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY",
        "FCLT_ROOMS.FCLT_ORGANIZATION_KEY"
      ]
    ],
    "sample_id": 73
  },
  {
    "question": "For each financial aid year and academic year, list the number of fiscal periods, quarters, the start term date, the end term date, and number of distinct department-level term parameters.",
    "db_id": "dw",
    "sql": "WITH FinancialAidDetails AS ( SELECT at.TERM_CODE, at.TERM_DESCRIPTION, at.ACADEMIC_YEAR, at.FINANCIAL_AID_YEAR, td.START_DATE AS Term_Start_Date, td.END_DATE AS Term_End_Date, tm.FISCAL_PERIOD, tm.FISCAL_YEAR, tq.FY_QUARTER_CODE, tp.TERM_PARAMETER AS Dept_Term_Param FROM ACADEMIC_TERMS at LEFT JOIN TIME_DAY td ON at.TERM_START_DATE = td.CALENDAR_DATE LEFT JOIN TIME_MONTH tm ON td.FISCAL_PERIOD = tm.FISCAL_PERIOD AND td.FISCAL_YEAR = tm.FISCAL_YEAR LEFT JOIN TIME_QUARTER tq ON tm.FISCAL_YEAR = tq.FISCAL_YEAR AND tm.FY_QUARTER_CODE = tq.FY_QUARTER_CODE LEFT JOIN ACADEMIC_TERM_PARAMETER tp ON at.TERM_CODE = tp.TERM_CODE WHERE at.FINANCIAL_AID_YEAR IS NOT NULL ) SELECT FINANCIAL_AID_YEAR, ACADEMIC_YEAR, COUNT(DISTINCT FISCAL_PERIOD) AS Total_Fiscal_Periods, COUNT(DISTINCT FY_QUARTER_CODE) AS Total_Quarters, MIN(Term_Start_Date) AS First_Term_Start_Date, MAX(Term_End_Date) AS Last_Term_End_Date, COUNT(DISTINCT Dept_Term_Param) AS Distinct_Term_Params FROM FinancialAidDetails GROUP BY FINANCIAL_AID_YEAR, ACADEMIC_YEAR ORDER BY FINANCIAL_AID_YEAR DESC, ACADEMIC_YEAR ASC;",
    "gold_tables": [
      "dw#sep#ACADEMIC_TERMS",
      "dw#sep#TIME_DAY",
      "dw#sep#TIME_MONTH",
      "dw#sep#TIME_QUARTER",
      "dw#sep#ACADEMIC_TERM_PARAMETER"
    ],
    "mapping": {
      "financial aid year": [
        "ACADEMIC_TERMS.FINANCIAL_AID_YEAR"
      ],
      "academic year": [
        "ACADEMIC_TERMS.ACADEMIC_YEAR"
      ],
      "fiscal periods": [
        "TIME_MONTH.FISCAL_PERIOD"
      ],
      "quarters": [
        "TIME_QUARTER.FY_QUARTER_CODE"
      ],
      "start term date": [
        "TIME_DAY.START_DATE"
      ],
      "end term date": [
        "TIME_DAY.END_DATE"
      ],
      "department-level term parameters": [
        "ACADEMIC_TERM_PARAMETER.TERM_PARAMETER"
      ]
    },
    "join_keys": [
      [
        "ACADEMIC_TERMS.TERM_START_DATE",
        "TIME_DAY.CALENDAR_DATE"
      ],
      [
        "TIME_DAY.FISCAL_PERIOD",
        "TIME_MONTH.FISCAL_PERIOD"
      ],
      [
        "TIME_QUARTER.FISCAL_YEAR",
        "TIME_MONTH.FISCAL_YEAR"
      ],
      [
        "ACADEMIC_TERM_PARAMETER.TERM_CODE",
        "ACADEMIC_TERMS.TERM_CODE"
      ]
    ],
    "sample_id": 74
  },
  {
    "question": "Group buildings by campus sectors. For each group, list the campus sector, name of the building, city and state where the building is located, total number of floors, total assignable area, total number of rooms, total number of organizations, ownership type, and a rank column indicating the order (1-indexed) of this row within each sector based on the descending order of assignable area. Include subtotals for each sector and a grand total across all sectors. The subtotal and grand total only need to computed over the total number of floors and assignable area.",
    "db_id": "dw",
    "sql": "WITH BuildingFloors AS ( SELECT FCLT_BUILDING_KEY, COUNT(DISTINCT FLOOR) AS Total_Floors FROM FCLT_FLOOR GROUP BY FCLT_BUILDING_KEY ), BuildingAddress AS ( SELECT FCLT_BUILDING_KEY, CITY, STATE FROM FCLT_BUILDING_ADDRESS WHERE ADDRESS_PURPOSE = 'STREET' ), TotalRooms AS ( SELECT b.FCLT_BUILDING_KEY, COUNT(DISTINCT r.FCLT_ROOM_KEY) AS Total_Rooms FROM FCLT_BUILDING b LEFT JOIN FCLT_ROOMS r ON b.FCLT_BUILDING_KEY = r.FCLT_BUILDING_KEY GROUP BY b.FCLT_BUILDING_KEY ), TotalOrganizations AS ( SELECT b.FCLT_BUILDING_KEY, COUNT(DISTINCT o.FCLT_ORGANIZATION_KEY) AS Total_Organizations FROM FCLT_BUILDING b LEFT JOIN FCLT_ROOMS r ON b.FCLT_BUILDING_KEY = r.FCLT_BUILDING_KEY LEFT JOIN FCLT_ORGANIZATION o ON r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY GROUP BY b.FCLT_BUILDING_KEY ), BuildingData AS ( SELECT b.CAMPUS_SECTOR, b.BUILDING_NAME_LONG AS Building_Name, ba.City AS Building_City, ba.State AS Building_State, COALESCE(bf.Total_Floors, 0) AS Total_Floors, b.ASSIGNABLE_AREA AS Assignable_Area, COALESCE(tr.Total_Rooms, 0) AS Total_Rooms, COALESCE(toz.Total_Organizations, 0) AS Total_Organizations, b.OWNERSHIP_TYPE AS Ownership_Type FROM FCLT_BUILDING b LEFT JOIN BuildingFloors bf ON b.FCLT_BUILDING_KEY = bf.FCLT_BUILDING_KEY LEFT JOIN BuildingAddress ba ON b.FCLT_BUILDING_KEY = ba.FCLT_BUILDING_KEY LEFT JOIN TotalRooms tr ON b.FCLT_BUILDING_KEY = tr.FCLT_BUILDING_KEY LEFT JOIN TotalOrganizations toz ON b.FCLT_BUILDING_KEY = toz.FCLT_BUILDING_KEY ), RankedBuildings AS ( SELECT CAMPUS_SECTOR, Building_Name, Building_City, Building_State, Total_Floors, Assignable_Area, Total_Rooms, Total_Organizations, Ownership_Type, RANK() OVER (PARTITION BY CAMPUS_SECTOR ORDER BY Assignable_Area DESC) AS Sector_Rank FROM BuildingData ), SectorSubtotals AS ( SELECT CAMPUS_SECTOR, CONCAT(CAMPUS_SECTOR, ' Subtotal') AS Building_Name, NULL AS Building_City, NULL AS Building_State, SUM(Total_Floors) AS Total_Floors, SUM(Assignable_Area) AS Assignable_Area, NULL AS Total_Rooms, NULL AS Total_Organizations, NULL AS Ownership_Type, 999999 AS Sector_Rank FROM BuildingData GROUP BY CAMPUS_SECTOR ), GrandTotal AS ( SELECT NULL AS CAMPUS_SECTOR, 'Grand Total' AS Building_Name, NULL AS Building_City, NULL AS Building_State, SUM(Total_Floors) AS Total_Floors, SUM(Assignable_Area) AS Assignable_Area, NULL AS Total_Rooms, NULL AS Total_Organizations, NULL AS Ownership_Type, 999999 AS Sector_Rank FROM BuildingData ) SELECT CAMPUS_SECTOR AS Campus_Sector, Building_Name, Building_City, Building_State, Total_Floors, FORMAT(Assignable_Area, 0) AS Assignable_Area, Total_Rooms, Total_Organizations, Ownership_Type, CASE WHEN Sector_Rank < 999999 THEN Sector_Rank ELSE NULL END AS Adjusted_Sector_Rank FROM ( SELECT * FROM RankedBuildings UNION ALL SELECT * FROM SectorSubtotals UNION ALL SELECT * FROM GrandTotal ) Combined ORDER BY COALESCE(CAMPUS_SECTOR, 'ZZZZ'), Sector_Rank, Building_Name;",
    "gold_tables": [
      "dw#sep#FCLT_BUILDING",
      "dw#sep#FCLT_FLOOR",
      "dw#sep#FCLT_BUILDING_ADDRESS",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_ORGANIZATION"
    ],
    "mapping": {
      "campus sector": [
        "FCLT_BUILDING.CAMPUS_SECTOR"
      ],
      "name of the building": [
        "FCLT_BUILDING.BUILDING_NAME_LONG"
      ],
      "city": [
        "FCLT_BUILDING_ADDRESS.CITY"
      ],
      "state": [
        "FCLT_BUILDING_ADDRESS.STATE"
      ],
      "floors": [
        "FCLT_FLOOR.FLOOR"
      ],
      "area": [
        "FCLT_BUILDING.ASSIGNABLE_AREA"
      ],
      "rooms": [
        "FCLT_ROOMS.FCLT_ROOM_KEY"
      ],
      "organizations": [
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY"
      ],
      "ownership type": [
        "FCLT_BUILDING.OWNERSHIP_TYPE"
      ]
    },
    "join_keys": [
      [
        "FCLT_BUILDING.FCLT_BUILDING_KEY",
        "FCLT_FLOOR.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_BUILDING.FCLT_BUILDING_KEY",
        "FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_BUILDING.FCLT_BUILDING_KEY",
        "FCLT_ROOMS.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_ROOMS.FCLT_BUILDING_KEY",
        "FCLT_BUILDING.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_ROOMS.FCLT_ORGANIZATION_KEY",
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY"
      ]
    ],
    "sample_id": 75
  },
  {
    "question": "For each department, list the name of the department, the title of the TIP material associated with the department, author, ISBN, library term code, and whether it is available in the library reserves ('Available in Library' if yes and 'Not Available in Library' otherwise), the total number of instructors per library book for the department, the total number of materials available in the library for the department, and the total number of available materials across all departments.",
    "db_id": "dw",
    "sql": "WITH TIPMaterials AS ( SELECT tm.TITLE AS TIP_Title, tm.AUTHOR AS TIP_Author, tm.ISBN AS TIP_ISBN, tso.OFFER_DEPT_NAME AS TIP_Department FROM TIP_MATERIAL tm JOIN TIP_DETAIL td ON tm.TIP_MATERIAL_KEY = td.TIP_MATERIAL_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY ), InstructorCounts AS ( SELECT lrc.CATALOG_ISBN AS ISBN, COUNT(DISTINCT lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY) AS Num_Instructors FROM LIBRARY_RESERVE_CATALOG lrc JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lrc.LIBRARY_RESERVE_CATALOG_KEY = lrmd.LIBRARY_RESERVE_CATALOG_KEY GROUP BY lrc.CATALOG_ISBN ), DepartmentMaterials AS ( SELECT tso.OFFER_DEPT_NAME AS Department, COUNT(DISTINCT tm.ISBN) AS Total_Available_Materials_Per_Dept FROM TIP_MATERIAL tm JOIN TIP_DETAIL td ON tm.TIP_MATERIAL_KEY = td.TIP_MATERIAL_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY WHERE tm.ISBN IN (SELECT CATALOG_ISBN FROM LIBRARY_RESERVE_CATALOG) GROUP BY tso.OFFER_DEPT_NAME ), OverallMaterials AS ( SELECT COUNT(DISTINCT tm.ISBN) AS Total_Available_Materials_All_Departments FROM TIP_MATERIAL tm JOIN TIP_DETAIL td ON tm.TIP_MATERIAL_KEY = td.TIP_MATERIAL_KEY WHERE tm.ISBN IN (SELECT CATALOG_ISBN FROM LIBRARY_RESERVE_CATALOG) ) SELECT DISTINCT tm.TIP_Department AS Department, tm.TIP_Title, tm.TIP_Author, tm.TIP_ISBN, lrmd.TERM_CODE AS Library_Term_Code, CASE WHEN lrc.CATALOG_ISBN IS NOT NULL THEN 'Available in Library' ELSE 'Not Available in Library' END AS Availability_Status, COALESCE(ic.Num_Instructors, 0) AS Num_Instructors, COALESCE(dm.Total_Available_Materials_Per_Dept, 0) AS Total_Available_Materials_Per_Dept, COALESCE(om.Total_Available_Materials_All_Departments, 0) AS Total_Available_Materials_All_Departments FROM TIPMaterials tm LEFT JOIN LIBRARY_RESERVE_CATALOG lrc ON tm.TIP_ISBN = lrc.CATALOG_ISBN LEFT JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lrc.LIBRARY_RESERVE_CATALOG_KEY = lrmd.LIBRARY_RESERVE_CATALOG_KEY LEFT JOIN InstructorCounts ic ON tm.TIP_ISBN = ic.ISBN LEFT JOIN DepartmentMaterials dm ON tm.TIP_Department = dm.Department LEFT JOIN OverallMaterials om ON 1=1 ORDER BY tm.TIP_Department, tm.TIP_Title;",
    "gold_tables": [
      "dw#sep#TIP_MATERIAL",
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_SUBJECT_OFFERED",
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_SUBJECT_OFFERED"
    ],
    "mapping": {
      "name of the department": [
        "TIP_SUBJECT_OFFERED.OFFER_DEPT_NAME"
      ],
      "title of the TIP material": [
        "TIP_MATERIAL.TITLE"
      ],
      "author": [
        "TIP_MATERIAL.AUTHOR"
      ],
      "ISBN": [
        "TIP_MATERIAL.ISBN"
      ],
      "library term code": [
        "LIBRARY_RESERVE_MATRL_DETAIL.TERM_CODE"
      ],
      "available in the library reserves": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_ISBN"
      ],
      "instructors": [
        "LIBRARY_COURSE_INSTRUCTOR.INSTRUCTOR_NAME"
      ]
    },
    "join_keys": [
      [
        "TIP_MATERIAL.TIP_MATERIAL_KEY",
        "TIP_DETAIL.TIP_MATERIAL_KEY"
      ],
      [
        "TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY",
        "TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY",
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ]
    ],
    "sample_id": 76
  },
  {
    "question": "For each department and material status, list the name of the department, the material status, the number of TIP materials associated with this department and status, the number of library materials associated with this department and status, the total number of TIP and library materials associated with this department and status. Include a subtotal for each department and a grand total across all departments.",
    "db_id": "dw",
    "sql": "WITH TIPMaterialStatuses AS ( SELECT tso.OFFER_DEPT_NAME AS Department, tms.TIP_MATERIAL_STATUS AS Status, COUNT(DISTINCT td.TIP_MATERIAL_KEY) AS Total_TIP_Materials FROM TIP_DETAIL td JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY GROUP BY tso.OFFER_DEPT_NAME, tms.TIP_MATERIAL_STATUS ), LibraryMaterialStatuses AS ( SELECT lso.OFFER_DEPT_NAME AS Department, lms.LIBRARY_MATERIAL_STATUS AS Status, COUNT(DISTINCT lrmd.LIBRARY_RESERVE_CATALOG_KEY) AS Total_Library_Materials FROM LIBRARY_RESERVE_MATRL_DETAIL lrmd JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY JOIN LIBRARY_MATERIAL_STATUS lms ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY GROUP BY lso.OFFER_DEPT_NAME, lms.LIBRARY_MATERIAL_STATUS ), CombinedStatuses AS ( SELECT Department, Status, Total_TIP_Materials, 0 AS Total_Library_Materials FROM TIPMaterialStatuses UNION ALL SELECT Department, Status, 0 AS Total_TIP_Materials, Total_Library_Materials FROM LibraryMaterialStatuses ) SELECT Department, Status, SUM(Total_TIP_Materials) AS Total_TIP_Materials, SUM(Total_Library_Materials) AS Total_Library_Materials, SUM(Total_TIP_Materials + Total_Library_Materials) AS Total_All_Materials FROM CombinedStatuses GROUP BY Department, Status WITH ROLLUP ORDER BY Department, Status;",
    "gold_tables": [
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_SUBJECT_OFFERED",
      "dw#sep#TIP_MATERIAL_STATUS",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_SUBJECT_OFFERED",
      "dw#sep#LIBRARY_MATERIAL_STATUS"
    ],
    "mapping": {
      "name of the department": [
        "TIP_SUBJECT_OFFERED.OFFER_DEPT_NAME"
      ],
      "material status": [
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS"
      ],
      "TIP materials": [
        "TIP_DETAIL.TIP_MATERIAL_KEY"
      ],
      "library materials": [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY"
      ]
    },
    "join_keys": [
      [
        "TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY",
        "TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY"
      ],
      [
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS_KEY",
        "TIP_DETAIL.TIP_MATERIAL_STATUS_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_MATERIAL_STATUS_KEY"
      ]
    ],
    "sample_id": 77
  },
  {
    "question": "For each building that is not a subdivision, list the building number, full name, street address, building type, occupancy date, ownership type, and site location. You should also include three rows at the end showing the number of owned, leased, all buildings at MIT that are not subdivisions, in the format of (null, #building Buildings, null, null, null, null, null).",
    "db_id": "dw",
    "sql": "SELECT * FROM (SELECT FAC_BUILDING.BUILDING_NUMBER AS BUILDING, FAC_BUILDING.BUILDING_NAME_LONG AS NAME, BUILDINGS.BUILDING_STREET_ADDRESS AS `STREET ADDRESS`, FAC_BUILDING.BUILDING_TYPE AS TYPE, FAC_BUILDING.DATE_OCCUPIED, FAC_BUILDING.OWNERSHIP_TYPE AS OWNERSHIP, FAC_BUILDING.SITE AS SITE FROM FAC_BUILDING_ADDRESS JOIN FAC_BUILDING ON FAC_BUILDING_ADDRESS.BUILDING_KEY = FAC_BUILDING.FAC_BUILDING_KEY JOIN BUILDINGS ON FAC_BUILDING_ADDRESS.BUILDING_KEY = BUILDINGS.BUILDING_KEY WHERE FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE = 'STREET' AND FAC_BUILDING.PARENT_BUILDING_NUMBER IS NULL) AS tbl1 UNION ALL SELECT NULL, CONCAT(COUNT(FAC_BUILDING.BUILDING_NUMBER), ' Buildings'), NULL, NULL, NULL, NULL, NULL FROM FAC_BUILDING_ADDRESS JOIN FAC_BUILDING ON FAC_BUILDING_ADDRESS.BUILDING_KEY = FAC_BUILDING.FAC_BUILDING_KEY WHERE FAC_BUILDING.OWNERSHIP_TYPE = 'OWNED' AND FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE = 'STREET' AND FAC_BUILDING.PARENT_BUILDING_NUMBER IS NULL AND FAC_BUILDING.SITE = 'MIT' UNION ALL SELECT NULL, CONCAT(COUNT(FAC_BUILDING.BUILDING_NUMBER), ' Buildings'), NULL, NULL, NULL, NULL, NULL FROM FAC_BUILDING_ADDRESS JOIN FAC_BUILDING ON FAC_BUILDING_ADDRESS.BUILDING_KEY = FAC_BUILDING.FAC_BUILDING_KEY WHERE FAC_BUILDING.OWNERSHIP_TYPE = 'LEASED' AND FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE = 'STREET' AND FAC_BUILDING.PARENT_BUILDING_NUMBER IS NULL AND FAC_BUILDING.SITE = 'MIT' UNION ALL SELECT NULL, CONCAT(COUNT(FAC_BUILDING.BUILDING_NUMBER), ' Buildings'), NULL, NULL, NULL, NULL, NULL FROM FAC_BUILDING_ADDRESS JOIN FAC_BUILDING ON FAC_BUILDING_ADDRESS.BUILDING_KEY = FAC_BUILDING.FAC_BUILDING_KEY WHERE FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE = 'STREET' AND FAC_BUILDING.PARENT_BUILDING_NUMBER IS NULL AND FAC_BUILDING.SITE = 'MIT';",
    "gold_tables": [
      "dw#sep#FAC_BUILDING_ADDRESS",
      "dw#sep#FAC_BUILDING",
      "dw#sep#BUILDINGS"
    ],
    "mapping": {
      "subdivision": [
        "FAC_BUILDING.PARENT_BUILDING_NUMBER"
      ],
      "building number": [
        "FAC_BUILDING.BUILDING_NUMBER"
      ],
      "full name": [
        "FAC_BUILDING.BUILDING_NAME_LONG"
      ],
      "street address": [
        "BUILDINGS.BUILDING_STREET_ADDRESS",
        "FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE"
      ],
      "building type": [
        "FAC_BUILDING.BUILDING_TYPE"
      ],
      "occupancy date": [
        "FAC_BUILDING.DATE_OCCUPIED"
      ],
      "ownership type": [
        "FAC_BUILDING.OWNERSHIP_TYPE"
      ],
      "site location": [
        "FAC_BUILDING.SITE"
      ]
    },
    "join_keys": [
      [
        "FAC_BUILDING_ADDRESS.BUILDING_KEY",
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ],
      [
        "BUILDINGS.BUILDING_KEY",
        "FAC_BUILDING_ADDRESS.BUILDING_KEY"
      ],
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_BUILDING_ADDRESS.BUILDING_KEY"
      ],
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_BUILDING_ADDRESS.BUILDING_KEY"
      ],
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_BUILDING_ADDRESS.BUILDING_KEY"
      ]
    ],
    "sample_id": 78
  },
  {
    "question": "For each owned building that is not a subdivision, list the construction start year, the building number, and the year of initial occupancy. Display the construction start year only if it differs from the previous row. If the year of initial occupancy or construction start year is unknown, display 'UNKNOWN'. You should also include a row at the end showing the total number of owned buildings that are not subdivisions, in the format of (null, #building Buildings, null).",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(year_construct_began) OVER (ORDER BY year_construct_began, building_sort, BUILDING_NUMBER) = year_construct_began THEN NULL WHEN BUILDING_NUMBER IS NULL THEN NULL ELSE year_construct_began END AS `YEAR CONSTRUCT BEGAN`, BUILDING_NUMBER AS BUILDING, year_occupied AS `YEAR INITIALLY OCCUPIED` FROM (SELECT year_construct_began, temp2.BUILDING_NUMBER, CASE WHEN FAC_BUILDING.BUILDING_NUMBER IS NOT NULL THEN IFNULL(DATE_FORMAT(STR_TO_DATE(FAC_BUILDING.DATE_OCCUPIED, '%m/%d/%Y'), '%Y'), 'UNKNOWN') ELSE NULL END AS year_occupied, CASE WHEN FAC_BUILDING.BUILDING_NUMBER IS NOT NULL THEN building_sort ELSE NULL END AS building_sort FROM (SELECT CASE WHEN BUILDING_NUMBER IS NOT NULL THEN year_construct_began ELSE CONCAT(year_construct_began, '*') END AS year_construct_began, BUILDING_NUMBER FROM (SELECT IFNULL(DATE_FORMAT(STR_TO_DATE(DATE_BUILT, '%m/%d/%Y'), '%Y'), 'UNKNOWN') AS year_construct_began, BUILDING_NUMBER FROM FAC_BUILDING WHERE ownership_type = 'OWNED' AND PARENT_BUILDING_NUMBER IS NULL) temp1 GROUP BY year_construct_began, BUILDING_NUMBER HAVING year_construct_began IS NOT NULL) temp2 LEFT JOIN FAC_BUILDING ON FAC_BUILDING.BUILDING_NUMBER = temp2.BUILDING_NUMBER) temp3 UNION ALL SELECT NULL, CONCAT(COUNT(FAC_BUILDING.BUILDING_NUMBER), ' Buildings'), NULL FROM FAC_BUILDING WHERE ownership_type = 'OWNED' AND PARENT_BUILDING_NUMBER IS NULL;",
    "gold_tables": [
      "dw#sep#FAC_BUILDING"
    ],
    "mapping": {
      "subdivision": [
        "FAC_BUILDING.PARENT_BUILDING_NUMBER"
      ],
      "construction start year": [
        "FAC_BUILDING.DATE_BUILT"
      ],
      "building number": [
        "FAC_BUILDING.PARENT_BUILDING_NUMBER"
      ],
      "year of initial occupancy": [
        "FAC_BUILDING.DATE_OCCUPIED"
      ]
    },
    "join_keys": [],
    "sample_id": 79
  },
  {
    "question": "Group all buildings at MIT into either owned or leased. For each group, state the ownership type, usage type, number of buildings, gross square footage, number of rooms, and the number of associated organizations. Display the ownership type only if it differs from the previous row. Include subtotals for each group and a grand total across all groups. The subtotal and grand total rows should not include ownership type and usage type. Footage should be rounded to integers and formatted using commas as thousands separators.",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(OWNERSHIP) OVER (ORDER BY ownership_sort, type_sort) = OWNERSHIP THEN NULL ELSE OWNERSHIP END AS OWNERSHIP, TYPE, BUILDINGS, GROSS_SQFT, ROOM_COUNT, ORG_COUNT FROM (SELECT CASE WHEN OWNERSHIP_TYPE = 'OWNED' THEN 1 WHEN OWNERSHIP_TYPE = 'LEASED' THEN 2 ELSE 3 END AS ownership_sort, COALESCE(BUILDING_USE, 'ZZZ') AS type_sort, CASE WHEN GROUPING(OWNERSHIP_TYPE) = 1 THEN NULL WHEN GROUPING(BUILDING_USE) = 1 THEN NULL ELSE OWNERSHIP_TYPE END AS OWNERSHIP, CASE WHEN GROUPING(OWNERSHIP_TYPE) = 1 THEN NULL WHEN GROUPING(BUILDING_USE) = 1 THEN NULL ELSE BUILDING_USE END AS TYPE, FORMAT(SUM(BUILDINGS), 0) AS BUILDINGS, FORMAT(ROUND(SUM(GROSS_SQFT)), 0) AS GROSS_SQFT, FORMAT(SUM(ROOM_COUNT), 0) AS ROOM_COUNT, FORMAT(SUM(ORG_COUNT), 0) AS ORG_COUNT FROM (SELECT bld.OWNERSHIP_TYPE, bld.BUILDING_USE, bld.BUILDINGS, bld.GROSS_SQFT, COALESCE(rm_counts.ROOM_COUNT, 0) AS ROOM_COUNT, COALESCE(rm_counts.ORG_COUNT, 0) AS ORG_COUNT FROM (SELECT OWNERSHIP_TYPE, BUILDING_USE, COUNT(DISTINCT COALESCE(PARENT_BUILDING_NUMBER, FCLT_BUILDING_KEY)) AS BUILDINGS, SUM(max_area) AS GROSS_SQFT FROM (SELECT FCLT_BUILDING_KEY, PARENT_BUILDING_NUMBER, OWNERSHIP_TYPE, BUILDING_USE, EXT_GROSS_AREA as max_area FROM (SELECT FCLT_BUILDING_KEY, PARENT_BUILDING_NUMBER, OWNERSHIP_TYPE, BUILDING_USE, EXT_GROSS_AREA, ROW_NUMBER() OVER (PARTITION BY FCLT_BUILDING_KEY ORDER BY CAST(FISCAL_PERIOD AS UNSIGNED) DESC) as rn FROM FCLT_BUILDING_HIST WHERE SITE = 'MIT') ranked WHERE rn = 1) deduped GROUP BY OWNERSHIP_TYPE, BUILDING_USE) bld LEFT JOIN (SELECT fh.OWNERSHIP_TYPE, fh.BUILDING_USE, COUNT(DISTINCT rm.FCLT_ROOM_KEY) AS ROOM_COUNT, COUNT(DISTINCT org.FCLT_ORGANIZATION_KEY) AS ORG_COUNT FROM FCLT_BUILDING_HIST fh LEFT JOIN FCLT_ROOMS rm ON fh.FCLT_BUILDING_KEY = rm.FCLT_BUILDING_KEY LEFT JOIN FCLT_ORGANIZATION org ON rm.FCLT_ORGANIZATION_KEY = org.FCLT_ORGANIZATION_KEY WHERE fh.SITE = 'MIT' GROUP BY fh.OWNERSHIP_TYPE, fh.BUILDING_USE) rm_counts ON bld.OWNERSHIP_TYPE = rm_counts.OWNERSHIP_TYPE AND bld.BUILDING_USE = rm_counts.BUILDING_USE) base GROUP BY OWNERSHIP_TYPE, BUILDING_USE WITH ROLLUP) t ORDER BY ownership_sort, type_sort;",
    "gold_tables": [
      "dw#sep#FCLT_BUILDING_HIST",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_ORGANIZATION"
    ],
    "mapping": {
      "buildings at MIT": [
        "FCLT_BUILDING_HIST.SITE"
      ],
      "ownership type": [
        "FCLT_BUILDING_HIST.OWNERSHIP_TYPE"
      ],
      "usage type": [
        "FCLT_BUILDING_HIST.BUILDING_USE"
      ],
      "buildings": [
        "FCLT_BUILDING_HIST.PARENT_BUILDING_NUMBER",
        "FCLT_BUILDING_HIST.FCLT_BUILDING_KEY"
      ],
      "gross square footage": [
        "FCLT_BUILDING_HIST.EXT_GROSS_AREA"
      ],
      "rooms": [
        "FCLT_ROOMS.FCLT_ROOM_KEY"
      ],
      "organizations": [
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY"
      ]
    },
    "join_keys": [
      [
        "FCLT_ROOMS.FCLT_BUILDING_KEY",
        "FCLT_BUILDING_HIST.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY",
        "FCLT_ROOMS.FCLT_ORGANIZATION_KEY"
      ]
    ],
    "sample_id": 80
  },
  {
    "question": "For each building use, list the type, the number of distinct buildings (excluding subdivisions) of this use, the total gross square footage of these buildings, and the number of unique organizations associated with the rooms in these buildings. If the building is used as a residence, display the usage type as \"RESIDENTIAL.\" You should also include a row at the end showing the total number of buildings, the gross square footage, and the number of organizations across all types of building use. All numerical values should be rounded to integers and formatted using commas as thousands separators.",
    "db_id": "dw",
    "sql": "SELECT * FROM ( SELECT CASE WHEN bld.BUILDING_USE = 'DHOA' THEN 'RESIDENTIAL' ELSE bld.BUILDING_USE END AS TYPE, bld.BUILDINGS, FORMAT(bld.GROSS_SQFT, 0) AS GROSS_SQFT, COALESCE(org_counts.NUM_ORGANIZATIONS, 0) AS NUM_ORGANIZATIONS FROM ( SELECT BUILDING_USE, COUNT(DISTINCT COALESCE(PARENT_BUILDING_NUMBER, FCLT_BUILDING_KEY)) AS BUILDINGS, SUM(EXT_GROSS_AREA) AS GROSS_SQFT FROM FCLT_BUILDING GROUP BY BUILDING_USE ) bld LEFT JOIN ( SELECT fb.BUILDING_USE, COUNT(DISTINCT org.FCLT_ORGANIZATION_KEY) AS NUM_ORGANIZATIONS FROM FCLT_BUILDING fb LEFT JOIN FCLT_ROOMS rm ON fb.FCLT_BUILDING_KEY = rm.FCLT_BUILDING_KEY LEFT JOIN FCLT_ORGANIZATION org ON rm.FCLT_ORGANIZATION_KEY = org.FCLT_ORGANIZATION_KEY GROUP BY fb.BUILDING_USE ) org_counts ON bld.BUILDING_USE <=> org_counts.BUILDING_USE UNION ALL SELECT 'TOTAL', SUM(bld.BUILDINGS), FORMAT(SUM(bld.GROSS_SQFT), 0), (SELECT COUNT(DISTINCT org.FCLT_ORGANIZATION_KEY) FROM FCLT_BUILDING fb LEFT JOIN FCLT_ROOMS rm ON fb.FCLT_BUILDING_KEY = rm.FCLT_BUILDING_KEY LEFT JOIN FCLT_ORGANIZATION org ON rm.FCLT_ORGANIZATION_KEY = org.FCLT_ORGANIZATION_KEY) FROM ( SELECT COUNT(DISTINCT COALESCE(PARENT_BUILDING_NUMBER, FCLT_BUILDING_KEY)) AS BUILDINGS, SUM(EXT_GROSS_AREA) AS GROSS_SQFT FROM FCLT_BUILDING ) bld ) final ORDER BY CASE WHEN TYPE = 'TOTAL' THEN 1 ELSE 0 END, TYPE;",
    "gold_tables": [
      "dw#sep#FCLT_BUILDING",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_ORGANIZATION"
    ],
    "mapping": {
      "building use": [
        "FCLT_BUILDING.BUILDING_USE"
      ],
      "buildings": [
        "FCLT_BUILDING.PARENT_BUILDING_NUMBER",
        "FCLT_BUILDING.FCLT_BUILDING_KEY"
      ],
      "gross square footage": [
        "FCLT_BUILDING.EXT_GROSS_AREA"
      ],
      "organizations": [
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY"
      ]
    },
    "join_keys": [
      [
        "FCLT_ROOMS.FCLT_BUILDING_KEY",
        "FCLT_BUILDING.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_ROOMS.FCLT_ORGANIZATION_KEY",
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY"
      ],
      [
        "FCLT_ROOMS.FCLT_BUILDING_KEY",
        "FCLT_BUILDING.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_ROOMS.FCLT_ORGANIZATION_KEY",
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY"
      ]
    ],
    "sample_id": 81
  },
  {
    "question": "For each organization except Cambridge-MIT Institute, list its ID, number, level, formatted name according to level (if level is 2, there should be 1 space before the name, if level is 3, there should be 2 space before the name, up to level 6), whether it is assignable ('ASSIGNABLE' if assignable, 'NON-ASSIGNABLE' otherwise), total area, number of rooms, and average room area. Area and number of rooms should be rounded to integers and formatted using commas as thousands separators.",
    "db_id": "dw",
    "sql": "SELECT o1.organization_id, organization_number, organization_level, \nCASE WHEN organization_level = '2' THEN CONCAT(' ', organization_name) \n     WHEN organization_level = '3' THEN CONCAT('  ', organization_name) \n     WHEN organization_level = '4' THEN CONCAT('   ', organization_name) \n     WHEN organization_level = '5' THEN CONCAT('    ', organization_name) \n     WHEN organization_level = '6' THEN CONCAT('     ', organization_name) \n     ELSE organization_name END AS formatted_name, \nCASE WHEN ASSIGNABLE = 1 THEN 'ASSIGNABLE' ELSE 'NON-ASSIGNABLE' END AS assignable_status, \n(SELECT FORMAT(COALESCE(SUM(area), 0), 0) FROM FCLT_ROOMS r WHERE r.FCLT_ORGANIZATION_KEY = o1.FCLT_ORGANIZATION_KEY) AS total_area, \n(SELECT FORMAT(COUNT(ROOM), 0) FROM FCLT_ROOMS r WHERE r.FCLT_ORGANIZATION_KEY = o1.FCLT_ORGANIZATION_KEY) AS room_count, \n(SELECT FORMAT(COALESCE(AVG(area), 0), 0) FROM FCLT_ROOMS r WHERE r.FCLT_ORGANIZATION_KEY = o1.FCLT_ORGANIZATION_KEY) AS avg_room_area \nFROM FCLT_ORGANIZATION o1 \nWHERE o1.organization_name <> 'CAMBRIDGE-MIT INST';",
    "gold_tables": [
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_ORGANIZATION",
      "dw#sep#MASTER_DEPT_HIERARCHY"
    ],
    "mapping": {
      "Cambridge-MIT Institute": [
        "FCLT_ORGANIZATION.ORGANIZATION_NAME"
      ],
      "ID": [
        "FCLT_ORGANIZATION.ORGANIZATION_ID"
      ],
      "number": [
        "FCLT_ORGANIZATION.ORGANIZATION_NUMBER"
      ],
      "level": [
        "FCLT_ORGANIZATION.ORGANIZATION_LEVEL"
      ],
      "name": [
        "FCLT_ORGANIZATION.ORGANIZATION_NAME"
      ],
      "assignable": [
        "FCLT_ORGANIZATION.ASSIGNABLE"
      ],
      "area": [
        "FCLT_ROOMS.AREA"
      ],
      "rooms": [
        "FCLT_ROOMS.ROOM"
      ],
      "room area": [
        "FCLT_ROOMS.AREA"
      ]
    },
    "join_keys": [
      [
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY",
        "FCLT_ROOMS.FCLT_ORGANIZATION_KEY"
      ],
      [
        "FCLT_ROOMS.FCLT_ORGANIZATION_KEY",
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY"
      ],
      [
        "FCLT_ROOMS.FCLT_ORGANIZATION_KEY",
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY"
      ],
      [
        "FCLT_ORGANIZATION.DLC_KEY",
        "MASTER_DEPT_HIERARCHY.DLC_KEY"
      ]
    ],
    "sample_id": 82
  },
  {
    "question": "Group all rooms into whether or not they are assignable and the major use descriptions. For each group, state \"ASSIGNABLE\" if the room is assignable and \"NON-ASSIGNABLE\" otherwise, the major use description, the total number of rooms, total area, and average area. Include subtotals for each group and a grand total across all groups. The assignable status and major use descriptions should only be displayed when they differ from the previous row. Do not include rooms whose major use or major use description starts with 'ZUSE.' The results should be sorted by assignable status and major use description. The subtotal and grand total rows should not include assignable status or major use description.",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(assign) OVER (ORDER BY assign) = assign THEN NULL ELSE assign END AS assign, CASE WHEN LAG(muse) OVER (ORDER BY assign, muse_sort) = muse THEN NULL ELSE muse END AS muse, rmcnt, area, area_avg FROM (SELECT CASE WHEN GROUPING(ASSIGNABLE) = 1 THEN NULL ELSE CASE WHEN ASSIGNABLE = 1 THEN 'ASSIGNABLE' ELSE 'NON-ASSIGNABLE' END END AS assign, CASE WHEN GROUPING(FCLT_ROOMS.MAJOR_USE_DESC) = 1 AND GROUPING(ASSIGNABLE) = 0 THEN NULL ELSE FCLT_ROOMS.MAJOR_USE_DESC END AS muse, CASE WHEN GROUPING(FCLT_ROOMS.MAJOR_USE_DESC) = 1 AND GROUPING(ASSIGNABLE) = 0 THEN 'zzz' ELSE FCLT_ROOMS.MAJOR_USE_DESC END AS muse_sort, COUNT(ROOM) AS rmcnt, SUM(FCLT_ROOMS.AREA) AS area, AVG(FCLT_ROOMS.AREA) AS area_avg FROM FCLT_ROOMS JOIN FCLT_MAJOR_USE ON FCLT_MAJOR_USE.FCLT_MAJOR_USE_KEY = FCLT_ROOMS.FCLT_MAJOR_USE_KEY WHERE FCLT_MAJOR_USE.MAJOR_USE NOT LIKE 'ZUSE%' AND FCLT_MAJOR_USE.DESCRIPTION NOT LIKE 'ZUSE%' GROUP BY ASSIGNABLE, FCLT_ROOMS.MAJOR_USE_DESC WITH ROLLUP ORDER BY assign, muse_sort) tbltmp;",
    "gold_tables": [
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_MAJOR_USE"
    ],
    "mapping": {
      "rooms": [
        "FCLT_ROOMS.ROOM"
      ],
      "assignable": [
        "FCLT_MAJOR_USE.ASSIGNABLE"
      ],
      "major use description": [
        "FCLT_MAJOR_USE.MAJOR_USE",
        "FCLT_ROOMS.MAJOR_USE_DESC",
        "FCLT_MAJOR_USE.DESCRIPTION"
      ],
      "area": [
        "FCLT_ROOMS.AREA"
      ]
    },
    "join_keys": [
      [
        "FCLT_ROOMS.FCLT_MAJOR_USE_KEY",
        "FCLT_MAJOR_USE.FCLT_MAJOR_USE_KEY"
      ]
    ],
    "sample_id": 83
  },
  {
    "question": "List each floor key and department name within the Stata building, as well as the number of rooms, total area, and average area per department on each floor. Include subtotals for each floor and a grand total across all floors. Sort the results by floor key and department name in ascending order. Exclude departments without any rooms in the building. Only the first row of each floor group should include the floor key, and the subtotal and grand total rows should not include floor key or department name. Number of rooms and area should be rounded to integers and formatted using commas as thousands separators.",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(FLOOR_KEY) OVER (ORDER BY COALESCE(FAC_FLOOR.FLOOR_SORT_SEQUENCE, 999), flsort, orgname) = FLOOR_KEY THEN NULL ELSE FLOOR_KEY END AS flid2, CASE WHEN orgname = 'zzz' THEN NULL ELSE orgname END AS dept, FORMAT(rmcnt, 0) AS rmcnt, FORMAT(ROUND(areasum), 0) AS areasum, FORMAT(ROUND(area_avg), 0) AS area_avg FROM (SELECT FLOOR_KEY AS flsort, CASE WHEN GROUPING(FLOOR_KEY) = 0 AND GROUPING(org.ORGANIZATION_NAME) = 1 THEN 'SUBTOTAL' WHEN GROUPING(FLOOR_KEY) = 1 AND GROUPING(org.ORGANIZATION_NAME) = 1 THEN 'TOTAL' ELSE FLOOR_KEY END AS flid, CASE WHEN GROUPING(FLOOR_KEY) = 0 AND GROUPING(org.ORGANIZATION_NAME) = 1 THEN 'zzz' ELSE org.ORGANIZATION_NAME END AS orgname, COUNT(DISTINCT rm.FAC_ROOM_KEY) AS rmcnt, SUM(CASE WHEN rn = 1 THEN rm.AREA ELSE 0 END) AS areasum, AVG(CASE WHEN rn = 1 THEN rm.AREA ELSE NULL END) AS area_avg FROM (SELECT rm.*, ROW_NUMBER() OVER (PARTITION BY rm.FAC_ROOM_KEY ORDER BY rm.FAC_ROOM_KEY) as rn FROM FAC_ROOMS rm) rm JOIN (SELECT DISTINCT FCLT_ORGANIZATION_KEY, ORGANIZATION_NAME FROM FCLT_ORGANIZATION) org ON rm.ORGANIZATION_KEY = org.FCLT_ORGANIZATION_KEY JOIN BUILDINGS bu ON rm.BUILDING_KEY = bu.BUILDING_KEY WHERE bu.BUILDING_NAME = 'Ray and Maria Stata Center' GROUP BY FLOOR_KEY, org.ORGANIZATION_NAME WITH ROLLUP ORDER BY flsort, orgname) tbltmp LEFT JOIN FAC_FLOOR ON FLOOR_KEY = flsort;",
    "gold_tables": [
      "dw#sep#FAC_ROOMS",
      "dw#sep#FCLT_ORGANIZATION",
      "dw#sep#BUILDINGS",
      "dw#sep#FAC_FLOOR"
    ],
    "mapping": {
      "floor key": [
        "FAC_FLOOR.FLOOR_KEY"
      ],
      "department name": [
        "FCLT_ORGANIZATION.ORGANIZATION_NAME"
      ],
      "Stata building": [
        "BUILDINGS.BUILDING_NAME"
      ],
      "rooms": [
        "FAC_ROOMS.FAC_ROOM_KEY"
      ],
      "area": [
        "FAC_ROOMS.AREA"
      ]
    },
    "join_keys": [
      [
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY",
        "FAC_ROOMS.ORGANIZATION_KEY"
      ],
      [
        "BUILDINGS.BUILDING_KEY",
        "FAC_ROOMS.BUILDING_KEY"
      ]
    ],
    "sample_id": 84
  },
  {
    "question": "List each building key and floor key within the department of facilities, the number of rooms, total area, average area per floor, building name, access level, zip code, and city. Include subtotals for each building and a grand total across all buildings. The subtotals and grand total should not include zip code or city. Numbers of rooms and area should be rounded to integers and formatted using commas as thousands separators.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT tbltmp.blsort AS building_id, tbltmp.flsort AS floor_id, FORMAT(tbltmp.rmcnt, 0) AS total_rooms, FORMAT(ROUND(tbltmp.areasum), 0) AS total_area, FORMAT(ROUND(tbltmp.area_avg), 0) AS avg_area, fb.BUILDING_NAME_LONG AS building_name, fb.ACCESS_LEVEL_NAME AS access_level, CASE WHEN tbltmp.flsort IS NULL THEN NULL ELSE fba.POSTAL_CODE END AS postal_code, CASE WHEN tbltmp.flsort IS NULL THEN NULL ELSE fba.CITY END AS city FROM (SELECT rm.BUILDING_KEY AS blsort, rm.FLOOR_KEY AS flsort, COUNT(rm.FAC_ROOM_KEY) AS rmcnt, SUM(rm.AREA) AS areasum, SUM(rm.AREA) / COUNT(DISTINCT rm.FLOOR_KEY) AS area_avg FROM FAC_ROOMS rm JOIN FAC_ORGANIZATION org ON rm.ORGANIZATION_KEY = org.ORGANIZATION_KEY WHERE org.ORGANIZATION_NAME = 'DP OF FACILITIES' GROUP BY rm.BUILDING_KEY, rm.FLOOR_KEY WITH ROLLUP) tbltmp LEFT JOIN FAC_BUILDING fb ON tbltmp.blsort = fb.FAC_BUILDING_KEY LEFT JOIN FAC_BUILDING_ADDRESS fba ON tbltmp.blsort = fba.BUILDING_KEY AND fba.ADDRESS_PURPOSE = 'STREET';",
    "gold_tables": [
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_ORGANIZATION",
      "dw#sep#FAC_FLOOR",
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_BUILDING_ADDRESS"
    ],
    "mapping": {
      "building key": [
        "FAC_ROOMS.BUILDING_KEY"
      ],
      "floor key": [
        "FAC_ROOMS.FLOOR_KEY"
      ],
      "department": [
        "FAC_ORGANIZATION.ORGANIZATION_NAME"
      ],
      "rooms": [
        "FAC_ROOMS.FAC_ROOM_KEY"
      ],
      "area": [
        "FAC_ROOMS.AREA"
      ],
      "building name": [
        "FAC_BUILDING.BUILDING_NAME_LONG"
      ],
      "access level": [
        "FAC_BUILDING.ACCESS_LEVEL_NAME"
      ],
      "zip code": [
        "FAC_BUILDING_ADDRESS.POSTAL_CODE"
      ],
      "city": [
        "FAC_BUILDING_ADDRESS.CITY"
      ]
    },
    "join_keys": [
      [
        "FAC_ORGANIZATION.ORGANIZATION_KEY",
        "FAC_ROOMS.ORGANIZATION_KEY"
      ]
    ],
    "sample_id": 85
  },
  {
    "question": "List the department, school, course number, subject title, total number of enrolled students, term code, and count of distinct catalog ISBNs. Add a summary row at the bottom showing the total number of students and distinct catalog ISBNs for the current term in the format of ('TOTAL:', null, null, null, total number of students, null, number of distinct catalog ISBNs).",
    "db_id": "dw",
    "sql": "WITH EnrollmentAgg AS (\n    SELECT OFFER_DEPT_NAME AS DEPT, OFFER_SCHOOL_NAME AS SCHOOL, \n           COURSE_NUMBER AS COURSE_NR, SUBJECT_TITLE AS TITLE, \n           TERM_CODE, SUM(NUM_ENROLLED_STUDENTS) AS TOTAL_ENROLLED \n    FROM LIBRARY_SUBJECT_OFFERED \n    GROUP BY OFFER_DEPT_NAME, OFFER_SCHOOL_NAME, COURSE_NUMBER, SUBJECT_TITLE, TERM_CODE\n), \nISBNAgg AS (\n    SELECT lso.OFFER_DEPT_NAME AS DEPT, lso.OFFER_SCHOOL_NAME AS SCHOOL, \n           lso.COURSE_NUMBER AS COURSE_NR, lso.SUBJECT_TITLE AS TITLE, \n           lso.TERM_CODE, COUNT(DISTINCT lrc.CATALOG_ISBN) AS ISBN_COUNT \n    FROM LIBRARY_SUBJECT_OFFERED lso \n    LEFT JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY \n    LEFT JOIN LIBRARY_RESERVE_CATALOG lrc ON lrc.LIBRARY_RESERVE_CATALOG_KEY = lrmd.LIBRARY_RESERVE_CATALOG_KEY \n    GROUP BY lso.OFFER_DEPT_NAME, lso.OFFER_SCHOOL_NAME, lso.COURSE_NUMBER, lso.SUBJECT_TITLE, lso.TERM_CODE\n)\nSELECT * FROM (\n    SELECT e.DEPT, e.SCHOOL, e.COURSE_NR, e.TITLE, e.TOTAL_ENROLLED, e.TERM_CODE, \n           COALESCE(i.ISBN_COUNT, 0) AS ISBN_COUNT \n    FROM EnrollmentAgg e \n    LEFT JOIN ISBNAgg i ON e.DEPT = i.DEPT AND e.SCHOOL = i.SCHOOL \n                       AND e.COURSE_NR = i.COURSE_NR AND e.TITLE = i.TITLE \n                       AND e.TERM_CODE = i.TERM_CODE\n    UNION ALL\n    SELECT 'TOTAL:', NULL, NULL, NULL, \n           (SELECT SUM(NUM_ENROLLED_STUDENTS) FROM LIBRARY_SUBJECT_OFFERED lso\n            JOIN ACADEMIC_TERM_PARAMETER atp ON lso.TERM_CODE = atp.TERM_CODE \n            WHERE atp.IS_CURRENT_TERM = 'Y'), \n           NULL,\n           (SELECT COUNT(DISTINCT lrc.CATALOG_ISBN) \n            FROM LIBRARY_SUBJECT_OFFERED lso \n            LEFT JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY \n            LEFT JOIN LIBRARY_RESERVE_CATALOG lrc ON lrc.LIBRARY_RESERVE_CATALOG_KEY = lrmd.LIBRARY_RESERVE_CATALOG_KEY \n            JOIN ACADEMIC_TERM_PARAMETER atp ON lso.TERM_CODE = atp.TERM_CODE \n            WHERE atp.IS_CURRENT_TERM = 'Y')\n) combined \nORDER BY (DEPT = 'TOTAL:') ASC, DEPT, COURSE_NR, TITLE, TERM_CODE;",
    "gold_tables": [
      "dw#sep#LIBRARY_SUBJECT_OFFERED",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#ACADEMIC_TERM_PARAMETER"
    ],
    "mapping": {
      "department": [
        "LIBRARY_SUBJECT_OFFERED.OFFER_DEPT_NAME"
      ],
      "school": [
        "LIBRARY_SUBJECT_OFFERED.OFFER_SCHOOL_NAME"
      ],
      "course number": [
        "LIBRARY_SUBJECT_OFFERED.COURSE_NUMBER"
      ],
      "subject title": [
        "LIBRARY_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "enrolled students": [
        "LIBRARY_SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS"
      ],
      "term code": [
        "LIBRARY_SUBJECT_OFFERED.TERM_CODE"
      ],
      "catalog ISBNs": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_ISBN"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "ACADEMIC_TERM_PARAMETER.TERM_CODE",
        "LIBRARY_SUBJECT_OFFERED.TERM_CODE"
      ]
    ],
    "sample_id": 86
  },
  {
    "question": "For each mailing list that involves subscribers that work in departments with names starting with 'Computer Science', state the ownership type, the list name, the number of owners, and the number of subscribers. Display the ownership type only if it differs from the previous entry. Include subtotals (the corresponding type field shoud be 'SUBTOTAL') for each ownership type and a grand total (the corresponding type field shoud be 'TOTAL') across all ownership types.",
    "db_id": "dw",
    "sql": "WITH QualifyingLists AS (SELECT DISTINCT ml.MOIRA_LIST_KEY FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN EMPLOYEE_DIRECTORY ed ON ed.MIT_ID = mld.MOIRA_LIST_MEMBER_MIT_ID WHERE ed.DEPARTMENT_NAME LIKE 'Computer Science%') SELECT CASE WHEN LAG(OWNERSHIP_TYPE) OVER (ORDER BY OWNERSHIP_TYPE_gr DESC, ML_sort, ML) = OWNERSHIP_TYPE THEN NULL ELSE OWNERSHIP_TYPE END AS OWNERSHIP_TYPE, ML, nr_owner, nr_member FROM (SELECT CASE WHEN OWNER_TYPE IS NULL AND MOIRA_LIST_NAME IS NOT NULL THEN CONCAT(OWNER_TYPE, '1') ELSE CONCAT(OWNER_TYPE, '2') END AS OWNERSHIP_TYPE_gr, CASE WHEN MOIRA_LIST_NAME IS NULL AND OWNER_TYPE IS NOT NULL THEN 'SUBTOTAL' WHEN MOIRA_LIST_NAME IS NULL AND OWNER_TYPE IS NULL THEN 'TOTAL' ELSE OWNER_TYPE END AS OWNERSHIP_TYPE, MOIRA_LIST_NAME AS ML, CASE WHEN MOIRA_LIST_NAME IS NULL THEN 1 ELSE 0 END AS ML_sort, COUNT(DISTINCT OWNER) AS nr_owner, COUNT(DISTINCT mld.MOIRA_LIST_MEMBER_MIT_ID) AS nr_member FROM QualifyingLists ql JOIN MOIRA_LIST ml ON ml.MOIRA_LIST_KEY = ql.MOIRA_LIST_KEY JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY GROUP BY OWNER_TYPE, MOIRA_LIST_NAME WITH ROLLUP) tbltmp ORDER BY OWNERSHIP_TYPE_gr DESC, ML_sort, ML;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST_OWNER",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MOIRA_LIST",
      "dw#sep#EMPLOYEE_DIRECTORY"
    ],
    "mapping": {
      "departments with names starting with 'Computer Science'": [
        "EMPLOYEE_DIRECTORY.DEPARTMENT_NAME"
      ],
      "ownership type": [
        "MOIRA_LIST_OWNER.OWNER_TYPE"
      ],
      "list name": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "owners": [
        "MOIRA_LIST_OWNER.OWNER"
      ],
      "subscribers": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER_MIT_ID"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_OWNER_KEY",
        "MOIRA_LIST_OWNER.MOIRA_LIST_OWNER_KEY"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ],
      [
        "EMPLOYEE_DIRECTORY.MIT_ID",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER_MIT_ID"
      ]
    ],
    "sample_id": 87
  },
  {
    "question": "For each IAP category, list its name, number of unique sessions, total number of attendees, active period (in the format of 'beginning term code-end term code'), the most common sponsor name, and the most common session start time. Include a grand total row showing the total number of sessions and attendees across all categories in the format of ('TOTAL', number of sessions, number of attendees, null, null, null).",
    "db_id": "dw",
    "sql": "WITH DedupEnroll AS (SELECT IAP_SUBJECT_SESSION_KEY, IAP_SUBJECT_CATEGORY_KEY, MAX(MAX_ENROLLMENT) as enrollment, MIN(TERM_CODE) as min_term, MAX(TERM_CODE) as max_term FROM IAP_SUBJECT_DETAIL GROUP BY IAP_SUBJECT_SESSION_KEY, IAP_SUBJECT_CATEGORY_KEY), SponsorCounts AS (SELECT c.IAP_CATEGORY_NAME, sp.SPONSOR_NAME, COUNT(DISTINCT d.IAP_SUBJECT_SESSION_KEY) AS cnt FROM IAP_SUBJECT_DETAIL d JOIN IAP_SUBJECT_CATEGORY c ON c.IAP_SUBJECT_CATEGORY_KEY = d.IAP_SUBJECT_CATEGORY_KEY JOIN IAP_SUBJECT_SPONSOR sp ON sp.IAP_SUBJECT_SPONSOR_KEY = d.IAP_SUBJECT_SPONSOR_KEY GROUP BY c.IAP_CATEGORY_NAME, sp.SPONSOR_NAME), TopSponsor AS (SELECT IAP_CATEGORY_NAME, SPONSOR_NAME FROM (SELECT *, ROW_NUMBER() OVER (PARTITION BY IAP_CATEGORY_NAME ORDER BY cnt DESC, SPONSOR_NAME) AS rn FROM SponsorCounts) x WHERE rn=1), StartCounts AS (SELECT c.IAP_CATEGORY_NAME, iss.SESSION_START_TIME, COUNT(DISTINCT d.IAP_SUBJECT_SESSION_KEY) AS cnt FROM IAP_SUBJECT_DETAIL d JOIN IAP_SUBJECT_CATEGORY c ON c.IAP_SUBJECT_CATEGORY_KEY = d.IAP_SUBJECT_CATEGORY_KEY JOIN IAP_SUBJECT_SESSION iss ON iss.IAP_SUBJECT_SESSION_KEY = d.IAP_SUBJECT_SESSION_KEY WHERE iss.SESSION_START_TIME IS NOT NULL GROUP BY c.IAP_CATEGORY_NAME, iss.SESSION_START_TIME), TopStart AS (SELECT IAP_CATEGORY_NAME, SESSION_START_TIME FROM (SELECT *, ROW_NUMBER() OVER (PARTITION BY IAP_CATEGORY_NAME ORDER BY cnt DESC, SESSION_START_TIME) AS rn FROM StartCounts) x WHERE rn=1), CategorySummary AS (SELECT isc.IAP_CATEGORY_NAME AS TYPE, COUNT(DISTINCT de.IAP_SUBJECT_SESSION_KEY) AS nr_sessions, FORMAT(SUM(de.enrollment), 0) AS total_attend, MIN(de.min_term) AS first_active_year, MAX(de.max_term) AS last_active_year, ts.SPONSOR_NAME AS most_common_sponsor, tst.SESSION_START_TIME AS most_common_start_time FROM IAP_SUBJECT_CATEGORY isc JOIN DedupEnroll de ON de.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY LEFT JOIN TopSponsor ts ON isc.IAP_CATEGORY_NAME = ts.IAP_CATEGORY_NAME LEFT JOIN TopStart tst ON isc.IAP_CATEGORY_NAME = tst.IAP_CATEGORY_NAME GROUP BY isc.IAP_CATEGORY_NAME, ts.SPONSOR_NAME, tst.SESSION_START_TIME) SELECT TYPE, nr_sessions, total_attend, CONCAT(first_active_year, '-', last_active_year) AS active_years, most_common_sponsor, most_common_start_time FROM CategorySummary UNION ALL SELECT 'TOTAL', COUNT(*), FORMAT(SUM(enrollment), 0), NULL, NULL, NULL FROM (SELECT IAP_SUBJECT_SESSION_KEY, MAX(MAX_ENROLLMENT) as enrollment FROM IAP_SUBJECT_DETAIL GROUP BY IAP_SUBJECT_SESSION_KEY) t ORDER BY TYPE;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_CATEGORY",
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#IAP_SUBJECT_SESSION",
      "dw#sep#IAP_SUBJECT_SPONSOR"
    ],
    "mapping": {
      "name": [
        "IAP_SUBJECT_CATEGORY.IAP_CATEGORY_NAME"
      ],
      "sessions": [
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY"
      ],
      "attendees": [
        "IAP_SUBJECT_DETAIL.MAX_ENROLLMENT"
      ],
      "active period": [
        "IAP_SUBJECT_DETAIL.TERM_CODE"
      ],
      "sponsor name": [
        "IAP_SUBJECT_SPONSOR.SPONSOR_NAME"
      ],
      "session start time": [
        "IAP_SUBJECT_SESSION.SESSION_START_TIME"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_CATEGORY_KEY",
        "IAP_SUBJECT_CATEGORY.IAP_SUBJECT_CATEGORY_KEY"
      ],
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY",
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY"
      ],
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SPONSOR_KEY",
        "IAP_SUBJECT_SPONSOR.IAP_SUBJECT_SPONSOR_KEY"
      ],
      [
        "IAP_SUBJECT_CATEGORY.IAP_SUBJECT_CATEGORY_KEY",
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_CATEGORY_KEY"
      ]
    ],
    "sample_id": 88
  },
  {
    "question": "For each building type, list the name of the building type, the number of buildings that are not subdivisions, number of employees, number of unique building street address, number of unique city, number of unique state, number of unique postal code, and average gross square footage per employee. For building type of 'resident', display it as 'RESIDENTIAL'. Include a grand total across all building types (the corresponding type field is 'TOTAL').",
    "db_id": "dw",
    "sql": "WITH LatestHist AS (SELECT t.FCLT_BUILDING_KEY, t.PARENT_BUILDING_NUMBER, t.BUILDING_TYPE, t.EXT_GROSS_AREA FROM (SELECT fbh.FCLT_BUILDING_KEY, fbh.PARENT_BUILDING_NUMBER, fbh.BUILDING_TYPE, fbh.EXT_GROSS_AREA, ROW_NUMBER() OVER (PARTITION BY fbh.FCLT_BUILDING_KEY ORDER BY CAST(fbh.FISCAL_PERIOD AS UNSIGNED) DESC) AS rn FROM FCLT_BUILDING_HIST fbh) t WHERE t.rn = 1), BuildingBase AS (SELECT CASE WHEN LOWER(lh.BUILDING_TYPE) = 'resident' THEN 'RESIDENTIAL' ELSE lh.BUILDING_TYPE END AS building_type, COALESCE(lh.PARENT_BUILDING_NUMBER, lh.FCLT_BUILDING_KEY) AS root_building_key, lh.FCLT_BUILDING_KEY AS building_key, lh.EXT_GROSS_AREA AS gross_sqft FROM LatestHist lh WHERE lh.BUILDING_TYPE IS NOT NULL), BuildingAgg AS (SELECT bb.building_type, COUNT(DISTINCT bb.root_building_key) AS non_subdivision_count, SUM(bb.gross_sqft) AS total_gross_sqft FROM BuildingBase bb GROUP BY bb.building_type), EmployeeAgg AS (SELECT CASE WHEN LOWER(lh.BUILDING_TYPE) = 'resident' THEN 'RESIDENTIAL' ELSE lh.BUILDING_TYPE END AS building_type, COUNT(DISTINCT e.MIT_ID) AS employee_count FROM EMPLOYEE_DIRECTORY e JOIN FAC_ROOMS r ON r.FAC_ROOM_KEY = e.OFFICE_LOCATION JOIN LatestHist lh ON lh.FCLT_BUILDING_KEY = r.BUILDING_KEY WHERE lh.BUILDING_TYPE IS NOT NULL GROUP BY CASE WHEN LOWER(lh.BUILDING_TYPE) = 'resident' THEN 'RESIDENTIAL' ELSE lh.BUILDING_TYPE END), AddressAgg AS (SELECT CASE WHEN LOWER(lh.BUILDING_TYPE) = 'resident' THEN 'RESIDENTIAL' ELSE lh.BUILDING_TYPE END AS building_type, COUNT(DISTINCT b.BUILDING_STREET_ADDRESS) AS unique_street_address_count, COUNT(DISTINCT fba.CITY) AS unique_city_count, COUNT(DISTINCT fba.STATE) AS unique_state_count, COUNT(DISTINCT fba.POSTAL_CODE) AS unique_postal_code_count FROM LatestHist lh LEFT JOIN BUILDINGS b ON b.BUILDING_KEY = lh.FCLT_BUILDING_KEY LEFT JOIN FAC_BUILDING_ADDRESS fba ON fba.BUILDING_KEY = lh.FCLT_BUILDING_KEY AND fba.ADDRESS_PURPOSE = 'STREET' WHERE lh.BUILDING_TYPE IS NOT NULL GROUP BY CASE WHEN LOWER(lh.BUILDING_TYPE) = 'resident' THEN 'RESIDENTIAL' ELSE lh.BUILDING_TYPE END), TotalsBuilding AS (SELECT COUNT(DISTINCT root_building_key) AS non_subdivision_count, SUM(gross_sqft) AS total_gross_sqft FROM BuildingBase), TotalsEmployee AS (SELECT COUNT(DISTINCT e.MIT_ID) AS employee_count FROM EMPLOYEE_DIRECTORY e JOIN FAC_ROOMS r ON r.FAC_ROOM_KEY = e.OFFICE_LOCATION JOIN LatestHist lh ON lh.FCLT_BUILDING_KEY = r.BUILDING_KEY WHERE lh.BUILDING_TYPE IS NOT NULL), TotalsAddress AS (SELECT COUNT(DISTINCT b.BUILDING_STREET_ADDRESS) AS unique_street_address_count, COUNT(DISTINCT fba.CITY) AS unique_city_count, COUNT(DISTINCT fba.STATE) AS unique_state_count, COUNT(DISTINCT fba.POSTAL_CODE) AS unique_postal_code_count FROM LatestHist lh LEFT JOIN BUILDINGS b ON b.BUILDING_KEY = lh.FCLT_BUILDING_KEY LEFT JOIN FAC_BUILDING_ADDRESS fba ON fba.BUILDING_KEY = lh.FCLT_BUILDING_KEY AND fba.ADDRESS_PURPOSE = 'STREET' WHERE lh.BUILDING_TYPE IS NOT NULL) SELECT ba.building_type AS TYPE, ba.non_subdivision_count AS BUILDINGS, COALESCE(ea.employee_count, 0) AS MIT_ID_COUNT, COALESCE(aa.unique_street_address_count, 0) AS ADDRESS_COUNT, COALESCE(aa.unique_city_count, 0) AS CITY_COUNT, COALESCE(aa.unique_state_count, 0) AS STATE_COUNT, COALESCE(aa.unique_postal_code_count, 0) AS POSTAL_CODE_COUNT, ba.total_gross_sqft / NULLIF(ea.employee_count, 0) AS AVG_AREA FROM BuildingAgg ba LEFT JOIN EmployeeAgg ea ON ea.building_type <=> ba.building_type LEFT JOIN AddressAgg aa ON aa.building_type <=> ba.building_type UNION ALL SELECT 'TOTAL', tb.non_subdivision_count, te.employee_count, ta.unique_street_address_count, ta.unique_city_count, ta.unique_state_count, ta.unique_postal_code_count, tb.total_gross_sqft / NULLIF(te.employee_count, 0) FROM TotalsBuilding tb CROSS JOIN TotalsEmployee te CROSS JOIN TotalsAddress ta ORDER BY CASE WHEN TYPE = 'TOTAL' THEN 1 ELSE 0 END, TYPE;",
    "gold_tables": [
      "dw#sep#FCLT_BUILDING_HIST",
      "dw#sep#FAC_BUILDING_ADDRESS",
      "dw#sep#BUILDINGS",
      "dw#sep#FAC_ROOMS",
      "dw#sep#EMPLOYEE_DIRECTORY"
    ],
    "mapping": {
      "name of the building type": [
        "FCLT_BUILDING_HIST.BUILDING_TYPE"
      ],
      "buildings that are not subdivisions": [
        "FCLT_BUILDING_HIST.FCLT_BUILDING_KEY",
        "FCLT_BUILDING_HIST.PARENT_BUILDING_NUMBER"
      ],
      "employees": [
        "EMPLOYEE_DIRECTORY.MIT_ID"
      ],
      "street address": [
        "BUILDINGS.BUILDING_STREET_ADDRESS",
        "FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE"
      ],
      "city": [
        "FAC_BUILDING_ADDRESS.CITY"
      ],
      "state": [
        "FAC_BUILDING_ADDRESS.STATE"
      ],
      "postal code": [
        "FAC_BUILDING_ADDRESS.POSTAL_CODE"
      ],
      "gross square footage": [
        "FCLT_BUILDING_HIST.EXT_GROSS_AREA"
      ]
    },
    "join_keys": [
      [
        "FAC_BUILDING_ADDRESS.BUILDING_KEY",
        "FCLT_BUILDING_HIST.FCLT_BUILDING_KEY"
      ],
      [
        "FAC_BUILDING_ADDRESS.BUILDING_KEY",
        "BUILDINGS.BUILDING_KEY"
      ],
      [
        "BUILDINGS.BUILDING_KEY",
        "FAC_ROOMS.BUILDING_KEY"
      ],
      [
        "EMPLOYEE_DIRECTORY.OFFICE_LOCATION",
        "FAC_ROOMS.FAC_ROOM_KEY"
      ],
      [
        "FCLT_BUILDING_HIST.FCLT_BUILDING_KEY",
        "FAC_BUILDING_ADDRESS.BUILDING_KEY"
      ],
      [
        "FAC_BUILDING_ADDRESS.BUILDING_KEY",
        "BUILDINGS.BUILDING_KEY"
      ],
      [
        "BUILDINGS.BUILDING_KEY",
        "FAC_ROOMS.BUILDING_KEY"
      ],
      [
        "FAC_ROOMS.FAC_ROOM_KEY",
        "EMPLOYEE_DIRECTORY.OFFICE_LOCATION"
      ]
    ],
    "sample_id": 89
  },
  {
    "question": "Group spaces in the Stata building by the access level and usage type. For each group, state the access level, usage type, name of the space, the number of spaces, total area across all rooms in the space, and average area across all rooms in the space. Display the access level only if it differs from the previous entry. Include subtotals for each access level, usage type, and space name, subtotals for each access level, and a grand total across all access levels. Exclude usage type that includes \"STORAGE\". All numerical values should be rounded to integers and formatted using commas as thousands separators.",
    "db_id": "dw",
    "sql": "WITH DedupOrg AS (\n  SELECT FCLT_ORGANIZATION_KEY, MAX(DLC_NAME) AS DLC_NAME\n  FROM FCLT_ORGANIZATION\n  GROUP BY FCLT_ORGANIZATION_KEY\n),\nDedupRoomsLoad AS (\n  SELECT BUILDING_ROOM, MAX(ACCESS_LEVEL) AS ACCESS_LEVEL\n  FROM ZPM_ROOMS_LOAD\n  WHERE BUILDING_COMPONENT = '32'\n  GROUP BY BUILDING_ROOM\n),\nSpaceData AS (\n  SELECT zrl.ACCESS_LEVEL, su2.SPACE_USAGE, su.SPACE_UNIT_NAME,\n         sd.ROOM_SQUARE_FOOTAGE, su.SPACE_UNIT_KEY\n  FROM SPACE_UNIT su\n  JOIN SPACE_DETAIL sd ON sd.SPACE_UNIT_KEY = su.SPACE_UNIT_KEY AND sd.BUILDING_KEY = '32'\n  JOIN SPACE_USAGE su2 ON su2.SPACE_USAGE_KEY = sd.SPACE_USAGE_KEY\n  LEFT JOIN DedupRoomsLoad zrl ON zrl.BUILDING_ROOM = sd.BUILDING_ROOM\n  LEFT JOIN DedupOrg fo ON fo.FCLT_ORGANIZATION_KEY = su.FCLT_ORGANIZATION_KEY\n  WHERE su2.SPACE_USAGE NOT LIKE '%STORAGE%'\n)\nSELECT ACCESS_LEVEL, SPACE_USAGE, SPACE_UNIT_NAME,\n       COUNT(DISTINCT SPACE_UNIT_KEY) AS num_spaces,\n       FORMAT(SUM(ROOM_SQUARE_FOOTAGE), 0) AS total_area,\n       FORMAT(AVG(ROOM_SQUARE_FOOTAGE), 0) AS avg_area\nFROM SpaceData\nGROUP BY ACCESS_LEVEL, SPACE_USAGE, SPACE_UNIT_NAME\nWITH ROLLUP\nORDER BY ACCESS_LEVEL, SPACE_USAGE, SPACE_UNIT_NAME;",
    "gold_tables": [
      "dw#sep#SPACE_UNIT",
      "dw#sep#SPACE_DETAIL",
      "dw#sep#SPACE_USAGE",
      "dw#sep#ZPM_ROOMS_LOAD",
      "dw#sep#FCLT_ORGANIZATION"
    ],
    "mapping": {
      "Stata building": [
        "SPACE_DETAIL.BUILDING_KEY"
      ],
      "access level": [
        "ZPM_ROOMS_LOAD.ACCESS_LEVEL"
      ],
      "usage type": [
        "SPACE_USAGE.SPACE_USAGE"
      ],
      "name of the space": [
        "FCLT_ORGANIZATION.DLC_NAME"
      ],
      "spaces": [
        "SPACE_UNIT.SPACE_UNIT"
      ],
      "area": [
        "SPACE_DETAIL.ROOM_SQUARE_FOOTAGE"
      ]
    },
    "join_keys": [
      [
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY",
        "SPACE_UNIT.FCLT_ORGANIZATION_KEY"
      ]
    ],
    "sample_id": 90
  },
  {
    "question": "List each organization's break group, ID, name, and formatted name according to its level, along with whether its members are emeritus or non-emeritus. Also, include the organization number, level, employer count, and hierarchy type for each organization. Exclude organizations '139' and '250'. Sort the results by hierarchy type and ensure totals for employer counts are displayed.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT SUBSTR(organization_sort, 5, 2) AS breakgrp, organization_id, organization_name, CASE WHEN organization_level = '4' THEN CONCAT(' ', organization_name) WHEN organization_level = '5' THEN CONCAT(' ', organization_name) WHEN organization_level = '6' THEN CONCAT(' ', organization_name) ELSE organization_name END AS formatted_name, CASE WHEN hfr.EMERITUS_STATUS = 'Emeritus' THEN 'EMERITUS' WHEN hfr.EMERITUS_STATUS IS NOT NULL THEN 'NON-EMERITUS' ELSE 'NO FACULTY' END AS assign, organization_number, organization_level, (SELECT COUNT(DISTINCT hfr2.MIT_ID) FROM HR_FACULTY_ROSTER hfr2 WHERE hfr2.HR_ORG_UNIT_TITLE=hou.HR_ORG_UNIT_TITLE) AS employer_count, HIERARCHY_TYPE, organization_sort FROM FCLT_ORGANIZATION JOIN MASTER_DEPT_HIERARCHY ON FCLT_ORGANIZATION.DLC_KEY = MASTER_DEPT_HIERARCHY.DLC_KEY LEFT JOIN HR_ORG_UNIT hou ON hou.DLC_KEY=FCLT_ORGANIZATION.DLC_KEY LEFT JOIN HR_FACULTY_ROSTER hfr ON hfr.HR_ORG_UNIT_TITLE=hou.HR_ORG_UNIT_TITLE WHERE organization_level IN ('3', '4', '5', '6') AND organization_id NOT IN ('139', '250') ORDER BY HIERARCHY_TYPE;",
    "gold_tables": [
      "dw#sep#HR_FACULTY_ROSTER",
      "dw#sep#FCLT_ORGANIZATION",
      "dw#sep#MASTER_DEPT_HIERARCHY",
      "dw#sep#HR_ORG_UNIT"
    ],
    "mapping": {
      "break group": [
        "FCLT_ORGANIZATION.ORGANIZATION_SORT"
      ],
      "ID": [
        "FCLT_ORGANIZATION.ORGANIZATION_ID"
      ],
      "name": [
        "FCLT_ORGANIZATION.ORGANIZATION_NAME"
      ],
      "level": [
        "FCLT_ORGANIZATION.ORGANIZATION_LEVEL"
      ],
      "number": [
        "FCLT_ORGANIZATION.ORGANIZATION_NUMBER"
      ],
      "employer": [
        "HR_FACULTY_ROSTER.MIT_ID"
      ],
      "hierarchy type": [
        "MASTER_DEPT_HIERARCHY.HIERARCHY_TYPE"
      ]
    },
    "join_keys": [
      [
        "FCLT_ORGANIZATION.DLC_KEY",
        "MASTER_DEPT_HIERARCHY.DLC_KEY"
      ],
      [
        "FCLT_ORGANIZATION.DLC_KEY",
        "HR_ORG_UNIT.DLC_KEY"
      ],
      [
        "HR_ORG_UNIT.HR_ORG_UNIT_TITLE",
        "HR_FACULTY_ROSTER.HR_ORG_UNIT_TITLE"
      ]
    ],
    "sample_id": 91
  },
  {
    "question": "For each course, list its title, name of the building of the course location, duration (in terms of days), and a running average of the duration (in terms of days) using a window of two preceding and two following courses (partitioned by academic year and sorted by course start date).",
    "db_id": "dw",
    "sql": "SELECT DISTINCT ccso.subject_title, fb.building_name, ccso.duration, AVG(duration) OVER (PARTITION BY ccso.academic_year ORDER BY ccso.term_start_date ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS running_avg FROM (SELECT DISTINCT subject_title, STR_TO_DATE(term_start_date, '%d-%b-%y') AS term_start_date, DATEDIFF(STR_TO_DATE(term_end_date, '%d-%b-%y'), STR_TO_DATE(term_start_date, '%d-%b-%y')) AS duration, cis.academic_year, meet_place FROM academic_terms JOIN COURSE_CATALOG_SUBJECT_OFFERED cis ON cis.effective_term_code = academic_terms.term_code) ccso LEFT JOIN FCLT_ROOMS fr ON ccso.MEET_PLACE = fr.FCLT_ROOM_KEY LEFT JOIN FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY;",
    "gold_tables": [
      "dw#sep#ACADEMIC_TERMS",
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_BUILDING"
    ],
    "mapping": {
      "title": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "name of the building": [
        "FCLT_BUILDING.BUILDING_NAME"
      ],
      "duration": [
        "ACADEMIC_TERMS.TERM_END_DATE",
        "ACADEMIC_TERMS.TERM_START_DATE"
      ]
    },
    "join_keys": [
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.EFFECTIVE_TERM_CODE",
        "ACADEMIC_TERMS.TERM_CODE"
      ],
      [
        "FCLT_ROOMS.FCLT_BUILDING_KEY",
        "FCLT_BUILDING.FCLT_BUILDING_KEY"
      ]
    ],
    "sample_id": 92
  },
  {
    "question": "For each course, list its name, name of the building of the course location, the start date, the name of the course before it, and the name of the course after it, access level of the building, and the assignable area of the room used for the course, sorted by the ascending order start date and course name.",
    "db_id": "dw",
    "sql": "SELECT ccso.subject_title, fb.BUILDING_NAME_LONG AS building_name, at.TERM_START_DATE AS term_start_date, lag(ccso.subject_title) OVER ( ORDER BY at.TERM_START_DATE ASC, ccso.subject_title ASC ) AS previous_subject_title, lead(ccso.subject_title) OVER ( ORDER BY at.TERM_START_DATE ASC, ccso.subject_title ASC ) AS next_subject_title, fb.ACCESS_LEVEL_NAME AS access_level, fr.AREA AS room_assignable_area FROM ( SELECT DISTINCT subject_id, subject_title, effective_term_code, meet_place FROM COURSE_CATALOG_SUBJECT_OFFERED ) ccso JOIN ACADEMIC_TERMS at ON at.TERM_CODE = ccso.effective_term_code JOIN FCLT_ROOMS fr ON ccso.MEET_PLACE = fr.FCLT_ROOM_KEY JOIN FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY ORDER BY at.TERM_START_DATE ASC, ccso.subject_title ASC;",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#ACADEMIC_TERMS",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_BUILDING"
    ],
    "mapping": {
      "name": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "name of the building": [
        "FCLT_BUILDING.BUILDING_NAME_LONG"
      ],
      "start date": [
        "ACADEMIC_TERMS.TERM_START_DATE"
      ],
      "name of the course": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "access level": [
        "FCLT_BUILDING.ACCESS_LEVEL_NAME"
      ],
      "area": [
        "FCLT_ROOMS.AREA"
      ]
    },
    "join_keys": [
      [
        "FCLT_BUILDING.FCLT_BUILDING_KEY",
        "FCLT_ROOMS.FCLT_BUILDING_KEY"
      ]
    ],
    "sample_id": 93
  },
  {
    "question": "For each course, list its name, name of the building of the course location, and the cumulative number of courses, including the course itself, held in the same year or preceding years (partitioned by academic year and sorted in the ascending order of course start date).",
    "db_id": "dw",
    "sql": "SELECT subject_id, subject_title, building_name, academic_year, cumulative_cnt FROM (SELECT subject_id, subject_title, building_name, academic_year, COUNT(*) OVER (PARTITION BY academic_year ORDER BY term_start_date ASC RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_cnt FROM (SELECT DISTINCT ccso.subject_id, ccso.subject_title, fb.building_name, ccso.academic_year, academic_terms.term_start_date FROM COURSE_CATALOG_SUBJECT_OFFERED ccso JOIN academic_terms ON ccso.effective_term_code = academic_terms.term_code JOIN (SELECT DISTINCT FCLT_ROOM_KEY, FCLT_BUILDING_KEY FROM FCLT_ROOMS) fr ON ccso.MEET_PLACE = fr.FCLT_ROOM_KEY JOIN FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY) deduped) final;",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#ACADEMIC_TERMS",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_BUILDING"
    ],
    "mapping": {
      "name": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "name of the building": [
        "FCLT_BUILDING.BUILDING_NAME"
      ],
      "courses": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "academic year": [
        "COURSE_CATALOG_SUBJECT_OFFERED.ACADEMIC_YEAR"
      ],
      "course start date": [
        "ACADEMIC_TERMS.TERM_START_DATE"
      ]
    },
    "join_keys": [
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.EFFECTIVE_TERM_CODE",
        "ACADEMIC_TERMS.TERM_CODE"
      ],
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.MEET_PLACE",
        "FCLT_ROOMS.FCLT_ROOM_KEY"
      ]
    ],
    "sample_id": 94
  },
  {
    "question": "Group courses in the biology and chemistry department by whether they are current or not and the cluster type. For each group, list the current status ('CURRENT' if yes and 'NON-CURRENT' otherwise), cluster type, the maximum duration of courses (in terms of days), the maximum units, average duration (in terms of days), and average units. Include subtotals for each current status (the corresponding current status field is 'SUBTOTAL') and a grand total across all current status (the corresponding current status field is 'TOTAL'). Do not repeat the current status if it is the same as the previous row. Sort the table by current status and cluster type.",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(assign) OVER (ORDER BY IS_CURRENT_TERM DESC, assign, CLUSTER_TYPE ASC) = assign THEN NULL ELSE assign END AS assign, CLUSTER_TYPE, max_duration, max_units, avg_dur, avg_unit FROM ( SELECT CASE WHEN GROUPING(CLUSTER_TYPE) = 1 AND GROUPING(IS_CURRENT_TERM) = 0 THEN 'SUBTOTAL' WHEN GROUPING(CLUSTER_TYPE) = 1 AND GROUPING(IS_CURRENT_TERM) = 1 THEN 'TOTAL' ELSE CASE WHEN IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END END AS assign, IS_CURRENT_TERM, CLUSTER_TYPE, MAX(DATEDIFF(STR_TO_DATE(term_end_date, '%d-%b-%y'), STR_TO_DATE(term_start_date, '%d-%b-%y'))) AS max_duration, MAX(TOTAL_UNITS) AS max_units, AVG(DATEDIFF(STR_TO_DATE(term_end_date, '%d-%b-%y'), STR_TO_DATE(term_start_date, '%d-%b-%y'))) AS avg_dur, AVG(TOTAL_UNITS) AS avg_unit FROM SUBJECT_SUMMARY ss JOIN ACADEMIC_TERMS_ALL ata ON ata.TERM_CODE = ss.TERM_CODE WHERE CLUSTER_TYPE IS NOT NULL AND ss.department_name IN ('Chemistry', 'Biology') GROUP BY IS_CURRENT_TERM, CLUSTER_TYPE WITH ROLLUP ORDER BY IS_CURRENT_TERM DESC, assign, CLUSTER_TYPE ASC ) tbltmp;",
    "gold_tables": [
      "dw#sep#SUBJECT_SUMMARY",
      "dw#sep#ACADEMIC_TERMS_ALL"
    ],
    "mapping": {
      "biology and chemistry department": [
        "SUBJECT_SUMMARY.DEPARTMENT_NAME"
      ],
      "current status": [
        "ACADEMIC_TERMS_ALL.IS_CURRENT_TERM"
      ],
      "cluster type": [
        "SUBJECT_SUMMARY.CLUSTER_TYPE"
      ],
      "duration": [
        "ACADEMIC_TERMS_ALL.TERM_END_DATE",
        "ACADEMIC_TERMS_ALL.TERM_START_DATE"
      ],
      "units": [
        "SUBJECT_SUMMARY.TOTAL_UNITS"
      ]
    },
    "join_keys": [
      [
        "ACADEMIC_TERMS_ALL.TERM_CODE",
        "SUBJECT_SUMMARY.TERM_CODE"
      ]
    ],
    "sample_id": 95
  },
  {
    "question": "Group courses in the biology and chemistry department by whether they are current or not and the department name. For each group, list the current status ('CURRENT' if yes and 'NON-CURRENT' otherwise), department name, the maximum duration of courses (in terms of days), the maximum units, average duration (in terms of days), and average units. Include subtotals for each current status (the corresponding current status field is 'SUBTOTAL') and a grand total across all current status (the corresponding current status field is 'TOTAL'). Do not repeat the current status if it is the same as the previous row. Sort the table by current status and department.",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(assign) OVER (ORDER BY IS_CURRENT_TERM DESC, assign, DEPARTMENT_NAME ASC) = assign THEN NULL ELSE assign END AS assign, DEPARTMENT_NAME, max_duration, max_units, avg_dur, avg_unit FROM (SELECT CASE WHEN GROUPING(DEPARTMENT_NAME) = 1 AND GROUPING(IS_CURRENT_TERM) = 0 THEN 'SUBTOTAL' WHEN GROUPING(DEPARTMENT_NAME) = 1 AND GROUPING(IS_CURRENT_TERM) = 1 THEN 'TOTAL' ELSE CASE WHEN IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END END AS assign, IS_CURRENT_TERM, DEPARTMENT_NAME, MAX(DATEDIFF(STR_TO_DATE(term_end_date, '%d-%b-%y'), STR_TO_DATE(term_start_date, '%d-%b-%y'))) AS max_duration, MAX(TOTAL_UNITS) AS max_units, AVG(DATEDIFF(STR_TO_DATE(term_end_date, '%d-%b-%y'), STR_TO_DATE(term_start_date, '%d-%b-%y'))) AS avg_dur, AVG(TOTAL_UNITS) AS avg_unit FROM SUBJECT_SUMMARY ss JOIN ACADEMIC_TERMS_ALL ata ON ata.TERM_CODE = ss.TERM_CODE WHERE ss.department_name IN ('Chemistry', 'Biology') GROUP BY IS_CURRENT_TERM, DEPARTMENT_NAME WITH ROLLUP ORDER BY IS_CURRENT_TERM DESC, assign, DEPARTMENT_NAME ASC) tbltmp;",
    "gold_tables": [
      "dw#sep#SUBJECT_SUMMARY",
      "dw#sep#ACADEMIC_TERMS_ALL"
    ],
    "mapping": {
      "biology and chemistry department": [
        "SUBJECT_SUMMARY.DEPARTMENT_NAME"
      ],
      "current status": [
        "ACADEMIC_TERMS_ALL.IS_CURRENT_TERM"
      ],
      "duration": [
        "ACADEMIC_TERMS_ALL.TERM_END_DATE",
        "ACADEMIC_TERMS_ALL.TERM_START_DATE"
      ],
      "units": [
        "SUBJECT_SUMMARY.TOTAL_UNITS"
      ]
    },
    "join_keys": [
      [
        "ACADEMIC_TERMS_ALL.TERM_CODE",
        "SUBJECT_SUMMARY.TERM_CODE"
      ]
    ],
    "sample_id": 96
  },
  {
    "question": "Group master courses by department. For each group, state the name of the department, the master course code, the number of subjects, the total new shelf price of associated TIP materials, and the number of unique TIP materials. Display the department and master course only if it differs from the previous entry. Include subtotals for each department and a grand total across all departments. All numerical values should be rounded to integers and formatted using commas as thousands separators.",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(dept) OVER (ORDER BY dept_sort, master) = dept THEN NULL ELSE dept END AS dept, CASE WHEN master = 'zzz' THEN NULL ELSE master END AS master, subcnt, totalprice, matcnt FROM (SELECT CASE WHEN GROUPING(OFFER_DEPT_NAME) = 1 AND GROUPING(MASTER_COURSE_NUMBER) = 1 THEN 'zzz' ELSE OFFER_DEPT_NAME END AS dept_sort, CASE WHEN GROUPING(OFFER_DEPT_NAME) = 0 AND GROUPING(MASTER_COURSE_NUMBER) = 1 THEN 'SUBTOTAL' WHEN GROUPING(OFFER_DEPT_NAME) = 1 AND GROUPING(MASTER_COURSE_NUMBER) = 1 THEN 'TOTAL' ELSE OFFER_DEPT_NAME END AS dept, CASE WHEN GROUPING(OFFER_DEPT_NAME) = 0 AND GROUPING(MASTER_COURSE_NUMBER) = 1 THEN 'zzz' ELSE MASTER_COURSE_NUMBER END AS master, FORMAT(COUNT(DISTINCT tso.SUBJECT_ID), 0) AS subcnt, FORMAT(SUM(NEW_SHELF_PRICE), 0) AS totalprice, FORMAT(COUNT(DISTINCT tm.ISBN), 0) AS matcnt FROM TIP_DETAIL td JOIN TIP_SUBJECT_OFFERED tso ON tso.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY JOIN TIP_MATERIAL tm ON tm.TIP_MATERIAL_KEY = td.TIP_MATERIAL_KEY GROUP BY OFFER_DEPT_NAME, MASTER_COURSE_NUMBER WITH ROLLUP) tbltmp ORDER BY dept_sort, master;",
    "gold_tables": [
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_SUBJECT_OFFERED",
      "dw#sep#TIP_MATERIAL"
    ],
    "mapping": {
      "name of the department": [
        "TIP_SUBJECT_OFFERED.OFFER_DEPT_NAME"
      ],
      "master course code": [
        "TIP_SUBJECT_OFFERED.MASTER_COURSE_NUMBER"
      ],
      "subjects": [
        "TIP_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "new shelf price": [
        "TIP_MATERIAL.NEW_SHELF_PRICE"
      ],
      "TIP materials": [
        "TIP_MATERIAL.ISBN"
      ]
    },
    "join_keys": [
      [
        "TIP_DETAIL.TIP_MATERIAL_KEY",
        "TIP_MATERIAL.TIP_MATERIAL_KEY"
      ]
    ],
    "sample_id": 97
  },
  {
    "question": "For each term and department, list the term, department, the number of courses, average number of equivalent subjects, the school name, and department phone number. Include subtotals for each term (the corresponding term field is 'SUBTOTAL') and a grand total across all terms (the corresponding term field is 'TOTAL'). Do not repeat the term if it is the same as the previous row. Sort the table by term and department.",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(term) OVER (ORDER BY term_sort, term, dept_sort) = term THEN NULL ELSE term END AS term, dept, subcnt, avgeqisub, sd.SCHOOL_NAME AS school_name, ad.DEPARTMENT_PHONE_NUMBER AS department_phone FROM (SELECT CASE WHEN GROUPING(TERM_CODE) = 1 AND GROUPING(DEPARTMENT_NAME) = 1 THEN 'zzz' ELSE TERM_CODE END AS term_sort, CASE WHEN GROUPING(TERM_CODE) = 0 AND GROUPING(DEPARTMENT_NAME) = 1 THEN 'SUBTOTAL' WHEN GROUPING(TERM_CODE) = 1 AND GROUPING(DEPARTMENT_NAME) = 1 THEN 'TOTAL' ELSE TERM_CODE END AS term, CASE WHEN GROUPING(TERM_CODE) = 0 AND GROUPING(DEPARTMENT_NAME) = 1 THEN 'zzz' ELSE DEPARTMENT_NAME END AS dept_sort, DEPARTMENT_NAME AS dept, COUNT(DISTINCT SUBJECT_ID) AS subcnt, MIN(MEET_TIME) AS mintime, AVG(CASE WHEN equivalent_subjects IS NULL THEN 0 ELSE 1 + LENGTH(equivalent_subjects) - LENGTH(REPLACE(equivalent_subjects, ',', '')) END) AS avgeqisub FROM COURSE_CATALOG_SUBJECT_OFFERED GROUP BY TERM_CODE, DEPARTMENT_NAME WITH ROLLUP) tbltmp LEFT JOIN (SELECT DEPARTMENT_NAME, DEPARTMENT_CODE, SCHOOL_NAME FROM (SELECT DEPARTMENT_NAME, DEPARTMENT_CODE, SCHOOL_NAME, ROW_NUMBER() OVER (PARTITION BY DEPARTMENT_NAME ORDER BY DEPARTMENT_CODE) as rn FROM SIS_DEPARTMENT) sub WHERE rn = 1) sd ON tbltmp.dept = sd.DEPARTMENT_NAME LEFT JOIN SIS_ADMIN_DEPARTMENT ad ON sd.DEPARTMENT_CODE = ad.SIS_ADMIN_DEPARTMENT_CODE ORDER BY term_sort, dept_sort;",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#SIS_DEPARTMENT",
      "dw#sep#SIS_ADMIN_DEPARTMENT"
    ],
    "mapping": {
      "term": [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE"
      ],
      "department": [
        "COURSE_CATALOG_SUBJECT_OFFERED.DEPARTMENT_NAME"
      ],
      "courses": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "equivalent subjects": [
        "COURSE_CATALOG_SUBJECT_OFFERED.EQUIVALENT_SUBJECTS"
      ],
      "school name": [
        "SIS_DEPARTMENT.SCHOOL_NAME"
      ],
      "department phone number": [
        "SIS_ADMIN_DEPARTMENT.DEPARTMENT_PHONE_NUMBER"
      ]
    },
    "join_keys": [
      [
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_CODE",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ]
    ],
    "sample_id": 98
  },
  {
    "question": "Group sessions by their current term status. For each group, state the status ('CURRENT' if is current term and 'NOT CURRENT' otherwise), name of the session, number of IAP sessions, total IAP session time in days, and average IAP session time in days. Show a subtotal for each current status and a grand total row across all status. Order the results by current status and cluster type. Display the the current status only if it differs from the previous entry.",
    "db_id": "dw",
    "sql": "WITH DedupSessions AS (\n  SELECT DISTINCT ss.IAP_SUBJECT_SESSION_KEY, ss.TERM_CODE, isc.IAP_CATEGORY_NAME,\n         iss.SESSION_START_TIME, iss.SESSION_END_TIME\n  FROM IAP_SUBJECT_DETAIL ss\n  JOIN IAP_SUBJECT_SESSION iss ON iss.IAP_SUBJECT_SESSION_KEY = ss.IAP_SUBJECT_SESSION_KEY\n  JOIN IAP_SUBJECT_CATEGORY isc ON isc.IAP_SUBJECT_CATEGORY_KEY = ss.IAP_SUBJECT_CATEGORY_KEY\n),\nSessionTimes AS (\n  SELECT ds.*, at.IS_CURRENT_TERM,\n         COALESCE(TIMESTAMPDIFF(HOUR, \n           STR_TO_DATE(CONCAT(LEFT(ds.SESSION_START_TIME, 2), ':', SUBSTRING(ds.SESSION_START_TIME, 3, 2), ' ', RIGHT(ds.SESSION_START_TIME, 2)), '%h:%i %p'),\n           STR_TO_DATE(CONCAT(LEFT(ds.SESSION_END_TIME, 2), ':', SUBSTRING(ds.SESSION_END_TIME, 3, 2), ' ', RIGHT(ds.SESSION_END_TIME, 2)), '%h:%i %p')\n         ) / 24.0, 0) AS session_days\n  FROM DedupSessions ds\n  JOIN ACADEMIC_TERMS at ON at.TERM_CODE = ds.TERM_CODE\n)\nSELECT \n  CASE WHEN IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NOT CURRENT' END AS term_status,\n  IAP_CATEGORY_NAME AS session_name,\n  COUNT(DISTINCT IAP_SUBJECT_SESSION_KEY) AS num_sessions,\n  SUM(session_days) AS total_session_days,\n  AVG(session_days) AS avg_session_days\nFROM SessionTimes\nGROUP BY IS_CURRENT_TERM, IAP_CATEGORY_NAME\nWITH ROLLUP\nORDER BY IS_CURRENT_TERM, IAP_CATEGORY_NAME;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#ACADEMIC_TERMS",
      "dw#sep#IAP_SUBJECT_SESSION",
      "dw#sep#IAP_SUBJECT_CATEGORY"
    ],
    "mapping": {
      "current term status": [
        "ACADEMIC_TERMS.IS_CURRENT_TERM"
      ],
      "name of the session": [
        "IAP_SUBJECT_CATEGORY.IAP_CATEGORY_NAME"
      ],
      "IAP sessions": [
        "IAP_SUBJECT_SESSION.SESSION_DATE"
      ],
      "session time": [
        "IAP_SUBJECT_SESSION.SESSION_START_TIME",
        "IAP_SUBJECT_SESSION.SESSION_END_TIME"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_DETAIL.TERM_CODE",
        "ACADEMIC_TERMS.TERM_CODE"
      ],
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY",
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY"
      ],
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_CATEGORY_KEY",
        "IAP_SUBJECT_CATEGORY.IAP_SUBJECT_CATEGORY_KEY"
      ]
    ],
    "sample_id": 99
  },
  {
    "question": "List each academic year, the term code, and the number of newly introduced subjects in this term. Display the academic year only if it differs from the previous entry. Include a grand total (the corresponding year field should be 'TOTAL') stating the total number of subjects across all academic years.",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(ACADEMIC_YEAR) OVER (ORDER BY ata.TERM_CODE) = ata.ACADEMIC_YEAR THEN NULL ELSE ata.ACADEMIC_YEAR END AS ACADEMIC_YEAR, ata.TERM_CODE, COUNT(DISTINCT si) AS distinct_subject_count FROM ACADEMIC_TERMS_ALL ata LEFT OUTER JOIN (SELECT CASE WHEN LAG(subject_id) OVER (ORDER BY SUBJECT_ID, TERM_CODE ASC, ACADEMIC_YEAR ASC) = subject_id THEN NULL ELSE subject_id END AS si, CASE WHEN LAG(subject_id) OVER (ORDER BY SUBJECT_ID, TERM_CODE ASC, ACADEMIC_YEAR ASC) = subject_id THEN NULL ELSE term_code END AS term_code FROM course_catalog_subject_offered WHERE TERM_CODE IS NOT NULL) AS a ON ata.TERM_CODE = a.TERM_CODE GROUP BY ata.TERM_CODE, ata.ACADEMIC_YEAR UNION ALL SELECT 'TOTAL', NULL, COUNT(DISTINCT SUBJECT_ID) AS total_distinct_subject_count FROM course_catalog_subject_offered;",
    "gold_tables": [
      "dw#sep#ACADEMIC_TERMS_ALL",
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED"
    ],
    "mapping": {
      "academic year": [
        "ACADEMIC_TERMS_ALL.ACADEMIC_YEAR"
      ],
      "term code": [
        "ACADEMIC_TERMS_ALL.TERM_CODE"
      ],
      "subjects": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ]
    },
    "join_keys": [],
    "sample_id": 100
  },
  {
    "question": "For email lists with names starting with e (case insensitive), containing 10 to 20 members inclusive, and where over 75% are computer science students, provide the list name, owner, and member count.",
    "db_id": "dw",
    "sql": "WITH FilteredLists AS (SELECT ml.MOIRA_LIST_NAME, mlo.OWNER, COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS TOTAL_MEMBER_COUNT FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY WHERE UPPER(ml.MOIRA_LIST_NAME) LIKE 'E%' GROUP BY ml.MOIRA_LIST_NAME, mlo.OWNER HAVING COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) BETWEEN 10 AND 20), CSStudentCounts AS (SELECT fl.MOIRA_LIST_NAME, COUNT(DISTINCT CASE WHEN msd.DEPARTMENT = '6' THEN se.KRB_NAME ELSE NULL END) AS CS_STUDENT_COUNT FROM FilteredLists fl JOIN MOIRA_LIST ml ON fl.MOIRA_LIST_NAME = ml.MOIRA_LIST_NAME JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN SE_PERSON se ON UPPER(mld.MOIRA_LIST_MEMBER) = UPPER(se.KRB_NAME) JOIN MIT_STUDENT_DIRECTORY msd ON se.FULL_NAME = msd.FULL_NAME GROUP BY fl.MOIRA_LIST_NAME) SELECT fl.MOIRA_LIST_NAME, fl.OWNER, fl.TOTAL_MEMBER_COUNT FROM FilteredLists fl JOIN CSStudentCounts cs ON fl.MOIRA_LIST_NAME = cs.MOIRA_LIST_NAME WHERE cs.CS_STUDENT_COUNT > 0.75 * fl.TOTAL_MEMBER_COUNT;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MOIRA_LIST_OWNER",
      "dw#sep#SE_PERSON",
      "dw#sep#MIT_STUDENT_DIRECTORY"
    ],
    "mapping": {
      "names": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "members": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ],
      "computer science": [
        "MIT_STUDENT_DIRECTORY.DEPARTMENT"
      ],
      "owner": [
        "MOIRA_LIST_OWNER.OWNER"
      ]
    },
    "join_keys": [
      [
        "SE_PERSON.FULL_NAME",
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER",
        "SE_PERSON.KRB_NAME"
      ],
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ],
      [
        "MOIRA_LIST_OWNER.MOIRA_LIST_OWNER_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_OWNER_KEY"
      ]
    ],
    "sample_id": 101
  },
  {
    "question": "For students with last names starting with K, list their names, the phone numbers of departments they belong to, total number of mailing lists each student is in, and the average size of the mailing lists each student is in.",
    "db_id": "dw",
    "sql": "WITH MailingListSizes AS (SELECT MOIRA_LIST_KEY, COUNT(MOIRA_LIST_MEMBER) AS List_Size FROM MOIRA_LIST_DETAIL GROUP BY MOIRA_LIST_KEY) SELECT msd.FULL_NAME AS Student_Name, sad.DEPARTMENT_PHONE_NUMBER, COUNT(DISTINCT mld.MOIRA_LIST_KEY) AS Total_Lists, AVG(MLS.List_Size) AS Avg_List_Size FROM MIT_STUDENT_DIRECTORY msd LEFT JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE LEFT JOIN SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE LEFT JOIN SE_PERSON se ON msd.FULL_NAME = se.FULL_NAME LEFT JOIN MOIRA_LIST_DETAIL mld ON UPPER(se.KRB_NAME) = UPPER(mld.MOIRA_LIST_MEMBER) LEFT JOIN MailingListSizes MLS ON mld.MOIRA_LIST_KEY = MLS.MOIRA_LIST_KEY WHERE msd.LAST_NAME LIKE 'K%' GROUP BY msd.FULL_NAME, sad.DEPARTMENT_PHONE_NUMBER;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MIT_STUDENT_DIRECTORY",
      "dw#sep#SIS_DEPARTMENT",
      "dw#sep#SIS_ADMIN_DEPARTMENT",
      "dw#sep#SE_PERSON"
    ],
    "mapping": {
      "last names": [
        "MIT_STUDENT_DIRECTORY.LAST_NAME"
      ],
      "names": [
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ],
      "phone numbers": [
        "SIS_ADMIN_DEPARTMENT.DEPARTMENT_PHONE_NUMBER"
      ],
      "mailing lists": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ]
    },
    "join_keys": [
      [
        "MIT_STUDENT_DIRECTORY.DEPARTMENT",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      [
        "SIS_DEPARTMENT.DEPARTMENT_CODE",
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_CODE"
      ],
      [
        "MIT_STUDENT_DIRECTORY.FULL_NAME",
        "SE_PERSON.FULL_NAME"
      ]
    ],
    "sample_id": 102
  },
  {
    "question": "From the 100 email lists with the most number of subscribers, list their names, their total number of subscribers, their public status, the name of the department with the most presence in the list, and the number of students from this department in the list.",
    "db_id": "dw",
    "sql": "WITH ListPublicStatus AS (SELECT MOIRA_LIST_NAME, MAX(IS_PUBLIC) AS IS_PUBLIC FROM MOIRA_LIST GROUP BY MOIRA_LIST_NAME), DedupedMoiraList AS (SELECT DISTINCT ml.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME, lps.IS_PUBLIC FROM MOIRA_LIST ml JOIN ListPublicStatus lps ON ml.MOIRA_LIST_NAME = lps.MOIRA_LIST_NAME), ListMemberCount AS (SELECT ml.MOIRA_LIST_NAME, ml.IS_PUBLIC, COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS Member_Count FROM DedupedMoiraList ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY GROUP BY ml.MOIRA_LIST_NAME, ml.IS_PUBLIC), DepartmentCounts AS (SELECT ml.MOIRA_LIST_NAME, sd.DEPARTMENT_NAME, COUNT(DISTINCT msd.FULL_NAME) AS Student_Count, ROW_NUMBER() OVER (PARTITION BY ml.MOIRA_LIST_NAME ORDER BY COUNT(DISTINCT msd.FULL_NAME) DESC) AS rnk FROM DedupedMoiraList ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN SE_PERSON se ON UPPER(mld.MOIRA_LIST_MEMBER) = UPPER(se.KRB_NAME) JOIN MIT_STUDENT_DIRECTORY msd ON msd.FULL_NAME = se.FULL_NAME JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE GROUP BY ml.MOIRA_LIST_NAME, sd.DEPARTMENT_NAME) SELECT lmc.MOIRA_LIST_NAME, lmc.Member_Count, lmc.IS_PUBLIC, dc.DEPARTMENT_NAME AS Most_Prominent_Department, dc.Student_Count FROM ListMemberCount lmc LEFT JOIN DepartmentCounts dc ON lmc.MOIRA_LIST_NAME = dc.MOIRA_LIST_NAME AND dc.rnk = 1 ORDER BY lmc.Member_Count DESC LIMIT 100;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#SE_PERSON",
      "dw#sep#MIT_STUDENT_DIRECTORY",
      "dw#sep#SIS_DEPARTMENT"
    ],
    "mapping": {
      "names": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "subscribers": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ],
      "public status": [
        "MOIRA_LIST.IS_PUBLIC"
      ],
      "department": [
        "SIS_DEPARTMENT.DEPARTMENT_NAME"
      ],
      "students": [
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ],
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ],
      [
        "SIS_DEPARTMENT.DEPARTMENT_CODE",
        "MIT_STUDENT_DIRECTORY.DEPARTMENT"
      ]
    ],
    "sample_id": 103
  },
  {
    "question": "Calculate the total assignable and non-assignable area for each building by summing up the respective areas of all its floors. For each building, list the building name, building number, total assignable area, total non-assignable area, and total room count, sorted in descending order of the total assignable area.",
    "db_id": "dw",
    "sql": "SELECT b.BUILDING_NAME, b.BUILDING_NUMBER,\n       SUM(f.ASSIGNABLE_AREA) AS TOTAL_ASSIGNABLE_AREA,\n       SUM(f.NON_ASSIGNABLE_AREA) AS TOTAL_NON_ASSIGNABLE_AREA,\n       COALESCE(room_counts.TOTAL_ROOMS, 0) AS TOTAL_ROOMS\nFROM FAC_BUILDING b\nJOIN FAC_FLOOR f ON b.FAC_BUILDING_KEY = f.BUILDING_KEY\nLEFT JOIN (SELECT BUILDING_KEY, COUNT(FAC_ROOM_KEY) AS TOTAL_ROOMS\n           FROM FAC_ROOMS GROUP BY BUILDING_KEY) room_counts\n          ON b.FAC_BUILDING_KEY = room_counts.BUILDING_KEY\nGROUP BY b.BUILDING_NAME, b.BUILDING_NUMBER, room_counts.TOTAL_ROOMS\nORDER BY TOTAL_ASSIGNABLE_AREA DESC;",
    "gold_tables": [
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_FLOOR",
      "dw#sep#FAC_ROOMS"
    ],
    "mapping": {
      "building name": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "building number": [
        "FAC_BUILDING.BUILDING_NUMBER"
      ],
      "assignable area": [
        "FAC_FLOOR.ASSIGNABLE_AREA"
      ],
      "non-assignable area": [
        "FAC_FLOOR.NON_ASSIGNABLE_AREA"
      ],
      "room": [
        "FAC_ROOMS.FAC_ROOM_KEY"
      ]
    },
    "join_keys": [
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_FLOOR.BUILDING_KEY"
      ],
      [
        "FAC_FLOOR.BUILDING_KEY",
        "FAC_ROOMS.BUILDING_KEY"
      ],
      [
        "FAC_FLOOR.FLOOR",
        "FAC_ROOMS.FLOOR"
      ]
    ],
    "sample_id": 104
  },
  {
    "question": "List all rooms in building 45, including their full name, area, major use, the organization that occupies them, the count of rooms per major use, and the total area occupied by rooms for each organization.",
    "db_id": "dw",
    "sql": "SELECT r.ROOM_FULL_NAME, r.AREA, mu.MAJOR_USE, o.ORGANIZATION_NAME, COUNT(*) OVER (PARTITION BY mu.MAJOR_USE) AS ROOM_COUNT_PER_MAJOR_USE, SUM(r.AREA) OVER (PARTITION BY o.ORGANIZATION_NAME) AS TOTAL_AREA_PER_ORG FROM FAC_ROOMS r JOIN FAC_MAJOR_USE mu ON r.MAJOR_USE_KEY = mu.MAJOR_USE_KEY JOIN FAC_ORGANIZATION o ON r.ORGANIZATION_KEY = o.ORGANIZATION_KEY WHERE r.BUILDING_KEY = 45 ORDER BY r.FAC_ROOM_KEY;",
    "gold_tables": [
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_MAJOR_USE",
      "dw#sep#FAC_ORGANIZATION"
    ],
    "mapping": {
      "building 45": [
        "FAC_ROOMS.BUILDING_KEY"
      ],
      "full name": [
        "FAC_ROOMS.ROOM_FULL_NAME"
      ],
      "area": [
        "FAC_ROOMS.AREA"
      ],
      "major use": [
        "FAC_MAJOR_USE.MAJOR_USE"
      ],
      "organization": [
        "FAC_ORGANIZATION.ORGANIZATION_NAME"
      ],
      "rooms": [
        "FAC_ROOMS.FAC_ROOM_KEY"
      ]
    },
    "join_keys": [
      [
        "FAC_ROOMS.MAJOR_USE_KEY",
        "FAC_MAJOR_USE.MAJOR_USE_KEY"
      ],
      [
        "FAC_ROOMS.ORGANIZATION_KEY",
        "FAC_ORGANIZATION.ORGANIZATION_KEY"
      ]
    ],
    "sample_id": 105
  },
  {
    "question": "List the name, number, construction date, and type of all buildings, along with the count of addresses associated with each building, the average gross area of the buildings, and the total number of rooms in each building. Sort the results by building name.",
    "db_id": "dw",
    "sql": "SELECT b.BUILDING_NAME, b.BUILDING_NUMBER, b.DATE_BUILT, b.BUILDING_TYPE, \n       COUNT(DISTINCT a.BUILDING_ADDRESS_KEY) AS ADDRESS_COUNT, \n       MAX(b.EXT_GROSS_AREA) AS GROSS_AREA, \n       COUNT(DISTINCT r.FAC_ROOM_KEY) AS TOTAL_ROOMS \nFROM FAC_BUILDING b \nLEFT JOIN FAC_BUILDING_ADDRESS a ON b.FAC_BUILDING_KEY = a.BUILDING_KEY \nLEFT JOIN FAC_ROOMS r ON b.FAC_BUILDING_KEY = r.BUILDING_KEY \nGROUP BY b.FAC_BUILDING_KEY, b.BUILDING_NAME, b.BUILDING_NUMBER, b.DATE_BUILT, b.BUILDING_TYPE \nORDER BY b.BUILDING_NAME;",
    "gold_tables": [
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_BUILDING_ADDRESS",
      "dw#sep#FAC_ROOMS"
    ],
    "mapping": {
      "name": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "number": [
        "FAC_BUILDING.BUILDING_NUMBER"
      ],
      "construction date": [
        "FAC_BUILDING.DATE_BUILT"
      ],
      "type": [
        "FAC_BUILDING.BUILDING_TYPE"
      ],
      "addresses": [
        "FAC_BUILDING_ADDRESS.BUILDING_ADDRESS_KEY"
      ],
      "gross area": [
        "FAC_BUILDING.EXT_GROSS_AREA"
      ],
      "rooms": [
        "FAC_ROOMS.FAC_ROOM_KEY"
      ]
    },
    "join_keys": [
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_BUILDING_ADDRESS.BUILDING_KEY"
      ],
      [
        "FAC_ROOMS.BUILDING_KEY",
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ]
    ],
    "sample_id": 106
  },
  {
    "question": "For each department, list its name, number of unique courses offered, the number of unique reserved materials, and the number of unique instructors associated with those courses, sorted by the number of unique courses offered in descending order.",
    "db_id": "dw",
    "sql": "SELECT lso.OFFER_DEPT_NAME AS DEPARTMENT, COUNT(DISTINCT lso.MASTER_COURSE_NUMBER) AS COURSE_COUNT, COUNT(DISTINCT lrc.CATALOG_TITLE) AS UNIQUE_MATERIALS, COUNT(DISTINCT lci.INSTRUCTOR_NAME) AS UNIQUE_INSTRUCTORS FROM LIBRARY_SUBJECT_OFFERED lso LEFT JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lso.LIBRARY_SUBJECT_OFFERED_KEY = lrmd.LIBRARY_SUBJECT_OFFERED_KEY LEFT JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY LEFT JOIN LIBRARY_COURSE_INSTRUCTOR lci ON lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY GROUP BY lso.OFFER_DEPT_NAME ORDER BY COURSE_COUNT DESC;",
    "gold_tables": [
      "dw#sep#LIBRARY_SUBJECT_OFFERED",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#LIBRARY_COURSE_INSTRUCTOR"
    ],
    "mapping": {
      "name": [
        "LIBRARY_SUBJECT_OFFERED.OFFER_DEPT_NAME"
      ],
      "course": [
        "LIBRARY_SUBJECT_OFFERED.MASTER_COURSE_NUMBER"
      ],
      "reserved materials": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_TITLE"
      ],
      "instructors": [
        "LIBRARY_COURSE_INSTRUCTOR.INSTRUCTOR_NAME"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY",
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ]
    ],
    "sample_id": 107
  },
  {
    "question": "For each course title, list the title, the total number of reserved materials, and the count of distinct material status associated with those materials, sorted by the total number of reserved materials in descending order.",
    "db_id": "dw",
    "sql": "SELECT lso.SUBJECT_TITLE AS COURSE_TITLE, COUNT(DISTINCT lrmd.LIBRARY_RESERVE_CATALOG_KEY) AS TOTAL_MATERIALS, COUNT(DISTINCT lms.LIBRARY_MATERIAL_STATUS) AS STATUS_COUNT FROM LIBRARY_RESERVE_MATRL_DETAIL lrmd JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY JOIN LIBRARY_MATERIAL_STATUS lms ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY GROUP BY lso.SUBJECT_TITLE ORDER BY TOTAL_MATERIALS DESC;",
    "gold_tables": [
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_SUBJECT_OFFERED",
      "dw#sep#LIBRARY_MATERIAL_STATUS"
    ],
    "mapping": {
      "title": [
        "LIBRARY_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "reserved materials": [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      "material status": [
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_MATERIAL_STATUS_KEY",
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS_KEY"
      ]
    ],
    "sample_id": 108
  },
  {
    "question": "For each instructor, list their name, the number of unique courses they teach, the total number of material assignments, average publication year, and number of distinct status, sorted by the number of unique courses in descending order.",
    "db_id": "dw",
    "sql": "SELECT lci.INSTRUCTOR_NAME, COUNT(DISTINCT lci.COURSE_NAME) AS COURSE_COUNT, COUNT(DISTINCT lrmd.LIBRARY_RESERVE_CATALOG_KEY) AS MATERIAL_ASSIGNMENTS, AVG(lrc_dedup.CATALOG_YEAR) AS AVG_PUBLICATION_YEAR, COUNT(DISTINCT lms.LIBRARY_MATERIAL_STATUS) AS STATUS_COUNT FROM LIBRARY_COURSE_INSTRUCTOR lci JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY LEFT JOIN (SELECT LIBRARY_RESERVE_CATALOG_KEY, MAX(CATALOG_YEAR) AS CATALOG_YEAR FROM LIBRARY_RESERVE_CATALOG GROUP BY LIBRARY_RESERVE_CATALOG_KEY) lrc_dedup ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc_dedup.LIBRARY_RESERVE_CATALOG_KEY LEFT JOIN LIBRARY_MATERIAL_STATUS lms ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY GROUP BY lci.INSTRUCTOR_NAME ORDER BY COURSE_COUNT DESC;",
    "gold_tables": [
      "dw#sep#LIBRARY_COURSE_INSTRUCTOR",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#LIBRARY_MATERIAL_STATUS"
    ],
    "mapping": {
      "name": [
        "LIBRARY_COURSE_INSTRUCTOR.INSTRUCTOR_NAME"
      ],
      "course": [
        "LIBRARY_COURSE_INSTRUCTOR.COURSE_NAME"
      ],
      "material assignments": [
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ],
      "publication year": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_YEAR"
      ],
      "status": [
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_MATERIAL_STATUS_KEY",
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS_KEY"
      ]
    ],
    "sample_id": 109
  },
  {
    "question": "For each publication year, list the year, the total number of reserved materials, the average length of their titles, distinct number of status, and number of courses, sorted by publication year in descending order.",
    "db_id": "dw",
    "sql": "WITH CatalogData AS (\n  SELECT LIBRARY_RESERVE_CATALOG_KEY, \n         MAX(CATALOG_YEAR) AS CATALOG_YEAR, \n         MAX(LENGTH(CATALOG_TITLE)) AS title_len \n  FROM LIBRARY_RESERVE_CATALOG \n  GROUP BY LIBRARY_RESERVE_CATALOG_KEY\n),\nYearlyAvg AS (\n  SELECT CATALOG_YEAR, \n         COUNT(*) AS TOTAL_MATERIALS,\n         AVG(title_len) AS AVG_TITLE_LENGTH\n  FROM CatalogData\n  GROUP BY CATALOG_YEAR\n),\nYearlyStats AS (\n  SELECT cd.CATALOG_YEAR,\n         COUNT(DISTINCT lms.LIBRARY_MATERIAL_STATUS) AS STATUS_COUNT,\n         COUNT(DISTINCT lci.COURSE_NAME) AS COURSE_COUNT\n  FROM CatalogData cd\n  JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON cd.LIBRARY_RESERVE_CATALOG_KEY = lrmd.LIBRARY_RESERVE_CATALOG_KEY\n  JOIN LIBRARY_MATERIAL_STATUS lms ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY\n  JOIN LIBRARY_COURSE_INSTRUCTOR lci ON lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY\n  GROUP BY cd.CATALOG_YEAR\n)\nSELECT ya.CATALOG_YEAR AS PUBLICATION_YEAR, ya.TOTAL_MATERIALS, ya.AVG_TITLE_LENGTH,\n       COALESCE(ys.STATUS_COUNT, 0) AS STATUS_COUNT, COALESCE(ys.COURSE_COUNT, 0) AS COURSE_COUNT\nFROM YearlyAvg ya\nLEFT JOIN YearlyStats ys ON ya.CATALOG_YEAR = ys.CATALOG_YEAR\nORDER BY PUBLICATION_YEAR DESC;",
    "gold_tables": [
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_MATERIAL_STATUS",
      "dw#sep#LIBRARY_COURSE_INSTRUCTOR"
    ],
    "mapping": {
      "publication year": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_YEAR"
      ],
      "reserved materials": [
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      "title": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_TITLE"
      ],
      "status": [
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS"
      ],
      "courses": [
        "LIBRARY_COURSE_INSTRUCTOR.COURSE_NAME"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_MATERIAL_STATUS_KEY",
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY",
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ]
    ],
    "sample_id": 110
  },
  {
    "question": "For each IAP category, list the category name, the sponsor name, the number of activities offered, and the average fee per activity, sorted by the number of activities in descending order.",
    "db_id": "dw",
    "sql": "SELECT isc.IAP_CATEGORY_NAME AS CATEGORY_NAME, iss.SPONSOR_NAME, COUNT(isd.IAP_SUBJECT_CATEGORY_KEY) AS ACTIVITY_COUNT, AVG(isd.FEE) AS AVG_FEE_PER_ACTIVITY FROM IAP_SUBJECT_DETAIL isd JOIN IAP_SUBJECT_CATEGORY isc ON isd.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY JOIN IAP_SUBJECT_SPONSOR iss ON isd.IAP_SUBJECT_SPONSOR_KEY = iss.IAP_SUBJECT_SPONSOR_KEY GROUP BY isc.IAP_CATEGORY_NAME, iss.SPONSOR_NAME ORDER BY ACTIVITY_COUNT DESC;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#IAP_SUBJECT_CATEGORY",
      "dw#sep#IAP_SUBJECT_SPONSOR"
    ],
    "mapping": {
      "category name": [
        "IAP_SUBJECT_CATEGORY.IAP_CATEGORY_NAME"
      ],
      "sponsor name": [
        "IAP_SUBJECT_SPONSOR.SPONSOR_NAME"
      ],
      "activities": [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_CATEGORY_KEY"
      ],
      "fee": [
        "IAP_SUBJECT_DETAIL.FEE"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_CATEGORY_KEY",
        "IAP_SUBJECT_CATEGORY.IAP_SUBJECT_CATEGORY_KEY"
      ],
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SPONSOR_KEY",
        "IAP_SUBJECT_SPONSOR.IAP_SUBJECT_SPONSOR_KEY"
      ]
    ],
    "sample_id": 111
  },
  {
    "question": "For each sponsor, list the sponsor name, the number of IAP sessions hosted, and the number of unique subjects organized.",
    "db_id": "dw",
    "sql": "SELECT iss.SPONSOR_NAME, COUNT(DISTINCT issp.IAP_SUBJECT_SESSION_KEY) AS SESSION_COUNT, COUNT(DISTINCT isd.ACTIVITY_TITLE) AS UNIQUE_SUBJECTS FROM IAP_SUBJECT_SESSION issp JOIN IAP_SUBJECT_DETAIL isd ON issp.IAP_SUBJECT_SESSION_KEY = isd.IAP_SUBJECT_SESSION_KEY JOIN IAP_SUBJECT_SPONSOR iss ON isd.IAP_SUBJECT_SPONSOR_KEY = iss.IAP_SUBJECT_SPONSOR_KEY GROUP BY iss.SPONSOR_NAME ORDER BY SESSION_COUNT DESC;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_SESSION",
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#IAP_SUBJECT_SPONSOR"
    ],
    "mapping": {
      "sponsor name": [
        "IAP_SUBJECT_SPONSOR.SPONSOR_NAME"
      ],
      "IAP sessions": [
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY"
      ],
      "subjects": [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY",
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY"
      ],
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SPONSOR_KEY",
        "IAP_SUBJECT_SPONSOR.IAP_SUBJECT_SPONSOR_KEY"
      ]
    ],
    "sample_id": 112
  },
  {
    "question": "For each person role and IAP category, list the role, the category name, the number of people in this role, and the average fee, sorted by the role count in descending order.",
    "db_id": "dw",
    "sql": "SELECT isp.PERSON_ROLE, isc.IAP_CATEGORY_NAME, COUNT(DISTINCT isp.IAP_SUBJECT_PERSON_KEY) AS ROLE_COUNT, AVG(isd.FEE) AS AVG_FEE FROM IAP_SUBJECT_PERSON isp LEFT JOIN IAP_SUBJECT_DETAIL isd ON isp.IAP_SUBJECT_PERSON_KEY = isd.IAP_SUBJECT_PERSON_KEY LEFT JOIN IAP_SUBJECT_CATEGORY isc ON isd.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY GROUP BY isp.PERSON_ROLE, isc.IAP_CATEGORY_NAME ORDER BY ROLE_COUNT DESC;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_PERSON",
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#IAP_SUBJECT_CATEGORY"
    ],
    "mapping": {
      "role": [
        "IAP_SUBJECT_PERSON.PERSON_ROLE"
      ],
      "category name": [
        "IAP_SUBJECT_CATEGORY.IAP_CATEGORY_NAME"
      ],
      "people": [
        "IAP_SUBJECT_PERSON.IAP_SUBJECT_PERSON_KEY"
      ],
      "fee": [
        "IAP_SUBJECT_DETAIL.FEE"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_PERSON.IAP_SUBJECT_PERSON_KEY",
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_PERSON_KEY"
      ],
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_CATEGORY_KEY",
        "IAP_SUBJECT_CATEGORY.IAP_SUBJECT_CATEGORY_KEY"
      ]
    ],
    "sample_id": 113
  },
  {
    "question": "List the names of the buildings with the most floors. If there are ties, list each one separately.",
    "db_id": "dw",
    "sql": "WITH FloorsPerBuilding AS ( SELECT fb.BUILDING_NAME,  MAX(CAST(ff.LEVEL_ID AS SIGNED)) - MIN(CAST(ff.LEVEL_ID AS SIGNED)) AS NUM_FLOORS FROM FAC_BUILDING fb JOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY JOIN FAC_FLOOR ff ON fr.FLOOR_KEY = ff.FLOOR_KEY GROUP BY fb.BUILDING_NAME ), MaxFloors AS ( SELECT MAX(NUM_FLOORS) AS MAX_FLOORS FROM FloorsPerBuilding ) SELECT a.BUILDING_NAME FROM FloorsPerBuilding a JOIN MaxFloors b ON a.NUM_FLOORS = b.MAX_FLOORS;",
    "gold_tables": [
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_FLOOR"
    ],
    "mapping": {
      "name of the buildings": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "floors": [
        "FAC_FLOOR.LEVEL_ID"
      ]
    },
    "join_keys": [
      [
        "FAC_ROOMS.BUILDING_KEY",
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ],
      [
        "FAC_FLOOR.FLOOR_KEY",
        "FAC_ROOMS.FLOOR_KEY"
      ]
    ],
    "sample_id": 114
  },
  {
    "question": "For subjects offered in the summer term, list the subject titles, number of instructors, and the length of the longest instructor name.",
    "db_id": "dw",
    "sql": "SELECT ccso.SUBJECT_CODE, ccso.SUBJECT_TITLE, COUNT(DISTINCT e.FULL_NAME) AS Num_Instructors, MAX(LENGTH(e.FULL_NAME)) AS Longest_Instructor_Name FROM COURSE_CATALOG_SUBJECT_OFFERED ccso LEFT JOIN EMPLOYEE_DIRECTORY e ON ccso.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID WHERE ccso.TERM_CODE LIKE '%SU' GROUP BY ccso.SUBJECT_CODE, ccso.SUBJECT_TITLE;",
    "gold_tables": [
      "dw#sep#EMPLOYEE_DIRECTORY",
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED"
    ],
    "mapping": {
      "summer term": [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE"
      ],
      "subject titles": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "instructors": [
        "EMPLOYEE_DIRECTORY.FULL_NAME"
      ],
      "instructor name": [
        "EMPLOYEE_DIRECTORY.FULL_NAME"
      ]
    },
    "join_keys": [
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID",
        "EMPLOYEE_DIRECTORY.MIT_ID"
      ]
    ],
    "sample_id": 115
  },
  {
    "question": "For the mailing list with owner key LIST69.377-keeper-xenon, list the owner, total number of mailing lists, and total number of members across all these mailing lists.",
    "db_id": "dw",
    "sql": "SELECT mlo.OWNER, COUNT(DISTINCT mld.MOIRA_LIST_KEY) AS Total_Lists, (SELECT COUNT(DISTINCT mld2.MOIRA_LIST_MEMBER) FROM MOIRA_LIST_DETAIL mld2 WHERE mld2.MOIRA_LIST_KEY IN (SELECT DISTINCT mld3.MOIRA_LIST_KEY FROM MOIRA_LIST_DETAIL mld3 WHERE mld3.MOIRA_LIST_OWNER_KEY = 'LIST69.377-keeper-xenon')) AS Total_Members FROM MOIRA_LIST_DETAIL mld JOIN MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY WHERE mlo.MOIRA_LIST_OWNER_KEY = 'LIST69.377-keeper-xenon' GROUP BY mlo.OWNER;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MOIRA_LIST_OWNER"
    ],
    "mapping": {
      "owner key": [
        "MOIRA_LIST_OWNER.MOIRA_LIST_OWNER_KEY"
      ],
      "owner": [
        "MOIRA_LIST_OWNER.OWNER"
      ],
      "mailing lists": [
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ],
      "members": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_OWNER_KEY",
        "MOIRA_LIST_OWNER.MOIRA_LIST_OWNER_KEY"
      ]
    ],
    "sample_id": 116
  },
  {
    "question": "For each school, list the school name, total number of courses that appear in SIS subject code catalog, and the total number of degree-granting courses that appear in SIS subject code catalog.",
    "db_id": "dw",
    "sql": "SELECT sd.SCHOOL_NAME, COUNT(DISTINCT scd.COURSE) AS Total_Courses, COUNT(CASE WHEN scd.IS_DEGREE_GRANTING = 'Y' THEN 1 END) AS Num_Degree_Granting_Y FROM SIS_COURSE_DESCRIPTION scd JOIN SIS_DEPARTMENT sd ON scd.DEPARTMENT = sd.DEPARTMENT_CODE JOIN SIS_SUBJECT_CODE ssc ON scd.COURSE = ssc.COURSE_NUMBER GROUP BY sd.SCHOOL_NAME;",
    "gold_tables": [
      "dw#sep#SIS_COURSE_DESCRIPTION",
      "dw#sep#SIS_DEPARTMENT",
      "dw#sep#SIS_SUBJECT_CODE"
    ],
    "mapping": {
      "school name": [
        "SIS_DEPARTMENT.SCHOOL_NAME"
      ],
      "courses": [
        "SIS_COURSE_DESCRIPTION.COURSE"
      ],
      "degree-granting courses": [
        "SIS_COURSE_DESCRIPTION.IS_DEGREE_GRANTING"
      ]
    },
    "join_keys": [
      [
        "SIS_COURSE_DESCRIPTION.DEPARTMENT",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      [
        "SIS_COURSE_DESCRIPTION.COURSE",
        "SIS_SUBJECT_CODE.COURSE_NUMBER"
      ]
    ],
    "sample_id": 117
  },
  {
    "question": "For each department, list the department name, department phone number, number of students, and the length of the longest student full name in that department.",
    "db_id": "dw",
    "sql": "SELECT sd.DEPARTMENT_NAME, sad.DEPARTMENT_PHONE_NUMBER, COUNT(DISTINCT msd.EMAIL_ADDRESS) AS Num_Students, MAX(LENGTH(msd.FULL_NAME)) AS Longest_Student_Name_Length FROM MIT_STUDENT_DIRECTORY msd JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE LEFT JOIN SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE GROUP BY sd.DEPARTMENT_NAME, sad.DEPARTMENT_PHONE_NUMBER;",
    "gold_tables": [
      "dw#sep#MIT_STUDENT_DIRECTORY",
      "dw#sep#SIS_DEPARTMENT",
      "dw#sep#SIS_ADMIN_DEPARTMENT"
    ],
    "mapping": {
      "department name": [
        "SIS_DEPARTMENT.DEPARTMENT_NAME"
      ],
      "department phone number": [
        "SIS_ADMIN_DEPARTMENT.DEPARTMENT_PHONE_NUMBER"
      ],
      "students": [
        "MIT_STUDENT_DIRECTORY.EMAIL_ADDRESS"
      ],
      "student full name": [
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ]
    },
    "join_keys": [
      [
        "MIT_STUDENT_DIRECTORY.DEPARTMENT",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      [
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_CODE",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ]
    ],
    "sample_id": 118
  }
]